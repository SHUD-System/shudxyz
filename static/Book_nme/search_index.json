[["index.html", "数值地球 绪论 0.1 数值方法在地球科学中的重要性 0.2 本书的目标与特色 0.3 主要内容概览 0.4 学习建议 0.5 代码示例：简单的数值积分 0.6 结语", " 数值地球 舒乐乐，孟宪红 2025-09-16 绪论 0.1 数值方法在地球科学中的重要性 地球科学是研究地球系统各组成部分及其相互作用的综合性学科，涵盖大气科学、水文学、地质学、地貌学、环境科学等多个领域。随着科学技术的不断发展和计算能力的快速提升，数值方法已成为现代地球科学研究中不可或缺的重要工具。 数值方法在地球科学中的应用 数值方法通过将复杂的物理过程转化为数学方程，并利用计算机进行数值求解，使我们能够： 模拟复杂的地球系统过程：从大气环流到地下水流动，从冰川运动到地震波传播 预测未来变化趋势：气候变化预测、洪水预报、地震预警等 优化资源管理：水资源配置、环境治理、灾害防控等 验证理论假设：通过数值实验验证科学理论的有效性 0.2 本书的目标与特色 本书旨在为地球科学领域的学生、研究人员和工程师提供一套系统、实用的数值方法教材。我们采用理论与实践相结合的方式，通过丰富的代码示例和实际应用案例，帮助读者： 掌握数值方法的基本原理：理解各种数值方法的数学基础和适用条件 学会编程实现：使用R语言实现各种数值算法 解决实际问题：将数值方法应用于具体的地球科学问题 培养计算思维：提高利用计算机解决科学问题的能力 0.3 主要内容概览 本书共分为六个主要章节，内容安排如下： 0.3.1 第一章：建模基本方法论 介绍CLAMS方法（概念模型、物理定律、假设、数学公式、求解器），这是将现实世界问题转化为可计算数学模型的标准流程。详见??。 0.3.2 第二章：数值方法基础 讲解显式与隐式求解法、数值迭代方法等基础概念，为后续章节的学习奠定基础。详见??。 0.3.3 第三章：有限差分法 详细介绍泰勒级数展开、差分格式构造、稳定性分析等有限差分法的核心内容。详见??。 0.3.4 第四章：有限元法 深入探讨变分原理、形函数理论、单元矩阵构造等有限元法的理论基础和实现方法。详见??。 0.3.5 第五章：有限体积法 系统介绍控制体积、通量计算、离散化方程等有限体积法的关键概念。详见??。 0.3.6 第六章：应用案例 通过大气科学、水文学、地质学、环境科学等领域的实际案例，展示数值方法的具体应用。详见??。 0.4 学习建议 为了更好地学习本书内容，建议读者： 具备必要的数学基础：微积分、线性代数、常微分方程等 熟悉R语言编程：本书所有代码示例均使用R语言实现 动手实践：认真完成每章的练习题和编程作业 理论联系实际：将所学方法应用到自己的研究领域 0.5 代码示例：简单的数值积分 让我们通过一个简单的例子来感受数值方法的魅力。考虑计算定积分： \\[\\int_0^1 e^{-x^2} dx\\] 这个积分没有解析解，但我们可以用数值方法近似计算： # 使用梯形法则进行数值积分 trapezoidal_rule &lt;- function(f, a, b, n) { h &lt;- (b - a) / n x &lt;- seq(a, b, length.out = n + 1) y &lt;- f(x) return(h * (sum(y) - 0.5 * (y[1] + y[length(y)]))) } # 定义被积函数 f &lt;- function(x) exp(-x^2) # 计算积分值 result &lt;- trapezoidal_rule(f, 0, 1, 1000) cat(&quot;数值积分结果:&quot;, result, &quot;\\n&quot;) cat(&quot;与精确值比较:&quot;, abs(result - 0.7468241), &quot;\\n&quot;) # 可视化积分过程 library(ggplot2) x_plot &lt;- seq(0, 1, length.out = 100) y_plot &lt;- f(x_plot) df &lt;- data.frame(x = x_plot, y = y_plot) ggplot(df, aes(x = x, y = y)) + geom_line(color = &quot;blue&quot;, size = 1) + geom_area(fill = &quot;lightblue&quot;, alpha = 0.3) + labs(title = &quot;数值积分示例：∫₀¹ e^(-x²) dx&quot;, x = &quot;x&quot;, y = &quot;f(x) = e^(-x²)&quot;) + theme_minimal() 这个简单的例子展示了数值方法如何帮助我们解决看似复杂的问题。在后续章节中，我们将学习更多高级的数值方法，并探索它们在地球科学中的广泛应用。 0.6 结语 数值方法作为现代科学计算的核心工具，在地球科学研究中发挥着越来越重要的作用。掌握这些方法不仅能够帮助我们更好地理解地球系统的运行机制，还能为解决人类面临的环境挑战提供科学依据。 希望本书能够成为您学习数值方法的良师益友，帮助您在地球科学的道路上走得更远。让我们一起探索数值方法的奥秘，为地球科学的进步贡献自己的力量。 "],["ch1_modeling.html", "第 1 建模基本方法论 1.1 建模基本思路 1.2 解析解与数值解 1.3 典型控制方程", " 第 1 建模基本方法论 本章介绍数值方法建模的基本方法论，涉及一些基础的建模思路和数学基础。 1.1 建模基本思路 我称之为CLAMS方法，包含以下步骤： Conceptual Model - 描述物理过程，形成概念模型（或认知模型） Laws of Physics - 使用物理规律 Assumptions - 列出合理假设，简化问题 Math equations - 使用数学公式表达物理规律和假设 Solver - 求解数学公式 求解数学公式的过程，可以尝试寻找其解析解(Analytical solution)，也可以使用数值方法求得数值解(Numerical Solution)。 数值方法本质上是对离散（非连续）时空模型中因变量(Dependant variable)分布和变化的数学近似描述，从理论的解析解到数值解虽然损失了精度，但解析解通常无法求得，而数值方法可给出误差可接受的近似解。 CLAMS方法应用案例：落体运动 描述 问题描述下图。 落体运动示意图 问题：任意\\(t&gt;0\\)时刻的速度，即\\(v(t) = ?\\)。 建模步骤： 认知模型： 落体运动(Fall motion): 落体运动是指物体在重力作用下从一定高度自由下落的运动。 当考虑风阻时，物体的运动会受到空气阻力的影响，这种阻力通常与物体的速度、形状、大小以及空气的密度有关。在实际的落体运动中，空气阻力会对物体的速度产生显著影响，主要体现在以下几个方面： 减小物体的加速度：在自由落体运动中，如果不考虑空气阻力，物体将以恒定的加速度（重力加速度）下落。但当考虑空气阻力时，物体受到的合外力将不再等于其重力，导致物体的净加速度减小。根据牛顿第二定律，物体的净加速度等于合外力除以物体的质量。因此，空气阻力的存在会导致物体的速度增长速度减慢。 使物体达到终端速度：随着物体下落速度的增加，空气阻力也会增大，直到与重力相平衡。此时，物体的速度不再增加，达到一个恒定值，这个速度称为终端速度。终端速度取决于物体的形状、大小以及空气的密度。一般来说，形状较大、大小较小的物体终端速度较小，而形状较小、大小较大的物体终端速度较大。 影响物体的下落轨迹：空气阻力不仅影响物体的速度，还可能影响物体的下落轨迹。例如，在北半球自由落体运动中，空气阻力可能导致物体的偏离，使得落体运动的轨迹发生偏移。 在实际应用中，如汽车空气动力学研究，风阻是一个重要的考虑因素。通过风洞实验和数值计算，可以研究模型周围流动的物理特征，理解气动力产生机理，研究气动力控制方法等。这些研究有助于优化汽车等物体的设计，以减少风阻、提高效率。 总的来说，考虑风阻的落体运动是一个复杂的物理过程，涉及到流体力学、物体的动力学特性以及环境因素等多个方面。通过实验和理论分析，可以更准确地描述和预测物体在实际环境中的运动行为。 物理定律： 牛顿定律： \\(F = ma\\)。 牛顿第二定律的描述是：物体的加速度与作用在物体上的合外力成正比，与物体的质量成反比，且加速度的方向与合外力的方向相同。牛顿第二定律是经典力学中描述物体运动的基本定律之一，由艾萨克·牛顿在1687年出版的《自然哲学的数学原理》中提出。 假设： 假设1：\\(v(t=0) = 0\\) 假设2：\\(F_{drag}(t) \\propto v(t)\\)，即\\(F_{drag} = cv\\)。 假设1属于初始条件，即进行计算最一开始的系统状态，基于这个“初始状态”系统开始变化。 假设2属于系统内过程的假设，这里假设了风的阻力与运动速度的一次方成正比。我们其实也可以假设风阻力与速度的二次方成正比，这一假设在实际应用中更常见。 数学公式： 由\\(F = ma\\)和\\(\\frac{dv}{dt} = a\\)可得： \\[\\tag{1} \\frac{dv}{dt} = a = \\frac{F}{m}\\] 根据物体受力分析, 其受到向下的重力\\(F_{g} = mg\\)和向上的空气阻力\\(F_{drag} = cv\\)，空气阻力在此假设与物体运动速度成正比关系。则其受力平衡公式为： \\[\\tag{2} F = F_{g} - F_{drag} = mg - cv\\] 综合公式（1）和（2），则得到： \\[\\tag{3} \\frac{dv}{dt} = g - \\frac{c}{m} v\\] 自由落体运动的受力分析 公式求解： 初始条件：\\(v(0) = 0\\) 积分求解(解析解)： \\[v(t) = \\frac {mg}{c}\\left[ 1- exp(-\\frac{c}{m}t) \\right]\\] 结果绘图： c = 15 # drag coeefficient g = 9.8 # Gravity m = 150 # Mass in kg x = seq(0,100, 1) # Time y = m*g/c *(1 - exp(-1 * c / m * x)) # Vecocity plot(x, y, type=&#39;l&#39;, xlab=&#39;Time (s)&#39;, ylab=&#39;Velocity (m/s)&#39;, col=2, lwd=2); grid() (#fig:example_falling_obj)自由落体运动速度随时间变化曲线 变量表: \\(v(t)\\) - 随时间变化的物体速度 \\(m\\) - 物体质量 \\(g\\) - 重力加速度 \\(a\\) - 物体运动的加速度 \\(c\\) - 空气阻力系数 \\(F\\) - 物体所受的力 \\(F_{g}\\) - 重力 \\(F_{drag}\\) - 空气阻力 1.1.1 落体运动的数值求解方法 前一节我们使用了解析解对落体运动进行了求解。但是现实中很多问题很难寻找的解析解，但是可以通过不同的数值方法和计算方案得到所需时间和空间上某一变量的数值解，数值解是解析解的近似。 针对以上的落体运动，我们首先跳过CLAMS方法的前4步，我们使用数值方法来完成Solver这个步骤。 1.1.1.1 求解数学公式(Solver) 初始条件：\\(v(0) = 0\\) 控制方程：\\[\\frac{dv}{dt} = g - \\frac{c}{m} v\\] 根据极限理论，当时间不长无限趋近于0时，我们可以根据前一时刻的系统状态（状态），和此时的变化趋势（导数）计算出相邻时刻的系统状态（未来状态）。 则： \\[v_{t+1} = v_{t} + \\frac{dv}{dt} * \\Delta t\\] 更进一步，可得到：\\[v_{t+1} = v_{t} + [g - \\frac{c}{m} \\cdot v_{t}]* \\Delta t\\] 我们可以在Excel中进行如下计算。 Step Time V_t dV/dt V_t+1 V_analytic Error ERROR % 1 0 0.0000 4.9000 4.9000 0.0000 0.0000 0 2 0.5 4.9000 4.6550 9.5550 4.7795 0.1205 0.025208325 3 1 9.5550 4.4223 13.9773 9.3259 0.2291 0.024562365 4 1.5 13.9773 4.2011 18.1784 13.6506 0.3266 0.023927978 5 2 18.1784 3.9911 22.1695 17.7644 0.4140 0.023305128 6 2.5 22.1695 3.7915 25.9610 21.6775 0.4919 0.022693776 7 3 25.9610 3.6020 29.5629 25.3998 0.5612 0.022093876 8 3.5 29.5629 3.4219 32.9848 28.9406 0.6224 0.021505376 9 4 32.9848 3.2508 36.2356 32.3086 0.6762 0.02092822 10 4.5 36.2356 3.0882 39.3238 35.5124 0.7231 0.020362349 … … … … 使用R进行计算结果为： c = 15 # drag coeefficient g = 9.8 # Gravity m = 150 # Mass in kg dt = 0.1 x = seq(0,100, dt) # Time # Analytic solution y = m*g/c *(1 - exp(-1 * c / m * x)) # Vecocity # Numeric solution nx= length(x) y_ana = rep(NA, nx) y_ana[1]=0 for(i in 2:nx){ dydt = g - c / m * y_ana[i-1] y_ana[i] = y_ana[i-1] + dydt * dt } df = data.frame(&#39;Time&#39;=x, &#39;V&#39;=y, &#39;V_ana&#39;=y_ana) par(mfrow=c(2, 1), mar=c(3, 3, 1,0)) matplot(x, cbind(y, y_ana), type=&#39;l&#39;, xlab=&#39;Time (s)&#39;, ylab=&#39;Velocity (m/s)&#39;, col=1:2, lwd=2, lty=1:2); grid() legend(&#39;bottomright&#39;, c(&#39;Analytic&#39;, &#39;Numeric&#39;), col=1:2, lwd=2, lty=1:2) grid() plot(abs(y - y_ana)); mtext(&#39;Error&#39;, side=3, line=-2, font=2, cex=2) grid() 1.2 解析解与数值解 数值解(Numeric solution)和解析解(Analytic solution)是解决科学和工程问题时得到的两种不同类型的解。它们的主要区别在于解的形式和求解过程： 形式上的区别： 解析解：通常是一个精确的数学表达式，可以是一个公式、方程或者函数。解析解能够给出问题的完整描述，包括所有的细节和特性。 数值解：是一个近似值，通常是一个数字或者一组数字。数值解是通过数值方法在计算机上计算得到的，只能近似地表示问题的解。 求解过程的区别： 解析解：通过数学推导和符号运算得到。这种方法通常需要对问题进行简化和抽象，以便于找到精确的数学表达式。 数值解：通过数值算法和计算机程序实现。数值方法不需要对问题进行简化，而是直接在计算机上模拟问题的物理过程，通过迭代和逼近来获得解。 精确度： 解析解：是精确的，没有误差，可以提供问题的完整信息。 数值解：是近似的，存在一定的误差。这种误差可能来源于数值方法的离散化、舍入误差等。 适用性： 解析解：适用于那些可以找到精确数学表达式的问题。解析解在理论上非常有价值，因为它们提供了对问题的深入理解。 数值解：适用于那些难以找到解析解的复杂问题，或者解析解过于复杂难以直接使用的情况。数值解在工程和科学实践中非常常见，因为它们可以处理实际问题中的复杂性和不确定性。 计算成本： 解析解：一旦找到，计算成本通常很低，因为解析解可以直接用于计算。 数值解：可能需要较高的计算成本，尤其是在需要高精度解或者问题规模很大时。 通用性： 解析解：通常具有很好的通用性，因为它们是精确的数学表达式，可以应用于各种情况。 数值解：可能需要针对具体问题调整数值方法和参数，以获得更好的近似效果。 简洁地总结了数值解和解析解在不同方面的主要区别。 特性 数值解 解析解 形式 近似值，通常是一个数字或一组数字。 精确的数学表达式，如公式、方程或函数。 求解过程 通过数值算法和计算机程序实现。 通过数学推导和符号运算得到。 精确度 近似，存在误差。 精确，没有误差。 适用性 适用于难以找到解析解的复杂问题。 适用于可以找到精确数学表达式的问题。 计算成本 可能需要较高的计算成本。 一旦找到，计算成本通常很低。 通用性 需要针对具体问题调整数值方法和参数。 具有很好的通用性，可以直接用于计算。 总的来说，解析解和数值解各有优势和局限，选择哪种解法取决于问题的性质、求解的精度要求以及可用的计算资源。在实际应用中，数值解因其灵活性和适用性而被广泛使用。 1.3 典型控制方程 1.3.1 一维承压地下水运动 Sure, let’s derive the governing equation for one-dimensional confined aquifer groundwater flow step by step. We will use Darcy’s Law and the principle of mass conservation. 1.3.1.1 Step 1: Darcy’s Law Darcy’s Law describes the flow of groundwater through porous media. It states that the discharge per unit area (specific discharge or Darcy velocity, \\(q\\)) is proportional to the hydraulic gradient: \\[q = -K \\frac{\\partial h}{\\partial x}\\] where: - \\(q\\) is the specific discharge (Darcy velocity) [L/T]. - \\(K\\) is the hydraulic conductivity of the aquifer [L/T]. - \\(h\\) is the hydraulic head [L]. - \\(x\\) is the spatial coordinate in the direction of flow [L]. 1.3.1.2 Step 2: Conservation of Mass Consider a control volume of length \\(\\Delta x\\), cross-sectional area \\(A\\), and located at position \\(x\\) along the direction of flow within a confined aquifer. 1.3.1.2.1 Inflow and Outflow The rate of inflow at \\(x\\): \\(q(x) \\cdot A\\). The rate of outflow at $ x + x $: \\(q(x + \\Delta x) \\cdot A\\). Using a Taylor series expansion for \\(q(x + \\Delta x)\\): \\[q(x + \\Delta x) \\approx q(x) + \\left( \\frac{\\partial q}{\\partial x} \\right) \\Delta x\\] 1.3.1.2.2 Net Flow The net rate of flow into the control volume is: \\[q(x) \\cdot A - \\left( q(x) + \\left( \\frac{\\partial q}{\\partial x} \\right) \\Delta x \\right) \\cdot A\\] \\[= -A \\left( \\frac{\\partial q}{\\partial x} \\right) \\Delta x\\] 1.3.1.3 Step 3: Storage in the Aquifer The change in storage within the control volume over a time interval \\(\\Delta t\\) can be expressed using the specific storage \\(S_s\\), which is the amount of water per unit volume of the aquifer that is stored or released from storage per unit change in hydraulic head: \\[\\Delta S = S_s \\cdot A \\cdot \\Delta x \\cdot \\frac{\\partial h}{\\partial t} \\cdot \\Delta t\\] 1.3.1.4 Step 4: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of storage in the control volume must equal the net rate of flow into the control volume: \\[-A \\left( \\frac{\\partial q}{\\partial x} \\right) \\Delta x = S_s \\cdot A \\cdot \\Delta x \\cdot \\frac{\\partial h}{\\partial t}\\] 1.3.1.5 Step 5: Substituting Darcy’s Law Substitute \\(q = -K \\frac{\\partial h}{\\partial x}\\) into the equation: \\[-A \\left( \\frac{\\partial}{\\partial x} \\left( -K \\frac{\\partial h}{\\partial x} \\right) \\right) \\Delta x = S_s \\cdot A \\cdot \\Delta x \\cdot \\frac{\\partial h}{\\partial t}\\] Simplify the equation: \\[A \\left( K \\frac{\\partial^2 h}{\\partial x^2} \\right) \\Delta x = S_s \\cdot A \\cdot \\Delta x \\cdot \\frac{\\partial h}{\\partial t}\\] #### Step 6: Simplifying and Rearranging Cancel out the common terms \\(A\\) and \\(\\Delta x\\): \\[K \\frac{\\partial^2 h}{\\partial x^2} = S_s \\frac{\\partial h}{\\partial t}\\] #### Final Governing Equation The one-dimensional groundwater flow equation for a confined aquifer is: \\[\\frac{\\partial h}{\\partial t} = \\frac{K}{S_s} \\frac{\\partial^2 h}{\\partial x^2}\\] Define the hydraulic diffusivity \\(D\\) as: \\[D = \\frac{K}{S_s}\\] Thus, the governing equation can also be written as: \\[\\frac{\\partial h}{\\partial t} = D \\frac{\\partial^2 h}{\\partial x^2}\\] This partial differential equation describes how the hydraulic head \\(h\\) varies with time \\(t\\) and position \\(x\\) within the confined aquifer. 1.3.2 二维承压地下水运动 Sure, let’s derive the governing equation for two-dimensional confined aquifer groundwater flow step by step using Darcy’s Law and the principle of mass conservation. 1.3.2.1 Step 1: Darcy’s Law In two dimensions, Darcy’s Law describes the flow of groundwater through porous media. It states that the discharge per unit area (specific discharge or Darcy velocity, \\(\\mathbf{q}\\)) is proportional to the hydraulic gradient: \\[\\mathbf{q} = -K \\nabla h\\] where: - \\(\\mathbf{q}\\) is the specific discharge (Darcy velocity) vector [L/T]. - \\(K\\) is the hydraulic conductivity of the aquifer [L/T]. - \\(h\\) is the hydraulic head [L]. - \\(\\nabla h\\) is the hydraulic gradient, which in two dimensions can be written as: \\[\\nabla h = \\left( \\frac{\\partial h}{\\partial x}, \\frac{\\partial h}{\\partial y} \\right)\\] 1.3.2.2 Step 2: Conservation of Mass Consider a differential control volume in the aquifer with dimensions \\(dx\\) by \\(dy\\) and thickness \\(b\\). 1.3.2.2.1 Inflow and Outflow For simplicity, let’s assume the flow is in the \\(x\\)- and \\(y\\)-directions. The rate of inflow in the \\(x\\)-direction at \\(x\\): $ q_x(x) b dy $ The rate of inflow in the \\(y\\)-direction at \\(y\\): $ q_y(y) b dx $ The rate of outflow in the \\(x\\)-direction at \\(x + dx\\): \\[q_x(x + dx) \\cdot b \\cdot dy \\approx \\left( q_x(x) + \\frac{\\partial q_x}{\\partial x} dx \\right) \\cdot b \\cdot dy\\] The rate of outflow in the \\(y\\)-direction at \\(y + dy\\): \\[q_y(y + dy) \\cdot b \\cdot dx \\approx \\left( q_y(y) + \\frac{\\partial q_y}{\\partial y} dy \\right) \\cdot b \\cdot dx\\] Net Flow The net rate of flow into the control volume is: \\[\\text{Net inflow in } x\\text{-direction} = \\left[ q_x(x) \\cdot b \\cdot dy \\right] - \\left[ \\left( q_x(x) + \\frac{\\partial q_x}{\\partial x} dx \\right) \\cdot b \\cdot dy \\right]\\] \\[= -b \\cdot dy \\cdot \\frac{\\partial q_x}{\\partial x} dx\\] \\[\\text{Net inflow in } y\\text{-direction} = \\left[ q_y(y) \\cdot b \\cdot dx \\right] - \\left[ \\left( q_y(y) + \\frac{\\partial q_y}{\\partial y} dy \\right) \\cdot b \\cdot dx \\right]\\] \\[= -b \\cdot dx \\cdot \\frac{\\partial q_y}{\\partial y} dy\\] The total net inflow into the control volume is: \\[-b \\left( \\frac{\\partial q_x}{\\partial x} dx \\cdot dy + \\frac{\\partial q_y}{\\partial y} dy \\cdot dx \\right)\\] \\[= -b \\left( \\frac{\\partial q_x}{\\partial x} + \\frac{\\partial q_y}{\\partial y} \\right) dx \\cdot dy\\] #### Step 3: Storage in the Aquifer The change in storage within the control volume over a time interval \\(\\Delta t\\) can be expressed using the specific storage \\(S_s\\): \\[\\Delta S = S_s \\cdot b \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t} \\cdot \\Delta t\\] #### Step 4: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of storage in the control volume must equal the net rate of flow into the control volume: \\[-b \\left( \\frac{\\partial q_x}{\\partial x} + \\frac{\\partial q_y}{\\partial y} \\right) dx \\cdot dy = S_s \\cdot b \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t}\\] #### Step 5: Substituting Darcy’s Law Substitute \\(q_x = -K \\frac{\\partial h}{\\partial x}\\) and \\(q_y = -K \\frac{\\partial h}{\\partial y}\\) into the equation: \\[-b \\left( \\frac{\\partial}{\\partial x} \\left( -K \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( -K \\frac{\\partial h}{\\partial y} \\right) \\right) dx \\cdot dy = S_s \\cdot b \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t}\\] Simplify the equation: \\[b \\left( K \\frac{\\partial^2 h}{\\partial x^2} + K \\frac{\\partial^2 h}{\\partial y^2} \\right) dx \\cdot dy = S_s \\cdot b \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t}\\] #### Step 6: Simplifying and Rearranging Cancel out the common terms \\(b\\), \\(dx\\), and \\(dy\\): \\[K \\left( \\frac{\\partial^2 h}{\\partial x^2} + \\frac{\\partial^2 h}{\\partial y^2} \\right) = S_s \\frac{\\partial h}{\\partial t}\\] #### Final Governing Equation The two-dimensional groundwater flow equation for a confined aquifer is: \\[\\frac{\\partial h}{\\partial t} = \\frac{K}{S_s} \\left( \\frac{\\partial^2 h}{\\partial x^2} + \\frac{\\partial^2 h}{\\partial y^2} \\right)\\] Define the hydraulic diffusivity \\(D\\) as: \\[D = \\frac{K}{S_s}\\] Thus, the governing equation can also be written as: \\[\\frac{\\partial h}{\\partial t} = D \\left( \\frac{\\partial^2 h}{\\partial x^2} + \\frac{\\partial^2 h}{\\partial y^2} \\right)\\] This partial differential equation describes how the hydraulic head \\(h\\) varies with time \\(t\\) and position \\((x, y)\\) within the confined aquifer. 1.3.3 一维非承压地下水运动 Let’s go through the derivation for one-dimensional unconfined aquifer groundwater flow more carefully, considering the variation in aquifer thickness due to changes in the water table. 1.3.3.1 Step-by-Step Derivation for One-Dimensional Unconfined Aquifer 1.3.3.2 Step 1: Darcy’s Law For unconfined groundwater flow, Darcy’s Law in one dimension is: \\[q = -K \\frac{\\partial h}{\\partial x}\\] where: - \\(q\\) is the specific discharge (Darcy velocity) [L/T]. - \\(K\\) is the hydraulic conductivity of the aquifer [L/T]. - \\(h\\) is the hydraulic head [L]. - \\(x\\) is the spatial coordinate in the direction of flow [L]. 1.3.3.3 Step 2: Volumetric Flow Rate The volumetric flow rate \\(Q\\) at a point \\(x\\) for an unconfined aquifer with variable saturated thickness \\(h\\) is given by: \\[Q = q \\cdot b \\cdot h\\] where \\(b\\) is the aquifer width perpendicular to the flow direction. For simplicity, we assume $ b = 1 $ unit width, leading to: \\[Q = q \\cdot h = -K h \\frac{\\partial h}{\\partial x}\\] 1.3.3.4 Step 3: Conservation of Mass Consider a differential control volume in the unconfined aquifer of width \\(dx\\) and saturated thickness $ h(x) $. 1.3.3.4.1 Inflow and Outflow Inflow at \\(x\\): \\(Q(x) = -K h \\frac{\\partial h}{\\partial x}\\) Outflow at \\(x + dx\\): \\(Q(x + dx) = -K h \\frac{\\partial h}{\\partial x} + \\left( \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) \\right) dx\\) 1.3.3.4.2 Net Flow The net inflow into the control volume is: \\[Q(x) - Q(x + dx) = -K h \\frac{\\partial h}{\\partial x} - \\left( -K h \\frac{\\partial h}{\\partial x} + \\left( \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) \\right) dx \\right)\\] \\[= - \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx\\] 1.3.3.5 Step 4: Change in Storage The change in storage within the control volume $ dx h $ over a time interval $ t $ can be expressed using the specific yield \\(S_y\\), which measures the volume of water released from storage per unit decline in the water table: \\[\\Delta S = S_y \\cdot dx \\cdot \\frac{\\partial h}{\\partial t} \\cdot \\Delta t\\] 1.3.3.6 Step 5: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of storage in the control volume must equal the net rate of flow into the control volume: \\[- \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx = S_y \\cdot dx \\cdot \\frac{\\partial h}{\\partial t}\\] 1.3.3.7 Step 6: Simplifying and Rearranging Simplify the equation: \\[\\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right) = S_y \\frac{\\partial h}{\\partial t}\\] 1.3.3.8 Final Governing Equation The one-dimensional groundwater flow equation for an unconfined aquifer is: \\[S_y \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right)\\] This is the governing equation for transient groundwater flow in an unconfined aquifer. It accounts for changes in the saturated thickness \\(h\\) due to fluctuations in the water table. 1.3.4 二维非承压地下水运动 Sure, let’s derive the governing equation for two-dimensional unconfined aquifer groundwater flow step by step. We’ll again use Darcy’s Law, the principle of mass conservation, and the Dupuit assumption, which simplifies the analysis by assuming horizontal flow and a vertical hydraulic gradient. 1.3.4.1 Step-by-Step Derivation for Two-Dimensional Unconfined Aquifer 1.3.4.2 Step 1: Darcy’s Law In two dimensions, Darcy’s Law for an unconfined aquifer can be written as: \\[\\mathbf{q} = -K \\nabla h\\] where: - \\(\\mathbf{q}\\) is the specific discharge (Darcy velocity) vector [L/T]. - \\(K\\) is the hydraulic conductivity of the aquifer [L/T]. - \\(h\\) is the hydraulic head [L]. - \\(\\nabla h\\) is the hydraulic gradient, which in two dimensions can be written as: \\[\\nabla h = \\left( \\frac{\\partial h}{\\partial x}, \\frac{\\partial h}{\\partial y} \\right)\\] 1.3.4.3 Step 2: Volumetric Flow Rate For a control volume in the unconfined aquifer, the volumetric flow rate \\(Q\\) at a point in two dimensions is given by: \\[Q_x = q_x \\cdot h = -K h \\frac{\\partial h}{\\partial x}\\] \\[Q_y = q_y \\cdot h = -K h \\frac{\\partial h}{\\partial y}\\] where \\(h\\) is the saturated thickness of the aquifer. 1.3.4.4 Step 3: Conservation of Mass Consider a differential control volume in the unconfined aquifer with dimensions \\(dx\\) by \\(dy\\) and saturated thickness \\(h\\). 1.3.4.4.1 Inflow and Outflow Inflow in the \\(x\\)-direction at \\(x\\): \\(Q_x(x) = -K h \\frac{\\partial h}{\\partial x}\\) Outflow in the \\(x\\)-direction at \\(x + dx\\): \\(Q_x(x + dx) = -K h \\frac{\\partial h}{\\partial x} + \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx\\) Inflow in the \\(y\\)-direction at \\(y\\): \\(Q_y(y) = -K h \\frac{\\partial h}{\\partial y}\\) Outflow in the \\(y\\)-direction at \\(y + dy\\): \\(Q_y(y + dy) = -K h \\frac{\\partial h}{\\partial y} + \\frac{\\partial}{\\partial y} \\left( -K h \\frac{\\partial h}{\\partial y} \\right) dy\\) 1.3.4.4.2 Net Flow The net inflow into the control volume is: \\[\\text{Net inflow in } x\\text{-direction} = Q_x(x) - Q_x(x + dx)\\] \\[= -K h \\frac{\\partial h}{\\partial x} - \\left( -K h \\frac{\\partial h}{\\partial x} + \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx \\right)\\] \\[= - \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx\\] \\[\\text{Net inflow in } y\\text{-direction} = Q_y(y) - Q_y(y + dy)\\] \\[= -K h \\frac{\\partial h}{\\partial y} - \\left( -K h \\frac{\\partial h}{\\partial y} + \\frac{\\partial}{\\partial y} \\left( -K h \\frac{\\partial h}{\\partial y} \\right) dy \\right)\\] \\[= - \\frac{\\partial}{\\partial y} \\left( -K h \\frac{\\partial h}{\\partial y} \\right) dy\\] The total net inflow into the control volume is: \\[\\text{Net inflow} = - \\left( \\frac{\\partial}{\\partial x} \\left( -K h \\frac{\\partial h}{\\partial x} \\right) dx + \\frac{\\partial}{\\partial y} \\left( -K h \\frac{\\partial h}{\\partial y} \\right) dy \\right)\\] \\[= \\left( \\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right) dx + \\frac{\\partial}{\\partial y} \\left( K h \\frac{\\partial h}{\\partial y} \\right) dy \\right)\\] 1.3.4.5 Step 4: Change in Storage The change in storage within the control volume over a time interval \\(\\Delta t\\) can be expressed using the specific yield \\(S_y\\), which is the volume of water released from storage per unit surface area per unit decline in the water table: \\[\\Delta S = S_y \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t} \\cdot \\Delta t\\] 1.3.4.6 Step 5: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of storage in the control volume must equal the net rate of flow into the control volume: \\[\\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right) dx + \\frac{\\partial}{\\partial y} \\left( K h \\frac{\\partial h}{\\partial y} \\right) dy = S_y \\cdot dx \\cdot dy \\cdot \\frac{\\partial h}{\\partial t}\\] 1.3.4.7 Step 6: Simplifying and Rearranging Divide through by $ dx dy $: \\[\\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K h \\frac{\\partial h}{\\partial y} \\right) = S_y \\frac{\\partial h}{\\partial t}\\] 1.3.4.8 Final Governing Equation The two-dimensional groundwater flow equation for an unconfined aquifer is: \\[S_y \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( K h \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K h \\frac{\\partial h}{\\partial y} \\right)\\] This is the governing equation for transient groundwater flow in a two-dimensional unconfined aquifer. It accounts for the variation in the saturated thickness \\(h\\) due to fluctuations in the water table and assumes horizontal flow and a vertical hydraulic gradient, as per the Dupuit approximation. 1.3.5 三维非承压地下水运动 You are right. The Dupuit assumption is primarily applicable to simplifying two-dimensional flow problems in unconfined aquifers by assuming horizontal flow and neglecting vertical gradients. For a three-dimensional unconfined aquifer groundwater flow, we need to take a different approach that does not rely on the Dupuit assumption. Let’s derive the governing equation for three-dimensional unconfined aquifer groundwater flow without using the Dupuit assumption, considering the changes in storage and flow in all three dimensions properly. 1.3.5.1 Step-by-Step Derivation for Three-Dimensional Unconfined Aquifer 1.3.5.2 Step 1: Darcy’s Law In three dimensions, Darcy’s Law for groundwater flow in an unconfined aquifer is given by: \\[\\mathbf{q} = -K \\nabla h\\] where: - \\(\\mathbf{q}\\) is the specific discharge (Darcy velocity) vector [L/T]. - \\(K\\) is the hydraulic conductivity of the aquifer [L/T]. - \\(h\\) is the hydraulic head [L]. - \\(\\nabla h\\) is the hydraulic gradient, which in three dimensions is written as: \\[\\nabla h = \\left( \\frac{\\partial h}{\\partial x}, \\frac{\\partial h}{\\partial y}, \\frac{\\partial h}{\\partial z} \\right)\\] 1.3.5.3 Step 2: Conservation of Mass Consider a differential control volume in the unconfined aquifer with dimensions \\(dx\\), \\(dy\\), and \\(dz\\), where \\(z\\) is the vertical direction. 1.3.5.3.1 Inflow and Outflow Inflow in the \\(x\\)-direction at \\(x\\): \\(Q_x(x) = q_x A_x = -K \\frac{\\partial h}{\\partial x} A_x\\), where \\(A_x = dy \\cdot dz\\) is the cross-sectional area perpendicular to the \\(x\\)-direction. Outflow in the \\(x\\)-direction at \\(x + dx\\): \\(Q_x(x + dx) = \\left( q_x + \\frac{\\partial q_x}{\\partial x} dx \\right) A_x\\) Similarly, for the \\(y\\)- and \\(z\\)-directions: Inflow in the \\(y\\)-direction at \\(y\\): \\(Q_y(y) = q_y A_y = -K \\frac{\\partial h}{\\partial y} A_y\\), where \\(A_y = dx \\cdot dz\\). Outflow in the \\(y\\)-direction at \\(y + dy\\): \\(Q_y(y + dy) = \\left( q_y + \\frac{\\partial q_y}{\\partial y} dy \\right) A_y\\) Inflow in the \\(z\\)-direction at \\(z\\): \\(Q_z(z) = q_z A_z = -K \\frac{\\partial h}{\\partial z} A_z\\), where \\(A_z = dx \\cdot dy\\). Outflow in the \\(z\\)-direction at \\(z + dz\\): \\(Q_z(z + dz) = \\left( q_z + \\frac{\\partial q_z}{\\partial z} dz \\right) A_z\\) 1.3.5.3.2 Net Flow The net inflow into the control volume is the sum of the net inflows in each direction: \\[\\text{Net inflow in } x\\text{-direction} = Q_x(x) - Q_x(x + dx)\\] \\[= \\left( -K \\frac{\\partial h}{\\partial x} \\right) A_x - \\left( -K \\frac{\\partial h}{\\partial x} + \\frac{\\partial}{\\partial x} \\left( -K \\frac{\\partial h}{\\partial x} \\right) dx \\right) A_x\\] \\[= - A_x \\frac{\\partial}{\\partial x} \\left( -K \\frac{\\partial h}{\\partial x} \\right) dx\\] Similarly, \\[\\text{Net inflow in } y\\text{-direction} = - A_y \\frac{\\partial}{\\partial y} \\left( -K \\frac{\\partial h}{\\partial y} \\right) dy\\] \\[\\text{Net inflow in } z\\text{-direction} = - A_z \\frac{\\partial}{\\partial z} \\left( -K \\frac{\\partial h}{\\partial z} \\right) dz\\] The total net inflow into the control volume is: \\[\\text{Net inflow} = - \\left( \\frac{\\partial}{\\partial x} \\left( -K \\frac{\\partial h}{\\partial x} \\right) dx \\cdot dy \\cdot dz + \\frac{\\partial}{\\partial y} \\left( -K \\frac{\\partial h}{\\partial y} \\right) dx \\cdot dy \\cdot dz + \\frac{\\partial}{\\partial z} \\left( -K \\frac{\\partial h}{\\partial z} \\right) dx \\cdot dy \\cdot dz \\right)\\] \\[= \\left( \\frac{\\partial}{\\partial x} \\left( K \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K \\frac{\\partial h}{\\partial y} \\right) + \\frac{\\partial}{\\partial z} \\left( K \\frac{\\partial h}{\\partial z} \\right) \\right) dx \\cdot dy \\cdot dz\\] 1.3.5.4 Step 3: Change in Storage The change in storage within the control volume over a time interval \\(\\Delta t\\) can be expressed using the specific yield \\(S_y\\), which is the volume of water released from storage per unit surface area per unit decline in the water table: \\[\\Delta S = S_y \\cdot dx \\cdot dy \\cdot dz \\cdot \\frac{\\partial h}{\\partial t} \\cdot \\Delta t\\] 1.3.5.5 Step 4: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of storage in the control volume must equal the net rate of flow into the control volume: \\[S_y \\frac{\\partial h}{\\partial t} \\cdot dx \\cdot dy \\cdot dz = \\left( \\frac{\\partial}{\\partial x} \\left( K \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K \\frac{\\partial h}{\\partial y} \\right) + \\frac{\\partial}{\\partial z} \\left( K \\frac{\\partial h}{\\partial z} \\right) \\right) dx \\cdot dy \\cdot dz\\] 1.3.5.6 Step 5: Simplifying and Rearranging Divide through by $ dx dy dz $: \\[S_y \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( K \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K \\frac{\\partial h}{\\partial y} \\right) + \\frac{\\partial}{\\partial z} \\left( K \\frac{\\partial h}{\\partial z} \\right)\\] 1.3.5.7 Final Governing Equation The three-dimensional groundwater flow equation for an unconfined aquifer is: \\[S_y \\frac{\\partial h}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( K \\frac{\\partial h}{\\partial x} \\right) + \\frac{\\partial}{\\partial y} \\left( K \\frac{\\partial h}{\\partial y} \\right) + \\frac{\\partial}{\\partial z} \\left( K \\frac{\\partial h}{\\partial z} \\right)\\] This equation describes the transient groundwater flow in a three-dimensional unconfined aquifer, accounting for variations in the hydraulic head in all three spatial dimensions. This derivation does not rely on the Dupuit assumption, making it suitable for three-dimensional flow problems. 1.3.6 一维热传导方程 Let’s go through the step-by-step derivation of the one-dimensional heat conduction equation based on Fourier’s law in a structured manner. 1.3.6.1 Step 1: Fourier’s Law of Heat Conduction Fourier’s law states that the heat flux \\(q\\) (amount of heat per unit area per unit time) is proportional to the negative gradient of the temperature \\(T\\): \\[q = -k \\frac{\\partial T}{\\partial x}\\] where: \\(q\\)is the heat flux [W/m\\(^2\\)]. \\(k\\)is the thermal conductivity of the material [W/(m·K)]. \\(\\frac{\\partial T}{\\partial x}\\)is the temperature gradient in the\\(x\\)-direction [K/m]. 1.3.6.2 Step 2: Energy Conservation in a Differential Element Consider a small differential control volume of length\\(dx\\), cross-sectional area\\(A\\), and located at position \\(x\\) along the rod’s length. 1.3.6.2.1 Heat Entering and Leaving the Control Volume The rate of heat entering at \\(x\\): \\(q(x) \\cdot A\\) The rate of heat leaving at \\(x + dx\\): \\(q(x + dx) \\cdot A\\) Using a Taylor series expansion for \\(q(x + dx)\\): \\[q(x + dx) \\approx q(x) + \\left( \\frac{\\partial q}{\\partial x} \\right) dx\\] 1.3.6.2.2 Net Heat Flow The net rate of heat entering the differential element is: \\[q(x) \\cdot A - \\left( q(x) + \\left( \\frac{\\partial q}{\\partial x} \\right) dx \\right) \\cdot A\\] \\[= -A \\left( \\frac{\\partial q}{\\partial x} \\right) dx\\] 1.3.6.3 Step 3: Heat Storage in the Differential Element The change in internal energy (\\(\\Delta U\\)) within the differential element over a time interval \\(\\Delta t\\) can be expressed using the specific heat capacity \\(c\\) and density \\(\\rho\\) of the material: \\[\\Delta U = \\rho \\cdot c \\cdot A \\cdot dx \\cdot \\frac{\\partial T}{\\partial t} \\cdot \\Delta t\\] 1.3.6.4 Step 4: Applying Conservation of Energy Assuming no internal heat generation and applying the conservation of energy principle, the rate of heat entering the control volume must equal the rate of energy storage within the control volume: \\[-A \\left( \\frac{\\partial q}{\\partial x} \\right) dx = \\rho \\cdot c \\cdot A \\cdot dx \\cdot \\frac{\\partial T}{\\partial t}\\] 1.3.6.5 Step 5: Substituting Fourier’s Law Substitute\\(q = -k \\frac{\\partial T}{\\partial x}\\)into the equation: \\[-A \\left( \\frac{\\partial}{\\partial x} \\left( -k \\frac{\\partial T}{\\partial x} \\right) \\right) dx = \\rho \\cdot c \\cdot A \\cdot dx \\cdot \\frac{\\partial T}{\\partial t}\\] Simplify the equation: \\[A \\left( k \\frac{\\partial^2 T}{\\partial x^2} \\right) dx = \\rho \\cdot c \\cdot A \\cdot dx \\cdot \\frac{\\partial T}{\\partial t}\\] 1.3.6.6 Step 6: Simplifying and Rearranging Cancel out the common terms\\(A\\)and\\(dx\\): \\[k \\frac{\\partial^2 T}{\\partial x^2} = \\rho c \\frac{\\partial T}{\\partial t}\\] Divide both sides by\\(\\rho c\\): \\[\\frac{\\partial T}{\\partial t} = \\frac{k}{\\rho c} \\frac{\\partial^2 T}{\\partial x^2}\\] Define the thermal diffusivity\\(\\alpha\\)as: \\[\\alpha = \\frac{k}{\\rho c}\\] 1.3.6.7 Final Governing Equation The one-dimensional heat conduction equation (also called the heat diffusion equation) is: \\[\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\\] This partial differential equation describes how the temperature \\(T\\) varies with time \\(t\\) and position \\(x\\) within the material. 1.3.7 一维溶质运移-扩散方程 Sure, let’s derive the governing equation for a one-dimensional solute advection-diffusion problem step by step. This equation describes how the solute concentration changes over time due to both advection (transport by the flow of the water) and diffusion (spreading due to concentration gradients). 1.3.7.1 Step-by-Step Derivation for One-Dimensional Solute Advection-Diffusion 1.3.7.2 Step 1: Define Variables \\(c(x, t)\\): Solute concentration [M/L³]. \\(u\\): Velocity of the fluid in the x-direction [L/T]. \\(D\\): Diffusion coefficient [L²/T]. \\(x\\): Spatial coordinate in the x-direction [L]. \\(t\\): Time [T]. 1.3.7.3 Step 2: Conservation of Mass (Continuity Equation) Consider a differential control volume of length \\(dx\\) in the x-direction. 1.3.7.3.1 Inflow and Outflow by Advection Inflow of solute by advection at position \\(x\\): \\[ J_{\\text{adv,in}} = u c(x, t) \\] Outflow of solute by advection at position $ x + dx $: \\[ J_{\\text{adv,out}} = u c(x + dx, t) \\approx u \\left( c(x, t) + \\frac{\\partial c}{\\partial x} dx \\right) \\] 1.3.7.3.2 Inflow and Outflow by Diffusion Inflow of solute by diffusion at position \\(x\\): \\[ J_{\\text{diff,in}} = -D \\frac{\\partial c}{\\partial x} \\] Outflow of solute by diffusion at position $ x + dx $: \\[ J_{\\text{diff,out}} = -D \\frac{\\partial c}{\\partial x} \\Bigg|_{x+dx} \\approx -D \\left( \\frac{\\partial c}{\\partial x} + \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial c}{\\partial x} \\right) dx \\right) \\] 1.3.7.4 Step 3: Net Flow The net inflow of solute into the control volume is the difference between the inflow and outflow due to both advection and diffusion. 1.3.7.4.1 Net Advection Flow \\[ \\text{Net advective flow} = J_{\\text{adv,in}} - J_{\\text{adv,out}} = u c(x, t) - u \\left( c(x, t) + \\frac{\\partial c}{\\partial x} dx \\right) = -u \\frac{\\partial c}{\\partial x} dx \\] 1.3.7.4.2 Net Diffusion Flow \\[ \\text{Net diffusive flow} = J_{\\text{diff,in}} - J_{\\text{diff,out}} = -D \\frac{\\partial c}{\\partial x} - \\left( -D \\left( \\frac{\\partial c}{\\partial x} + \\frac{\\partial}{\\partial x} \\left( \\frac{\\partial c}{\\partial x} \\right) dx \\right) \\right) = D \\frac{\\partial^2 c}{\\partial x^2} dx \\] 1.3.7.5 Step 4: Change in Storage The change in solute mass within the control volume over a time interval \\(\\Delta t\\) is: \\[ \\Delta S = \\frac{\\partial c}{\\partial t} dx \\Delta t \\] 1.3.7.6 Step 5: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of solute storage in the control volume must equal the net rate of solute flow into the control volume: \\[ \\frac{\\partial c}{\\partial t} dx = -u \\frac{\\partial c}{\\partial x} dx + D \\frac{\\partial^2 c}{\\partial x^2} dx \\] 1.3.7.7 Step 6: Simplifying and Rearranging Divide through by \\(dx\\): \\[ \\frac{\\partial c}{\\partial t} = -u \\frac{\\partial c}{\\partial x} + D \\frac{\\partial^2 c}{\\partial x^2} \\] 1.3.7.8 Final Governing Equation The final governing equation for the one-dimensional solute advection-diffusion problem is: \\[ \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = D \\frac{\\partial^2 c}{\\partial x^2} \\] This partial differential equation describes how the solute concentration \\(c\\) varies with time \\(t\\) and position \\(x\\) due to advection by the flow field \\(u\\) and diffusion characterized by the diffusion coefficient \\(D\\). 1.3.8 二维溶质运移-扩散方程 Let’s derive the governing equation for a two-dimensional solute advection-diffusion problem step by step. This equation describes how a solute concentration changes over time due to both advection (transport by the flow of the water) and diffusion (spreading due to concentration gradients). 1.3.8.1 Step-by-Step Derivation for Two-Dimensional Solute Advection-Diffusion 1.3.8.2 Step 1: Define Variables $ c(x, y, t) $: solute concentration [M/L³]. \\(u\\): velocity component in the x-direction [L/T]. \\(v\\): velocity component in the y-direction [L/T]. \\(D_x\\): diffusion coefficient in the x-direction [L²/T]. \\(D_y\\): diffusion coefficient in the y-direction [L²/T]. 1.3.8.3 Step 2: Conservation of Mass (Continuity Equation) Consider a differential control volume in the \\(x\\)-\\(y\\) plane with dimensions \\(dx\\) and \\(dy\\). 1.3.8.3.1 Inflow and Outflow Inflow of solute by advection in the \\(x\\)-direction at \\(x\\): \\[u(x) c(x) \\cdot dy\\] Outflow of solute by advection in the \\(x\\)-direction at $ x + dx $: \\[u(x + dx) c(x + dx) \\cdot dy \\approx (u(x) c(x) + \\frac{\\partial}{\\partial x} (u c) dx) \\cdot dy\\] Inflow of solute by advection in the \\(y\\)-direction at \\(y\\): \\[v(y) c(y) \\cdot dx\\] Outflow of solute by advection in the \\(y\\)-direction at $ y + dy $: \\[v(y + dy) c(y + dy) \\cdot dx \\approx (v(y) c(y) + \\frac{\\partial}{\\partial y} (v c) dy) \\cdot dx\\] Inflow of solute by diffusion in the \\(x\\)-direction at \\(x\\): \\[-D_x \\frac{\\partial c}{\\partial x} \\cdot dy\\] Outflow of solute by diffusion in the \\(x\\)-direction at $ x + dx $: \\[-D_x \\frac{\\partial c}{\\partial x} \\cdot dy - \\frac{\\partial}{\\partial x} \\left( -D_x \\frac{\\partial c}{\\partial x} \\right) dx \\cdot dy\\] Inflow of solute by diffusion in the \\(y\\)-direction at \\(y\\): \\[-D_y \\frac{\\partial c}{\\partial y} \\cdot dx\\] Outflow of solute by diffusion in the \\(y\\)-direction at $ y + dy $: \\[-D_y \\frac{\\partial c}{\\partial y} \\cdot dx - \\frac{\\partial}{\\partial y} \\left( -D_y \\frac{\\partial c}{\\partial y} \\right) dy \\cdot dx\\] 1.3.8.3.2 Net Flow The net inflow of solute into the control volume due to advection and diffusion is: \\[\\text{Net inflow in } x\\text{-direction} = \\left( u(x) c(x) \\cdot dy - (u(x + dx) c(x + dx) \\cdot dy) \\right) + \\left( -D_x \\frac{\\partial c}{\\partial x} \\cdot dy - \\left( -D_x \\frac{\\partial c}{\\partial x} - \\frac{\\partial}{\\partial x} \\left( -D_x \\frac{\\partial c}{\\partial x} \\right) dx \\right) dy \\right)\\] \\[= - \\frac{\\partial}{\\partial x} \\left( u c \\right) dx \\cdot dy + \\frac{\\partial}{\\partial x} \\left( D_x \\frac{\\partial c}{\\partial x} \\right) dx \\cdot dy\\] Similarly, for the \\(y\\)-direction: \\[\\text{Net inflow in } y\\text{-direction} = - \\frac{\\partial}{\\partial y} \\left( v c \\right) dy \\cdot dx + \\frac{\\partial}{\\partial y} \\left( D_y \\frac{\\partial c}{\\partial y} \\right) dy \\cdot dx\\] The total net inflow of solute into the control volume is: \\[\\text{Total net inflow} = \\left( \\frac{\\partial}{\\partial x} \\left( D_x \\frac{\\partial c}{\\partial x} \\right) - \\frac{\\partial}{\\partial x} \\left( u c \\right) \\right) dx \\cdot dy + \\left( \\frac{\\partial}{\\partial y} \\left( D_y \\frac{\\partial c}{\\partial y} \\right) - \\frac{\\partial}{\\partial y} \\left( v c \\right) \\right) dy \\cdot dx\\] 1.3.8.4 Step 3: Change in Storage The change in solute mass within the control volume over a time interval $ t $ is: \\[\\Delta S = \\frac{\\partial c}{\\partial t} \\cdot dx \\cdot dy \\cdot \\Delta t\\] 1.3.8.5 Step 4: Applying Conservation of Mass According to the conservation of mass principle, the rate of change of solute storage in the control volume must equal the net rate of solute flow into the control volume: \\[\\frac{\\partial c}{\\partial t} = \\left( \\frac{\\partial}{\\partial x} \\left( D_x \\frac{\\partial c}{\\partial x} \\right) - \\frac{\\partial}{\\partial x} \\left( u c \\right) \\right) + \\left( \\frac{\\partial}{\\partial y} \\left( D_y \\frac{\\partial c}{\\partial y} \\right) - \\frac{\\partial}{\\partial y} \\left( v c \\right) \\right)\\] 1.3.8.6 Step 5: Simplifying and Rearranging Combine the terms and rearrange: \\[\\frac{\\partial c}{\\partial t} = D_x \\frac{\\partial^2 c}{\\partial x^2} + D_y \\frac{\\partial^2 c}{\\partial y^2} - \\frac{\\partial}{\\partial x} \\left( u c \\right) - \\frac{\\partial}{\\partial y} \\left( v c \\right)\\] 1.3.8.7 Final Governing Equation The final governing equation for the two-dimensional solute advection-diffusion problem is: \\[\\frac{\\partial c}{\\partial t} + \\frac{\\partial}{\\partial x} (u c) + \\frac{\\partial}{\\partial y} (v c) = D_x \\frac{\\partial^2 c}{\\partial x^2} + D_y \\frac{\\partial^2 c}{\\partial y^2}\\] This partial differential equation describes how the solute concentration \\(c\\) varies with time \\(t\\) and position $ (x, y) $ due to advection by the flow field $ (u, v) $ and diffusion characterized by the diffusion coefficients \\(D_x\\) and \\(D_y\\). "],["ch2_nm.html", "第 2 数值方法基础 2.1 隐式与显式求解法 2.2 数值迭代方法 2.3 有限元, 有限差分 ,有限体积 2.4 CFL条件约束 2.5 时空离散化 2.6 初始条件 2.7 边界条件", " 第 2 数值方法基础 2.1 隐式与显式求解法 数值方法可分为显式求解(Explicit method)与隐式求解(Implicit method)： Definition 2.1 (显式求解法) 当下一时刻变量由前一时刻变量直接计算得到的，称为显式求解法。数学表达可写为： \\[Y(t+\\Delta t)=F(Y(t))\\] Definition 2.2 (隐式求解法) 当下一时刻变量由一系列公式、矩阵或者迭代算法计算得到，称为隐式求解法。数学表达可写为： \\[G(Y(t), Y(t+\\Delta t))=0\\] 相同时空分辨率条件下，显式求解法的计算速度显著高于隐式求解法，但是隐式求解法可以保证计算的稳定性，因此可采用较大时间步长进行计算，而显式求解法必须受制于CFL条件。 2.2 数值迭代方法 2.2.1 牛顿迭代(Newton Iteration) 牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），是一种在实数域和复数域上近似求解方程的方法。方法使用函数\\(f (x)\\)的泰勒级数的前面几项来寻找方程\\(f(x) = 0\\)的根。 以下我们将通过一个实例，展示如何使用R语言实现牛顿迭代法。 我们选取的方程是 \\(e^x - 3x = 0\\)，这是一个没有显式解的方程。我们的目标是找到这个方程的一个根。 牛顿迭代法的核心思想是利用函数在某点的切线来逼近函数的根。其迭代公式如下： \\[x_{n+1} = x_n - \\frac{f(x_n)}{f&#39;(x_n)}\\] 其中，\\(x_n\\) 是第 n 次迭代的近似值，\\(f(x)\\) 是我们要解决的方程，\\(f&#39;(x)\\) 是 \\(f(x)\\) 的导数。 下面是使用R语言实现牛顿迭代法求解 \\(e^x - 3x = 0\\) 的代码： # 定义方程 f(x) 和它的导数 f_prime(x) f &lt;- function(x) { return(exp(x) - 3 * x) } f_prime &lt;- function(x) { return(exp(x) - 3) } # 牛顿迭代法 newton_method &lt;- function(f, f_prime, x0, tol = 1e-6, max_iter = 1000) { x &lt;- x0 for (i in 1:max_iter) { x_new &lt;- x - f(x) / f_prime(x) if (abs(x_new - x) &lt; tol) { return(x_new) } x &lt;- x_new } warning(&quot;迭代未收敛&quot;) return(x) } # 初始猜测值 x0 &lt;- 1.0 # 执行牛顿迭代 root &lt;- newton_method(f, f_prime, x0) # 输出结果 cat(&quot;方程 e^x - 3x = 0 的近似根为：&quot;, root, &quot;\\n&quot;) ## 方程 e^x - 3x = 0 的近似根为： 0.6190613 牛顿迭代法虽然是一种非常有效的数值方法，但它也存在一些局限性，以下是一些主要的局限性： 初始猜测的重要性：牛顿迭代法的收敛速度和是否收敛很大程度上取决于初始猜测值。如果初始猜测远离实际根，迭代可能会发散，或者收敛到错误的根。 导数的计算：牛顿迭代法需要计算函数的导数。对于一些复杂的函数，这可能非常困难或者计算成本很高。 不可导函数：如果函数在某些点不可导，或者导数为零，牛顿迭代法可能无法应用或者失效。 多根问题：对于具有多个根的方程，牛顿迭代法可能只收敛到其中的一个根，这取决于初始猜测值。它可能无法找到所有的根。 奇点附近的问题：如果函数在根的附近有奇点（例如，函数值或导数趋向于无穷大），牛顿迭代法可能无法正确工作。 全局收敛性：牛顿迭代法通常保证局部收敛，但不保证全局收敛。这意味着即使方程有多个根，迭代过程也可能只收敛到离初始猜测最近的根。 数值稳定性：在某些情况下，由于浮点数的精度限制，牛顿迭代法可能产生数值不稳定。 以下是这些局限性的详细说明： 初始猜测的重要性 收敛性：如果初始猜测接近实际根，牛顿迭代法通常能快速收敛。但如果初始猜测远离根，或者接近函数的拐点，迭代可能发散。 根的选择：对于具有多个根的方程，迭代可能只收敛到某个特定的根，这取决于初始猜测。 导数的计算 复杂性：对于复杂的函数，计算导数可能非常困难，尤其是当函数涉及多个变量或者嵌套的数学表达式时。 成本：在某些情况下，导数的计算可能比函数本身的计算还要昂贵。 -不可导函数 应用限制：如果函数在某点不可导，或者导数为零，牛顿迭代法的迭代公式将无法应用。 多根问题 局部收敛：牛顿迭代法可能只找到离初始猜测最近的根，而忽略了其他根。 奇点附近的问题 发散：如果函数在根的附近有奇点，迭代过程可能会发散。 全局收敛性 局限性：牛顿迭代法不保证找到方程的所有根，特别是当根分布复杂时。 数值稳定性 精度问题：由于计算机的有限精度，牛顿迭代法可能产生舍入误差，影响结果的准确性。 了解这些局限性有助于我们更好地选择和使用牛顿迭代法，以及采取相应的策略来克服这些问题，例如使用更好的初始猜测，或者结合其他数值方法来提高解的可靠性。 2.2.2 欧拉方法(Euler Method) 在数学和计算机科学中，欧拉方法，命名自它的发明者萊昂哈德·歐拉，是一种一阶数值方法，用以对给定初值的常微分方程（即初值問題）求解。它是常微分方程數值方法中最基本的显式方法（Explicit method）。 欧拉方法是一个一阶方法，意味着其局部截断误差（每步误差）正比于步长的平方，并且其全局截断误差正比于步长。欧拉方法经常应用于作为构建一些更复杂方法的基础，例如，预估-校正方法。 Definition 2.3 (欧拉方法) 欧拉方法数学表达为: \\[y^{\\prime}(t)=f(t, y(t))\\] \\[y(t_0) = y_0\\] 求解时： \\[y_{n+1} = y_n + h f&#39;(t_n, y_n)\\] 其中\\(t_n = t0+nh\\)，\\(h\\)即迭代步长， \\(h = t_{n+1} - t _{n}\\)。 欧拉方法属于显式求解法。 Example 2.1 已知函数： \\[\\frac{dy}{dt} = y\\] \\[y(0)=1\\] 求：\\[y(4) = ?\\] # source: https://en.wikipedia.org/wiki/Euler_method # ============ # SOLUTION to # y&#39; = y, where y&#39; = f(t,y) # then: f &lt;- function(ti,y) y # INITIAL VALUES: t0 &lt;- 0 y0 &lt;- 1 h &lt;- .1 tn &lt;- 4 # Euler&#39;s method: function definition Euler &lt;- function(t0, y0, h, tn, dy.dt) { # dy.dt: derivative function # t sequence: tt &lt;- seq(t0, tn, by=h) # table with as many rows as tt elements: tbl &lt;- data.frame(ti=tt) tbl$yi &lt;- y0 # Initializes yi with y0 tbl$Dy.dt[1] &lt;- dy.dt(tbl$ti[1],y0) # derivative for (i in 2:nrow(tbl)) { tbl$yi[i] &lt;- tbl$yi[i-1] + h*tbl$Dy.dt[i-1] # For next iteration: tbl$Dy.dt[i] &lt;- dy.dt(tbl$ti[i],tbl$yi[i]) } return(tbl) } # Euler&#39;s method: function application r &lt;- Euler(t0, y0, h, tn, f) rownames(r) &lt;- 0:(nrow(r)-1) # to coincide with index n # Exact solution for this case: y = exp(t) # added as an additional column to r r$y &lt;- exp(r$ti) plot(r$ti, r$y, type=&quot;l&quot;, col=&quot;red&quot;, lwd=2) lines(r$ti, r$yi, col=&quot;blue&quot;, lwd=2) grid(col=&quot;black&quot;) legend(&quot;top&quot;, legend = c(&quot;Exact&quot;, &quot;Euler&quot;), lwd=2, col = c(&quot;red&quot;, &quot;blue&quot;)) # TABLE with results: print(r) ## ti yi Dy.dt y ## 0 0.0 1.000000 1.000000 1.000000 ## 1 0.1 1.100000 1.100000 1.105171 ## 2 0.2 1.210000 1.210000 1.221403 ## 3 0.3 1.331000 1.331000 1.349859 ## 4 0.4 1.464100 1.464100 1.491825 ## 5 0.5 1.610510 1.610510 1.648721 ## 6 0.6 1.771561 1.771561 1.822119 ## 7 0.7 1.948717 1.948717 2.013753 ## 8 0.8 2.143589 2.143589 2.225541 ## 9 0.9 2.357948 2.357948 2.459603 ## 10 1.0 2.593742 2.593742 2.718282 ## 11 1.1 2.853117 2.853117 3.004166 ## 12 1.2 3.138428 3.138428 3.320117 ## 13 1.3 3.452271 3.452271 3.669297 ## 14 1.4 3.797498 3.797498 4.055200 ## 15 1.5 4.177248 4.177248 4.481689 ## 16 1.6 4.594973 4.594973 4.953032 ## 17 1.7 5.054470 5.054470 5.473947 ## 18 1.8 5.559917 5.559917 6.049647 ## 19 1.9 6.115909 6.115909 6.685894 ## 20 2.0 6.727500 6.727500 7.389056 ## 21 2.1 7.400250 7.400250 8.166170 ## 22 2.2 8.140275 8.140275 9.025013 ## 23 2.3 8.954302 8.954302 9.974182 ## 24 2.4 9.849733 9.849733 11.023176 ## 25 2.5 10.834706 10.834706 12.182494 ## 26 2.6 11.918177 11.918177 13.463738 ## 27 2.7 13.109994 13.109994 14.879732 ## 28 2.8 14.420994 14.420994 16.444647 ## 29 2.9 15.863093 15.863093 18.174145 ## 30 3.0 17.449402 17.449402 20.085537 ## 31 3.1 19.194342 19.194342 22.197951 ## 32 3.2 21.113777 21.113777 24.532530 ## 33 3.3 23.225154 23.225154 27.112639 ## 34 3.4 25.547670 25.547670 29.964100 ## 35 3.5 28.102437 28.102437 33.115452 ## 36 3.6 30.912681 30.912681 36.598234 ## 37 3.7 34.003949 34.003949 40.447304 ## 38 3.8 37.404343 37.404343 44.701184 ## 39 3.9 41.144778 41.144778 49.402449 ## 40 4.0 45.259256 45.259256 54.598150 2.2.3 龙格-库塔方法(Runge-Kutta Method) 数值分析中，龙格-库塔方法（Runge-Kutta Methods）是用于非线性常微分方程的解的重要的一类隐式或显式迭代法。这些技术由数学家卡尔·龙格和马丁·威尔海姆·库塔于1900年左右发明。 Definition 2.4 (4阶Runge-Kutta) 4阶Runge-Kutta方法的基本步骤如下： 计算\\(k_1 = f(x_n, y_n)\\) 计算\\(k_2 = f(x_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1)\\) 计算\\(k_3 = f(x_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2)\\) 计算\\(k_4 = f(x_n + h, y_n + hk_3)\\) 更新\\(y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\\) 例子1: 考虑以下常微分方程初值问题： \\[y&#39; = 1 + (y - x)^2, \\quad y(0) = 0.5\\] 我们需要使用4阶Runge-Kutta方法（RK4）来数值求解该微分方程在区间\\((0, 2)\\)上的解。 接下来我们将使用R语言实现该数值解法。 # 4阶Runge-Kutta方法 rungeKutta4 &lt;- function(func, x0, y0, x_end, n) { h &lt;- (x_end - x0) / n x &lt;- x0 y &lt;- y0 results &lt;- data.frame(x = x0, y = y0) for (i in 1:n) { k1 &lt;- func(x, y) k2 &lt;- func(x + 0.5 * h, y + 0.5 * h * k1) k3 &lt;- func(x + 0.5 * h, y + 0.5 * h * k2) k4 &lt;- func(x + h, y + h * k3) y &lt;- y + h/6 * (k1 + 2*k2 + 2*k3 + k4) x &lt;- x + h results &lt;- rbind(results, data.frame(x = x, y = y)) } return(results) } # 定义微分方程 dydx &lt;- function(x, y) { return(1 + (y - x)^2) } # 初始条件 x0 &lt;- 0 y0 &lt;- 0.5 x_end &lt;- 2 n &lt;- 10 # 步数 # 计算 results &lt;- rungeKutta4(dydx, x0, y0, x_end, n) # 打印结果 print(results) ## x y ## 1 0.0 0.5000000 ## 2 0.2 0.7555552 ## 3 0.4 1.0249990 ## 4 0.6 1.3142831 ## 5 0.8 1.6333266 ## 6 1.0 1.9999816 ## 7 1.2 2.4499414 ## 8 1.4 3.0664221 ## 9 1.6 4.0983141 ## 10 1.8 6.7645620 ## 11 2.0 42.9981995 plot(results$x, results$y, type=&#39;o&#39;) grid() 例子2： 考虑以下常微分方程初值问题： \\[y&#39; = -2xy, \\quad y(0) = 1\\] 我们将使用4阶Runge-Kutta方法（RK4）来数值求解该微分方程在区间\\((0, 1)\\)上的解。 以下是R语言的实现代码： # 定义微分方程 dydx &lt;- function(x, y) { return(-2 * x * y) } # 初始条件 x0 &lt;- 0 y0 &lt;- 1 x_end &lt;- 1 n &lt;- 50 # 步数 # 计算 results &lt;- rungeKutta4(dydx, x0, y0, x_end, n) # 打印结果 plot(results$x, results$y, type=&#39;o&#39;) grid() 2.2.4 皮卡法(Picard Method) 皮卡逐次逼近法（Picard Successive Approximation Method）是常微分方程解的一种主要近似计算方法。皮卡(Picard,(C.-)É)最早在数学上完善处理这样的逐次逼近的函数序列，所以称为皮卡逐次逼近法。 2.3 有限元, 有限差分 ,有限体积 数值方法中主要有有限差分（Finite Difference, FD）、有限元（Finite Element, FE）和有限体积（Finite Volume，FV）法三类。三类方法并无明显优劣之分，但其中各有特点。有限差分法方法简洁，物理意义清晰，编程容易，因而是水文/气象领域应用最多的方法。 有限元法可以保证全局物质/能量守恒，但是无法保证局部守恒；有限体积法弥补了有限元这一缺陷，既可以保证全局守恒，也可以保证局部守恒。 三类方法的数学的意义略有不同：有限差分法计算为空间某一点的值，有限元法计算某一计算单元内的近似拟合曲线，有限体积法作为有限元法的特例，计算该计算单元内的均值。因此对于三种不同方法计算的结果的解读应当略有不同，但实际模型用户层面通常将其视为相同含义。 三种数值方法对比 2.4 CFL条件约束 CFL条件是数值方法求解常/偏微分方程保证其收敛性和稳定性的必要条件，但不是充分条件；以Courant， Fredrichs和Lewy共同命名（cite）。CFL条件即数值方法的时间步长要足够小，方能够保证计算精度，否则结果不收敛或者不稳定。 最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。 Definition 2.5 (CFL条件) CFL条件数学表达形式为： \\[\\frac {c \\Delta t} {\\Delta x ^n} &lt; C_{max}\\] 其中\\(c\\)即为系统中变量的变化速率。\\(C_{max}\\)是保持求解系统稳定和收敛的最大值，常见值为0.5。有的系统中\\(n=1\\)，但有的科学问题中\\(n&gt;1\\)。 2.5 时空离散化 空间离散化，即分割连续的空间称为空间若干子集的过程,由一维\\(\\Delta x\\), 二维\\((\\Delta x, \\Delta y)\\), 或者三维\\((\\Delta x, \\Delta y, \\Delta z)\\)构成的最小计算单元或质点。 时间离散化即模型时间步长，即\\(\\Delta t\\)。 时间步长和空间分辨率的组合关系，对于数值方法求解的稳定性和收敛性都有显著影响。CFL条件是限制因素。为保证数值方法稳定性，空间分辨率越高，则要求时间分辨率也越高，时间分辨率与空间分辨率的（一次或多次）幂存在正比关系。 一维空间离散化 二维空间离散化 三维空间离散化 通常的空间离散化分为结构化(Structured)与非结构化(Unstructured)网格。 结构化网格主要是划分为形状和面积相同的计算单元。矩形规则化网格的好处是：求解过程直观易懂，编程实现简单，并且易于并行化；输入和输出数据都直接使用矩阵方式表达；数据制备、处理和可视化都直观且便捷。规则化网格常见矩形，也有正三角形和正六边形的方案。 非结构化网格的优势在于：（1）更好的表现不规则三维地形；（2）更好的表现不规则研究区(流域）的边界，边界条件处理更合理，其边界条件控制也更符合数值理论；（3）计算单元的面积大小灵活可变，可以在保证整体边界条件情况下，对重点地区进行局部加密——亦或相反设置。非结构化网格既可以保证重点区域的高分辨率，在保证可靠的边界条件情况下，不显著增加计算单元数量，保证重点区域模拟精度和计算负担之间的平衡。非结构化网格的主要缺陷是：（1）计算过程相对复杂，仅支持有限元和有限体积法；（2）数据解读和可视化复杂，需要针对性的数据前处理和后处理软件。 2.6 初始条件 Definition 2.6 (初始条件) 初始条件定义为 \\[y(t_0) = y_0\\] 其中\\(t_0\\)为问题的初始时刻，\\(y_0\\)为初始时刻包含目标变量值的向量。 数值方法研究中，模拟结果对初始条件具有一定敏感性。但是，初始条件的敏感性问题与描述该系统的控制方程有关。部分问题的初始条件误差，可以通过一定时间的模型预热(Spin-up)消除；但另有一部分问题（例如Lorenz System为代表的混沌系统），初始条件敏感性极高。 2.7 边界条件 数值方法的边界条件通常分为Dirichlet和Neumann两类。 Definition 2.7 (第一类边界条件) Dirichlet边界条件(Dirichlet Boundary Condition, DBC)是常/偏微分方程的第一类边界条件，也称为固定边界条件，其指定了空间某点的固定值，比如在地下水中，Dirichlet边界条件限定固定地下水水头高度。 Definition 2.8 (第二类边界条件) 诺伊曼边界条件（Neumann boundary condition, NBC) 也被称为常/偏微分方程的“第二类边界条件”，其给定空间特定位置上目标变量的一阶导数，在地下水问题中，通常某一点处固定的流量，如注水或者取水量。 作为三维的数值模型，两类边界条件都可以施加在空间任意位置的任意方向上。 "],["ch3_fdm.html", "第 3 有限差分法 3.1 泰勒级数(Taylor Series) 3.2 构建数值方法 3.3 显式求解法 3.4 隐式求解法 3.5 编程求解 3.6 显式与隐式求解法对比 3.7 二维有限差分", " 第 3 有限差分法 3.1 泰勒级数(Taylor Series) 泰勒级数（Taylor series）是数学中一个重要的概念，它提供了一种将函数表示为无限项的幂级数的方法。这种表示方法在微积分、复分析、数值分析以及物理学的许多领域中都有广泛的应用。泰勒级数是以于1715年发表了泰勒公式的英國数学家布魯克·泰勒（Sir Brook Taylor）来命名的。 以下是用学术语言对泰勒级数的介绍： 定义： 设函数 \\(f(x)\\) 在点 \\(a\\) 处无限次可微，则该函数在 \\(a\\) 点的泰勒级数展开式为： \\[ f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x-a)^n \\] 其中，\\(f^{(n)}(a)\\) 表示函数 \\(f\\) 在点 \\(a\\) 处的第 \\(n\\) 阶导数，\\(n!\\) 是 \\(n\\) 的阶乘。 收敛性： 泰勒级数的收敛性取决于函数的性质和展开点的选择。根据泰勒定理，如果函数 \\(f(x)\\) 在包含 \\(a\\) 的某个开区间内无限次可微，则对于该区间内的任意 \\(x\\)，泰勒级数都收敛于 \\(f(x)\\)。收敛区间可以通过比值判别法、根值判别法等方法确定。 余项： 泰勒级数的余项（R remainder）是实际函数值与泰勒级数部分和之间的差值。根据泰勒定理，余项 \\(R_n(x)\\) 可以表示为： \\[ R_n(x) = \\frac{f^{(n+1)}(c)}{(n+1)!}(x-a)^{n+1} \\] 其中 \\(c\\) 是 \\(a\\) 和 \\(x\\) 之间的某个点。余项的存在说明了泰勒级数近似的误差。 应用： 泰勒级数在求解复杂函数的近似值、计算定积分、求解微分方程以及在物理学中分析波动和场的传播等方面都有重要应用。通过泰勒级数，可以将难以直接求解的问题转化为多项式问题，从而简化计算。 特殊情形： 当展开点 \\(a = 0\\) 时，泰勒级数称为麦克劳林级数（Maclaurin series），它是泰勒级数的一个特例。 泰勒级数的引入，不仅丰富了数学分析的内容，也为解决实际问题提供了强有力的工具。通过对函数的局部线性化，泰勒级数在理论和应用上都显示出了其独特的价值。 泰勒展开式的基本形式： \\[\\begin{equation} f(x) = \\sum_{k=0}^n \\frac{f^{(n)}(0) }{n!}( x) ^{n} \\tag{3.1} \\end{equation}\\] Taylor Series 根据泰勒展开式，通过\\(f(x)\\)和其任意阶的导数，可以获得任意\\(\\Delta x\\)值下的函数值\\(f(x + \\Delta x)\\) ，即: \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}( \\Delta x) ^{n} \\tag{3.2} \\end{equation}\\] 或者在\\(-\\Delta x\\)位置，可写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 - \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}(- \\Delta x) ^{n} \\tag{3.3} \\end{equation}\\] 以上公式也可以写为： \\[\\begin{equation} u_{i+1} = u_{i} + \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 + \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n} \\tag{3.4} \\end{equation}\\] \\[\\begin{equation} u_{i-1} = u_{i} - \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 - \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}(- \\Delta x) ^{n} \\tag{3.5} \\end{equation}\\] 3.1.1 截断误差 在泰勒级数的应用中，截断误差（truncation error）是一个重要的概念，它描述了当我们使用有限项的泰勒级数来近似一个函数时所产生的误差。 定义： 截断误差是指在泰勒级数展开中，由于只取有限项而忽略剩余无限项所引起的误差， 数学表达为\\(O()\\)。具体来说，如果我们对函数 \\(f(x)\\) 在点 \\(a\\) 处进行泰勒级数展开，并只取前 \\(n\\) 项，那么截断误差就是函数在 \\(x\\) 处的真实值与这 \\(n\\) 项部分和之间的差值。 \\(O(2)\\)和\\(O(3)\\)分别表示为在泰勒展开式上的二阶和三阶导数上的误差。截取误差的阶数越高，误差越小。 数学表达： 如果 \\(f(x)\\) 在 \\(a\\) 处的泰勒级数为： \\[ f(x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(a)}{k!} (x-a)^k \\] 那么，当我们取前 \\(n\\) 项时，截断误差 \\(T_n(x)\\) 可以表示为： \\[ O(n) = f(x) - \\sum_{k=0}^{n} \\frac{f^{(k)}(a)}{k!} (x-a)^k \\] 余项的另一种形式： 在泰勒定理中，余项 \\(R_n(x)\\) 也可以用来描述截断误差。对于拉格朗日形式的余项，我们有： \\[ R_n(x) = \\frac{f^{(n+1)}(c)}{(n+1)!} (x-a)^{n+1} \\] 其中 \\(c\\) 是 \\(a\\) 和 \\(x\\) 之间的某个点。这个余项提供了截断误差的一个上界，即： \\[ |O(x)| \\leq |R_n(x)| \\] \\[O(1) = \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2+\\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(2) = \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(3) = \\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] 影响因素： 截断误差的大小受到多个因素的影响，包括： 1. 函数 \\(f(x)\\) 在 \\(a\\) 附近的平滑性。 2. 点 \\(x\\) 与展开点 \\(a\\) 之间的距离。 3. 所取泰勒级数项数 \\(n\\) 的大小。 减小截断误差： 为了减小截断误差，可以采取以下措施： 1. 增加泰勒级数的项数 \\(n\\)。 2. 选择更接近 \\(x\\) 的展开点 \\(a\\)。 3. 选择一个更平滑的函数或者在更平滑的区间内进行展开。 截断误差是评估泰勒级数近似效果的重要指标，对于数值计算和函数逼近的准确性具有重要意义。在实际应用中，理解和控制截断误差对于提高计算结果的可靠性至关重要。 何种情况下，泰勒展开式的截断误差为0？ \\(O(0) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x)\\)。则该函数为\\(f(x) = C\\), \\(C\\)为常数。 如图： \\(O(1) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x) + f^{&#39;}(x) \\cdot \\Delta x\\)。则该函数为\\(f(x) = ax + b\\)。 如图： 如何依据泰勒级数，得到函数的一阶和二阶导数？ 3.1.2 一阶导数 3.1.2.1 向前估计 (Forward Approximation) 采纳一阶截断误差，我们可将公式(3.2)写为： \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) - f(x) } {\\Delta x} \\tag{3.6} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac {u_{i+1} - u_{i} } {\\Delta x} \\tag{3.6} \\end{equation}\\] 注：公式(3.6)隐含了\\(O(1)\\)的误差。 向前估计 3.1.2.2 向后估计 (Backward Approximation) 采纳一阶截断误差，我们可将公式(3.3)写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x) -f(x+\\Delta x) } {\\Delta x} \\tag{3.7} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i} - u_{i+1}} {\\Delta x} \\tag{3.7} \\end{equation}\\] 注：公式(3.7)隐含了\\(O(1)\\)的误差。 向后估计 3.1.2.3 中心估计 (Central Approximation) 中心估计算法中，我们将从公式(3.2)减去公式(3.3)，得到： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + 2 * \\frac{f^{&#39;&#39;&#39;}(x)}{3!} + ... \\] 截断误差由以上公式右边的第四项（三阶导数）开始，则该公式的截取误差为\\(O(2)\\)，即二阶精度的截取误差，公式表达为： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + O(2) \\] 可得到二阶精度的一阶导数的中心估计： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) -f(x-\\Delta x) } {2\\Delta x} \\tag{3.8} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i+1} - u_{i21}} {2\\Delta x} \\tag{3.8} \\end{equation}\\] 公式(3.8)隐含了\\(O(2)\\)的误差，同时(3.6)和(3.7)都隐含了\\(O(1)\\)的误差。 中心估计 3.1.3 二阶导数 我们将公式 (3.2)和(3.3)相加，可得到： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2 \\cdot f(x) + 0 + 2 \\cdot \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + 0 + 2 \\cdot \\frac{f^{(4)}(x)} {4!} \\Delta x^4 + \\dotsb \\tag{3.9} \\end{equation}\\] 公式(3.9)来自公式 (3.2)和(3.3)的相加，三阶导数项在相加过程中为零，因此我们截取其三阶截取误差，则公式(3.9)可写为： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2f(x) + f^{&#39;&#39;}(x) \\Delta x^2 + O(3) \\tag{3.10} \\end{equation}\\] 根据公式(3.10)，我们可获得函数\\(f(x)\\)在\\(x\\)位置的二阶导数为： \\[\\begin{equation} f^{&#39;&#39;}(x) = \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } + O(3) \\tag{3.11} \\end{equation}\\] 当移除其三阶截断误差\\(O(3)\\)后，我们得到近似的二阶导数： \\[\\begin{align} f^{&#39;&#39;}(x) &amp; \\approx \\frac {1}{ \\Delta x } \\left( \\frac{ f(x+\\Delta x) - f(x) }{ \\Delta x } + \\frac{ f(x) - f(x-\\Delta x) } { \\Delta x } \\right) \\\\ &amp; \\approx \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } \\tag{3.12} \\end{align}\\] 将公式一般化，我们可写为以下形式： \\[\\begin{align} u^{&#39;&#39;}_{i} &amp;\\approx \\frac {1}{ \\Delta x } \\left( \\frac{u_{i+1} - u_{i}}{\\Delta x} - \\frac{u_{i} - u_{i-1}}{\\Delta x} \\right) \\\\ &amp; \\approx \\frac { u_{i+1} - 2u_{i} + u_{i-1} } { \\Delta x^2 } \\\\ \\tag{3.12} \\end{align}\\] 二阶导数估计 3.2 构建数值方法 Example 3.1 一根100\\(cm\\)长的铁棍，初始温度25 \\(^\\circ C\\)，在其左右两边分别持续施加100\\(^\\circ C\\)和\\(50 ^\\circ C\\)的温度。 求解：任意时刻铁棍的温度分布。 参考信息： wiki:Thermal_diffusivity wiki:Heat_equation 为求解这个铁棍中的温度变化问题，我们继续使用@ref{modeling}当中的方法，该方法总结为CLAMS方法：概念描述(Conceptual model)、物理定律(physic Laws)、假设(Assumptions)、 数学推导(Math derivation)、求解(Solver)。 概念描述 空间微分，如图。 物理定律 能量守恒： 能量变化 = 能量流入 - 能量流出 \\[ \\Delta E = Q _{in} - Q _{out} \\] 假设 此问题的假设包括： 铁棍绝热，即两端之外的部分并不存在热传递作用。 忽略热辐射作用。 铁棍的介质/物理属性均一。 数学推导 \\[ 通量 = \\frac {量}{单位时间 \\cdot 单位面积} \\] \\(k\\) - 热传导率[\\(W m^{-1} K ^{-1}\\)]。 \\(c\\) - 比热容(specific heat capacity)[\\(J {kg}^{-1} K ^{-1}\\)]。 \\(\\rho\\) - 密度[\\({kg} m^{-3}\\)]。 \\(A\\) - 截面积[\\(m^2\\)]。 \\(D\\) - 热力学扩散度（Thermal diffusivity）\\(D = \\frac{k}{\\rho c}\\) [\\(m^2 s^{-1}\\)]。 \\[ \\rho * c * \\Delta x * A * \\Delta u = q_{in} * A * \\Delta t - q_{out} * A * \\Delta t\\] 两边同时除以\\(\\rho c \\Delta x A\\)，得到 \\[\\frac {\\Delta u}{\\Delta t} = \\frac{1}{\\rho c} \\frac{q_{in} - q_{out}}{\\Delta x}\\] 以上公式当\\(\\Delta x\\)趋近与0，\\(\\Delta t\\)趋近于0时，得到微分形式： \\[\\frac {\\partial u}{\\partial t} = \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x}\\] \\[q = k \\frac{\\partial u}{\\partial x}\\] 则得到其控制方程： \\[\\begin{equation} \\begin{aligned} \\frac {\\partial u}{\\partial t} &amp;= \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x} \\\\ &amp;= \\frac{1}{\\rho c} \\frac{k \\frac{\\partial u}{\\partial x} } {\\partial x} \\\\ &amp;= D\\frac{\\partial } {\\partial x} \\left(\\frac{\\partial u}{\\partial x} \\right) \\end{aligned} \\end{equation}\\] 令\\(D=\\frac{k}{\\rho c}\\)，单位[\\(m s^{-2}\\)]，则最终控制方程(Governing Equation)写为 \\[\\begin{equation} \\frac {\\partial u}{\\partial t} =D\\frac{\\partial ^2 u} {\\partial x^2} \\tag{3.13} \\end{equation}\\] 控制方程，通常是我们关键数学/数值求解的核心对象，控制方程也是我们对问题最重要的描述，其中已经包含了问题的概念描述、假设、物理定律等信息。 求解 这里我们使用数值方法对本问题进行求解。 由一阶泰勒级数可知，控制方程(3.13)左边(Left Hand Side, LHS)可写为： \\[\\frac {\\partial u}{\\partial t} = D\\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} + O(1)\\] 控制方程(3.13)右边(Right Hand Side, RHS)可写为： \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x} + O(2) \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x} + O(2) \\end{equation}\\] 此时，方程左边在时间尺度上具有一阶截取误差，方程右边在空间尺度上具有二阶截断误差。省去误差项，离散化后控制方程写为： \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x ^2} \\tag{3.14} \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x ^2} \\tag{3.15} \\end{equation}\\] 3.3 显式求解法 显式求解法以公式(3.14)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = 1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + (1- 2\\alpha) u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t}_{1} = U_{0}\\) 2 \\(u^{t}_{2} = \\alpha u^{t-1}_{3} + \\beta u^{t-1}_{2} + \\alpha u^{t-1}_{1}\\) 3 \\(u^{t}_{3} = \\alpha u^{t-1}_{4} + \\beta u^{t-1}_{3} + \\alpha u^{t-1}_{2}\\) 4 \\(u^{t}_{4} = \\alpha u^{t-1}_{5} + \\beta u^{t-1}_{4} + \\alpha u^{t-1}_{3}\\) 5 \\(u^{t}_{5} = \\alpha u^{t-1}_{6} + \\beta u^{t-1}_{5} + \\alpha u^{t-1}_{4}\\) … … i-1 … i \\(u^{t}_{i} = \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1}\\) i+1 … … … n-2 \\(u^{t}_{n-2} = \\alpha u^{t-1}_{n-1} + \\beta u^{t-1}_{n-2} + \\alpha u^{t-1}_{n-3}\\) n-1 \\(u^{t}_{n-1} = \\alpha u^{t-1}_{n} + \\beta u^{t-1}_{n-1} + \\alpha u^{t-1}_{n-2}\\) n 边界条件: \\(u^{t}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} u_{1}^{t} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ u_{n}^{t} \\end{bmatrix} = \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\textcolor{red}{1}} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ U_{L} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t} = \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\textcolor{red}{1}} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t-1} \\end{equation}\\] 下一时刻(\\(t\\))的变量组成的向量\\(x\\)由一个矩阵\\([A]\\)乘以已知的前一时刻(\\(t-1\\))的向量\\(b\\)获得，即：。 \\[ x = [A] * b \\] 由已知变量的矩阵求解未知变量的方法，称为显式求解法。 3.4 隐式求解法 显式求解法以公式(3.15)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = -1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + (-1- 2\\alpha) u^{t}_{i} + \\alpha u^{t}_{i-1} \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t-1}_{1} = U_{0}\\) 2 \\(-u^{t-1}_{2} = \\alpha u^{t}_{3} + \\beta u^{t}_{2} + \\alpha u^{t}_{1}\\) 3 \\(-u^{t-1}_{3} = \\alpha u^{t}_{4} + \\beta u^{t}_{3} + \\alpha u^{t}_{2}\\) 4 \\(-u^{t-1}_{4} = \\alpha u^{t}_{5} + \\beta u^{t}_{4} + \\alpha u^{t}_{3}\\) 5 \\(-u^{t-1}_{5} = \\alpha u^{t}_{6} + \\beta u^{t}_{5} + \\alpha u^{t}_{4}\\) … … i-1 … i \\(-u^{t-1}_{i} = \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1}\\) i+1 … … … n-2 \\(-u^{t-1}_{n-2} = \\alpha u^{t}_{n-1} + \\beta u^{t}_{n-2} + \\alpha u^{t}_{n-3}\\) n-1 \\(-u^{t-1}_{n-1} = \\alpha u^{t}_{n} + \\beta u^{t}_{n-1} + \\alpha u^{t}_{n-2}\\) n 边界条件: \\(u^{t-1}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\textcolor{red}{1}} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ U_{L} \\end{bmatrix} = - \\begin{bmatrix} u_{1}^{t-1} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ u_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\textcolor{red}{1}} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t} = - \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t-1} \\end{equation}\\] 一个矩阵\\([A]\\)乘以下一时刻(\\(t\\))的变量组成的向量\\(x\\)等于已知的前一时刻(\\(t-1\\))的向量\\(b\\)，求解该方程则可得到\\(x\\)的值，数学表达为： \\[[A] * x = b\\] 通用的求解法为 \\[ x = [A]^{-1} * b \\] 通过已知变量、未知变量和矩阵组成的公式或函数来求解未知变量的过程，称为隐式求解法。 3.5 编程求解 显式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.explicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = DD * DT / (DX * DX) beta = 1-2*alpha CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx = cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 隐式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.implicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = -DD * DT / (DX * DX) beta = 1 + 2 * DD * DT / (DX * DX) CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx=cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 3.6 显式与隐式求解法对比 3.6.1 CFL条件 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) xlab =&#39;Distance (m)&#39; ylab = &#39;Temperature (C)&#39; x = HT.implicit(DX= 0.05, DT = 1000, U0=100, UL=50, uic = 25, ignore.cfl=TRUE, plot=FALSE) ## [1] 9.2 plot1(x, nout=10) 3.6.2 计算效率 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) source(&quot;Code/ch03/ch3_HeatTransferEx.R&quot;) Tmax = 1e4 t0 = Sys.time() x=HT.explicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.ex = t1 - t0 t0 = Sys.time() x=HT.implicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.im = t1 - t0 message(&#39;Time for implicit =&#39;, tu.im) ## Time for implicit =0.0986859798431396 message(&#39;Time for explicit =&#39;, tu.ex) ## Time for explicit =0.0623009204864502 3.7 二维有限差分 Example 3.2 \\[ s \\frac{dh}{dt} = k_{x} B * \\frac{d^2 h}{d x^2} + k_{y} B * \\frac{d^2 h}{d y^2} + s_s \\] 令\\(D_x = \\frac{k_x B}{s}\\)和\\(D_y = \\frac{k_y B}{s}\\)。 公式推导： 右边： \\[\\frac{\\partial u}{\\partial t} = \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t}\\] 左边： \\[D_x\\frac{\\partial ^2 u}{\\partial x^2} + D_y\\frac{\\partial ^2 u}{\\partial y^2}= D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2}\\] 控制方程离散化后得到： \\[ \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t} = D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2} \\] \\[u^{t+1}_{i, j} - u^{t}_{i, j}= \\frac{D_x \\Delta t}{ {\\Delta x }^2} (u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} ) + \\frac{D_x \\Delta t}{ {\\Delta y }^2} (u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1})\\] 令\\(\\alpha = \\frac{D_x \\Delta t}{ {\\Delta x }^2}\\), \\(\\beta = \\frac{D_x \\Delta t}{ {\\Delta y }^2}\\), \\(\\gamma = 1-2\\frac{D_x \\Delta t}{ {\\Delta x }^2} - 2\\frac{D_x \\Delta t}{ {\\Delta y }^2}\\)，公式变为： \\[ u^{t+1}_{i, j} = \\alpha u^{t}_{i+1, j} + \\beta u^{t}_{i, j+1} + \\gamma u^{t}_{i, j} + \\beta u^{t}_{i, j-1} + \\alpha u^{t}_{i-1, j} \\] 二维离散化格点 假设\\(x\\)和\\(y\\)方向总长为\\(L_x\\)和\\(L_y\\)，沿两个方向的离散点数为\\(N_x =L_x / \\Delta x\\), \\(N_y =L_y / \\Delta y\\), \\(N = N_x * N_y\\)。 矩阵形式可表达为： \\[ x = A * b \\] \\[x = \\begin{bmatrix} \\begin{bmatrix} u_{1,1} \\\\ \\dots \\\\ u_{1, N_y} \\end{bmatrix} \\\\ \\begin{bmatrix} u_{2,1} \\\\\\dots \\\\ u_{2, N_y} \\end{bmatrix} \\\\ \\dots \\\\ u_{i,j} \\\\ \\dots \\\\ \\begin{bmatrix} u_{Nx, 1} \\\\ \\dots\\\\ u_{N_x, N_y} \\end{bmatrix} \\end{bmatrix} ^{t}\\] \\[A = \\begin{bmatrix} \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\textcolor{red}{1}} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\textcolor{red}{1}} \\end{bmatrix} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\textcolor{red}{1}} \\end{bmatrix} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\textcolor{red}{1}} \\end{bmatrix} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\begin{bmatrix} {\\textcolor{red}{1}} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\textcolor{red}{1}} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\textcolor{red}{1}} \\end{bmatrix} \\\\ \\end{bmatrix} \\] \\[b= \\begin{bmatrix} [U_{1}]_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{2,1} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{i,j} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ [U_{4}]_{N_y*1} \\end{bmatrix} ^{t-1}\\] 3.7.1 编程求解 显式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Explicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY CFL.x = alpha = DD[1] * DT / (DX * DX) CFL.y = beta = DD[2] * DT / (DY * DY) gamma = 1 - 2 * alpha - 2 * beta message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) # xm = matrix(NA, nrow=N, ncol=NT) vs = cbind(rep(0, N)) # bc2=list(id=10, x=0.01) # vs[bc2$id] = bc2$x b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } 隐式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Implicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY alpha = -DD[1] * DT / (DX * DX) beta = -DD[2] * DT / (DY * DY) CFL.x = DD[1] * DT / (DX * DX) CFL.y = DD[2] * DT / (DY * DY) gamma = 1 + 2 * DD[1] * DT / (DX * DX) + 2 * DD[2] * DT / (DY * DY) message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) vs = cbind(rep(0, N)) b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b + vs * DT) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } 对比隐式与显式求解法的时间步长和效率： "],["ch4_fem.html", "第 4 有限元法 4.1 有限元法理论基础 4.2 数学公式论证 4.3 一维热传导问题的深入分析与FEM求解 4.4 地球科学应用案例：地下水流模拟 4.5 有限元法的收敛性分析与误差估计 4.6 有限元法与有限差分法的系统对比 4.7 高级有限元技术的深入探讨 4.8 总结", " 第 4 有限元法 4.1 有限元法理论基础 有限元法（Finite Element Method, FEM）是一种强大的数值分析方法，广泛应用于求解工程和科学中的偏微分方程问题。它由Richard Courant于1943年首次提出，经过几十年的发展，已成为现代数值计算的重要工具之一。 4.1.1 历史发展与应用背景 有限元法的发展经历了几个重要阶段： 理论奠基期（1943-1960）：Courant提出了使用分片多项式和变分方法求解偏微分方程的思想 工程应用期（1960-1980）：在结构力学和航空航天领域得到广泛应用 理论完善期（1980-2000）：数学理论体系日趋完善，收敛性和误差分析取得重大进展 多学科融合期（2000至今）：在地球科学、生物医学、材料科学等领域得到广泛应用 在地球科学中，有限元法特别适用于： - 地下水流动模拟 - 地质构造变形分析 - 地震波传播计算 - 地热传输模拟 - 污染物扩散预测 4.1.2 基本思想与哲学 有限元法的核心思想体现了”分而治之”的哲学理念，将复杂的连续问题分解为简单的离散问题。这种思想具有以下特点： 局部化原理：复杂的全局问题可以通过求解简单的局部问题来近似 分片逼近：使用简单的多项式函数在每个小区域内逼近真解 变分基础：基于能量原理或变分原理，确保解的物理合理性 系统性方法：提供了一套系统的、标准化的求解流程 4.1.3 详细求解步骤 有限元法的完整求解过程包括以下七个核心步骤： 4.1.3.1 1. 域离散化（Domain Discretization） 将连续的求解域 \\(\\Omega\\) 划分为 \\(N_e\\) 个不重叠的子域（单元）： \\[\\Omega = \\bigcup_{e=1}^{N_e} \\Omega_e, \\quad \\Omega_i \\cap \\Omega_j = \\emptyset \\text{ (when } i \\neq j \\text{)}\\] 单元类型的选择原则： - 一维问题：线段单元（2节点或3节点） - 二维问题：三角形单元或四边形单元 - 三维问题：四面体单元或六面体单元 4.1.3.2 2. 形函数构造（Shape Function Construction） 在每个单元内定义形函数 \\(N_i(x)\\)，满足： - 插值性质：\\(N_i(x_j) = \\delta_{ij}\\)（Kronecker delta） - 完备性质：能够精确表示多项式函数 - 连续性质：在单元边界上保持连续性 4.1.3.3 3. 弱形式建立（Weak Formulation） 通过分部积分和Green公式，将强形式的偏微分方程转化为弱形式，降低对解的光滑性要求。 4.1.3.4 4. 单元矩阵组装（Element Matrix Assembly） 在每个单元上计算局部刚度矩阵 \\(\\mathbf{K}^e\\) 和质量矩阵 \\(\\mathbf{M}^e\\)。 4.1.3.5 5. 全局矩阵组装（Global Matrix Assembly） 将所有单元的贡献组装成全局矩阵： \\[\\mathbf{K} = \\sum_{e=1}^{N_e} \\mathbf{A}^e \\mathbf{K}^e (\\mathbf{A}^e)^T\\] 其中 \\(\\mathbf{A}^e\\) 是单元组装矩阵。 4.1.3.6 6. 边界条件施加（Boundary Condition Implementation） 处理不同类型的边界条件： - Dirichlet边界条件：指定函数值 - Neumann边界条件：指定导数值 - Robin边界条件：混合边界条件 4.1.3.7 7. 线性方程组求解（Linear System Solution） 求解最终的线性代数方程组： \\[\\mathbf{K}\\mathbf{u} = \\mathbf{f}\\] 使用适当的数值方法（直接法或迭代法）求解。 4.1.4 变分原理的深入理解 4.1.4.1 变分原理的数学基础 变分原理是有限元法的理论基石，它建立了偏微分方程与泛函极值问题之间的等价关系。这种等价性不仅为数值求解提供了新的途径，更重要的是为解的存在性和唯一性提供了理论保证。 泛函的定义： 泛函是从函数空间到实数的映射。对于函数 \\(u(x)\\)，泛函 \\(J[u]\\) 将函数 \\(u\\) 映射到一个实数值： \\[J[u] = \\int_\\Omega F(x, u, \\nabla u) dx\\] 其中 \\(F\\) 是给定的函数，\\(\\nabla u\\) 是 \\(u\\) 的梯度。 4.1.4.2 从强形式到弱形式的详细推导 考虑一般的二阶椭圆型偏微分方程： \\[-\\nabla \\cdot (k(x) \\nabla u) + c(x) u = f(x) \\quad \\text{in} \\quad \\Omega\\] 配以边界条件： \\[u = g \\quad \\text{on} \\quad \\Gamma_D \\quad \\text{(Dirichlet边界)}\\] \\[k \\frac{\\partial u}{\\partial n} = h \\quad \\text{on} \\quad \\Gamma_N \\quad \\text{(Neumann边界)}\\] 其中 \\(\\Gamma_D \\cup \\Gamma_N = \\partial\\Omega\\)，\\(\\partial\\Omega\\) 是 \\(\\Omega\\) 的边界。 步骤1：构造测试函数空间 定义测试函数空间： \\[V_0 = \\{v \\in H^1(\\Omega) : v = 0 \\text{ on } \\Gamma_D\\}\\] 其中 \\(H^1(\\Omega)\\) 是Sobolev空间，包含所有在 \\(\\Omega\\) 上平方可积且弱导数也平方可积的函数。 步骤2：建立弱形式 将强形式方程乘以测试函数 \\(v \\in V_0\\) 并在 \\(\\Omega\\) 上积分： \\[\\int_\\Omega [-\\nabla \\cdot (k \\nabla u) + c u] v \\, dx = \\int_\\Omega f v \\, dx\\] 步骤3：应用Green公式（分部积分） 对第一项应用Green公式： \\[-\\int_\\Omega v \\nabla \\cdot (k \\nabla u) dx = \\int_\\Omega k \\nabla u \\cdot \\nabla v \\, dx - \\int_{\\partial\\Omega} v k \\frac{\\partial u}{\\partial n} ds\\] 由于 \\(v = 0\\) 在 \\(\\Gamma_D\\) 上，边界积分只在 \\(\\Gamma_N\\) 上非零： \\[-\\int_{\\partial\\Omega} v k \\frac{\\partial u}{\\partial n} ds = -\\int_{\\Gamma_N} v h \\, ds\\] 步骤4：得到弱形式 最终的弱形式为：寻找 \\(u \\in V_g = \\{w \\in H^1(\\Omega) : w = g \\text{ on } \\Gamma_D\\}\\)，使得对所有 \\(v \\in V_0\\)： \\[\\int_\\Omega k \\nabla u \\cdot \\nabla v \\, dx + \\int_\\Omega c u v \\, dx = \\int_\\Omega f v \\, dx + \\int_{\\Gamma_N} h v \\, ds\\] 这可以写成抽象形式： \\[a(u,v) = L(v)\\] 其中： - \\(a(u,v) = \\int_\\Omega k \\nabla u \\cdot \\nabla v \\, dx + \\int_\\Omega c u v \\, dx\\) （双线性形式） - \\(L(v) = \\int_\\Omega f v \\, dx + \\int_{\\Gamma_N} h v \\, ds\\) （线性形式） 4.1.4.3 变分原理的物理意义 变分原理具有深刻的物理意义： 能量最小原理：对于弹性力学问题，弱形式对应于势能的最小化 虚功原理：弱形式表达了虚位移做的虚功等于外力做的虚功 守恒定律：弱形式自然地体现了各种守恒定律（质量、动量、能量等） 4.1.4.4 Lax-Milgram定理 Lax-Milgram定理保证了弱形式解的存在性和唯一性。如果双线性形式 \\(a(\\cdot,\\cdot)\\) 满足： 连续性：存在常数 \\(M &gt; 0\\)，使得 \\(|a(u,v)| \\leq M \\|u\\|_{V} \\|v\\|_{V}\\) 强制性（椭圆性）：存在常数 \\(\\alpha &gt; 0\\)，使得 \\(a(v,v) \\geq \\alpha \\|v\\|_{V}^2\\) 且线性形式 \\(L(\\cdot)\\) 连续，则弱形式存在唯一解。 4.1.4.5 等价性定理 在适当的正则性假设下，强形式和弱形式是等价的： - 强形式的解必然是弱形式的解 - 在足够光滑的条件下，弱形式的解也是强形式的解 这种等价性为有限元法提供了坚实的理论基础。 4.1.5 形函数理论的完整体系 形函数（Shape Functions）是有限元法的核心概念，它们不仅定义了单元内的插值关系，更是连接离散节点值与连续函数空间的桥梁。深入理解形函数的性质和构造方法，对于掌握有限元法的精髓至关重要。 4.1.5.1 形函数的基本性质 形函数必须满足以下四个基本性质： 1. 插值性质（Interpolation Property） \\[N_i(x_j) = \\delta_{ij} = \\begin{cases} 1 &amp; \\text{if } i = j \\\\ 0 &amp; \\text{if } i \\neq j \\end{cases}\\] 这确保了节点值的准确插值。 2. 单位分解性质（Partition of Unity） \\[\\sum_{i=1}^{n} N_i(x) = 1, \\quad \\forall x \\in \\Omega_e\\] 这保证了常数函数能够被精确表示。 3. 完备性性质（Completeness Property） 形函数集合能够精确表示完全多项式，至少到某个给定阶数 \\(p\\)： \\[\\mathcal{P}_p \\subset \\text{span}\\{N_1, N_2, \\ldots, N_n\\}\\] 其中 \\(\\mathcal{P}_p\\) 是阶数不超过 \\(p\\) 的多项式空间。 4. 连续性性质（Continuity Property） 在单元边界上，形函数保持 \\(C^0\\) 连续性，即函数值连续但导数可能不连续。 4.1.5.2 一维形函数的详细构造 线性形函数（Linear Shape Functions） 对于标准单元 \\(\\xi \\in [-1, 1]\\)： \\[N_1(\\xi) = \\frac{1-\\xi}{2}, \\quad N_2(\\xi) = \\frac{1+\\xi}{2}\\] 其导数为： \\[\\frac{dN_1}{d\\xi} = -\\frac{1}{2}, \\quad \\frac{dN_2}{d\\xi} = \\frac{1}{2}\\] 二次形函数（Quadratic Shape Functions） 对于三节点单元，节点位于 \\(\\xi = -1, 0, 1\\)： \\[N_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}, \\quad N_2(\\xi) = 1-\\xi^2, \\quad N_3(\\xi) = \\frac{\\xi(\\xi+1)}{2}\\] 其导数为： \\[\\frac{dN_1}{d\\xi} = \\xi - \\frac{1}{2}, \\quad \\frac{dN_2}{d\\xi} = -2\\xi, \\quad \\frac{dN_3}{d\\xi} = \\xi + \\frac{1}{2}\\] 三次形函数（Cubic Shape Functions） 对于四节点单元，可以使用Hermite插值： \\[N_1(\\xi) = \\frac{1}{16}(1-\\xi)^2(2+\\xi)\\] \\[N_2(\\xi) = \\frac{1}{16}(1-\\xi)^2(1+\\xi)\\] \\[N_3(\\xi) = \\frac{1}{16}(1+\\xi)^2(2-\\xi)\\] \\[N_4(\\xi) = \\frac{1}{16}(1+\\xi)^2(1-\\xi)\\] 4.1.5.3 Lagrange插值基础 形函数的构造通常基于Lagrange插值理论。对于 \\(n+1\\) 个节点 \\(\\xi_0, \\xi_1, \\ldots, \\xi_n\\)，Lagrange插值多项式为： \\[L_i(\\xi) = \\prod_{j=0, j \\neq i}^{n} \\frac{\\xi - \\xi_j}{\\xi_i - \\xi_j}\\] 这自然满足插值性质：\\(L_i(\\xi_j) = \\delta_{ij}\\)。 4.1.5.4 等参变换理论 坐标变换 从物理坐标 \\(x\\) 到参考坐标 \\(\\xi\\) 的变换： \\[x = \\sum_{i=1}^{n} x_i N_i(\\xi)\\] 其中 \\(x_i\\) 是节点的物理坐标。 雅可比矩阵 变换的雅可比矩阵为： \\[J = \\frac{dx}{d\\xi} = \\sum_{i=1}^{n} x_i \\frac{dN_i}{d\\xi}\\] 对于一维情况，雅可比行列式 \\(|J| = J\\)。 导数变换 物理空间中的导数通过链式法则计算： \\[\\frac{dN_i}{dx} = \\frac{dN_i}{d\\xi} \\frac{d\\xi}{dx} = \\frac{1}{J} \\frac{dN_i}{d\\xi}\\] 4.1.5.5 二维形函数 三角形单元 对于三角形单元，使用面积坐标（重心坐标）\\(L_1, L_2, L_3\\)： \\[N_1 = L_1, \\quad N_2 = L_2, \\quad N_3 = L_3\\] 其中 \\(L_1 + L_2 + L_3 = 1\\)。 四边形单元 对于双线性四边形单元： \\[N_1(\\xi, \\eta) = \\frac{(1-\\xi)(1-\\eta)}{4}\\] \\[N_2(\\xi, \\eta) = \\frac{(1+\\xi)(1-\\eta)}{4}\\] \\[N_3(\\xi, \\eta) = \\frac{(1+\\xi)(1+\\eta)}{4}\\] \\[N_4(\\xi, \\eta) = \\frac{(1-\\xi)(1+\\eta)}{4}\\] 4.1.5.6 形函数的数值积分 形函数涉及的积分通常通过高斯积分法计算： 一维高斯积分 \\[\\int_{-1}^{1} f(\\xi) d\\xi \\approx \\sum_{i=1}^{n} w_i f(\\xi_i)\\] 其中 \\(w_i\\) 是权重，\\(\\xi_i\\) 是积分点。 常用高斯积分点 1点积分：\\(\\xi_1 = 0\\), \\(w_1 = 2\\) 2点积分：\\(\\xi_{1,2} = \\pm\\frac{1}{\\sqrt{3}}\\), \\(w_{1,2} = 1\\) 3点积分：\\(\\xi_1 = 0, \\xi_{2,3} = \\pm\\sqrt{\\frac{3}{5}}\\), \\(w_1 = \\frac{8}{9}, w_{2,3} = \\frac{5}{9}\\) 4.1.5.7 形函数的误差分析 形函数的插值误差可以通过Taylor展开分析。对于 \\(p\\) 阶多项式形函数，插值误差为： \\[|u - u^h| \\leq C h^{p+1} \\left\\|\\frac{d^{p+1}u}{dx^{p+1}}\\right\\|_{L^2(\\Omega_e)}\\] 其中 \\(h\\) 是单元尺寸，\\(C\\) 是与形函数相关的常数。 4.1.5.8 特殊形函数 分层形函数（Hierarchical Shape Functions） 分层形函数便于实现 \\(p\\) 型自适应： \\[N_i^{(p)} = N_i^{(p-1)} + \\alpha_i \\phi_p(\\xi)\\] 其中 \\(\\phi_p\\) 是 \\(p\\) 阶正交多项式。 泡函数（Bubble Functions） 泡函数在单元内部非零，在边界上为零： \\[N_b(\\xi) = (1-\\xi^2)^p\\] 泡函数常用于稳定化方法和混合有限元法。 4.2 数学公式论证 4.2.1 变分形式的推导 考虑一维热传导方程： \\[\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2} \\quad \\text{in} \\quad (0,L) \\times (0,T)\\] 其中 \\(u(x,t)\\) 是温度，\\(\\alpha\\) 是热扩散系数，\\(L\\) 是杆长，\\(T\\) 是总时间。 边界条件： \\[u(0,t) = u_0, \\quad u(L,t) = u_L\\] 初始条件： \\[u(x,0) = u_{ic}(x)\\] 将方程乘以测试函数 \\(v(x)\\) 并在空间域上积分： \\[\\int_0^L v(x) \\frac{\\partial u}{\\partial t} dx = \\alpha \\int_0^L v(x) \\frac{\\partial^2 u}{\\partial x^2} dx\\] 对右边进行分部积分： \\[\\int_0^L v(x) \\frac{\\partial u}{\\partial t} dx = -\\alpha \\int_0^L \\frac{\\partial v}{\\partial x} \\frac{\\partial u}{\\partial x} dx + \\alpha \\left[v(x) \\frac{\\partial u}{\\partial x}\\right]_0^L\\] 由于边界条件已知，边界项可以处理，得到弱形式： \\[\\int_0^L v(x) \\frac{\\partial u}{\\partial t} dx + \\alpha \\int_0^L \\frac{\\partial v}{\\partial x} \\frac{\\partial u}{\\partial x} dx = 0\\] 4.2.2 有限元离散化 将空间域 \\([0,L]\\) 划分为 \\(n\\) 个单元，每个单元长度为 \\(h = L/n\\)。在每个单元 \\([x_i, x_{i+1}]\\) 上，使用线性形函数： \\[u^h(x) = \\sum_{j=1}^{n+1} u_j N_j(x)\\] 其中 \\(u_j\\) 是节点 \\(j\\) 处的温度值，\\(N_j(x)\\) 是节点 \\(j\\) 的形函数。 将弱形式离散化，得到： \\[\\sum_{i=1}^n \\int_{x_i}^{x_{i+1}} N_j(x) \\frac{\\partial u^h}{\\partial t} dx + \\alpha \\sum_{i=1}^n \\int_{x_i}^{x_{i+1}} \\frac{\\partial N_j}{\\partial x} \\frac{\\partial u^h}{\\partial x} dx = 0\\] 这可以写成矩阵形式： \\[M \\frac{d\\mathbf{u}}{dt} + K\\mathbf{u} = \\mathbf{0}\\] 其中 \\(M\\) 是质量矩阵，\\(K\\) 是刚度矩阵，\\(\\mathbf{u}\\) 是节点温度向量。 4.2.3 单元矩阵的构造 对于线性单元，质量矩阵和刚度矩阵的元素为： \\[M_{ij} = \\int_{x_i}^{x_{i+1}} N_i(x) N_j(x) dx\\] \\[K_{ij} = \\alpha \\int_{x_i}^{x_{i+1}} \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} dx\\] 对于均匀网格，这些积分可以解析计算： \\[M = \\frac{h}{6} \\begin{bmatrix} 2 &amp; 1 \\\\ 1 &amp; 2 \\end{bmatrix}\\] \\[K = \\frac{\\alpha}{h} \\begin{bmatrix} 1 &amp; -1 \\\\ -1 &amp; 1 \\end{bmatrix}\\] 4.3 一维热传导问题的深入分析与FEM求解 4.3.1 工程背景与实际意义 热传导问题在地球科学和工程实践中具有重要意义。本节以铁棍热传导为例，展示有限元法在解决实际工程问题中的应用。这类问题在以下领域具有广泛应用： 地球科学应用： - 地热能开发：地下岩层的热传导分析 - 冻土工程：永久冻土层的热力学行为 - 地质勘探：地下温度场分布预测 - 环境工程：土壤污染热修复技术 工程应用： - 建筑节能：墙体保温材料设计 - 电子散热：芯片热管理系统 - 材料加工：金属热处理工艺 - 核工程：反应堆热传递分析 4.3.2 详细问题描述 考虑一根长度为 \\(L = 1.0\\) m 的均匀铁棍，其物理参数如下： 材料参数： - 热传导系数：\\(k = 50\\) W/(m·K) - 密度：\\(\\rho = 7850\\) kg/m³ - 比热容：\\(c = 460\\) J/(kg·K) - 热扩散系数：\\(\\alpha = \\frac{k}{\\rho c} = 1.384 \\times 10^{-5}\\) m²/s 几何参数： - 长度：\\(L = 1.0\\) m - 横截面积：\\(A = 1.0\\) cm²（假设为细棍，忽略横向传热） 边界条件： - 左端（\\(x = 0\\)）：恒温 \\(u(0,t) = 100°C\\) - 右端（\\(x = L\\)）：恒温 \\(u(L,t) = 50°C\\) 初始条件： - 初始温度：\\(u(x,0) = 25°C\\)（室温） 4.3.3 CLAMS方法的系统化建模 CLAMS方法为复杂物理问题提供了系统化的建模框架，确保建模过程的完整性和科学性。 4.3.3.1 1. 概念描述 (Conceptual Model) 物理系统描述： 一维热传导系统，包含以下关键要素： - 系统边界：铁棍的几何边界 - 控制体积：整个铁棍内部 - 热源/热汇：两端的恒温边界条件 - 传热机制：纯导热（忽略对流和辐射） 简化假设的物理合理性： 1. 一维假设：当铁棍的长度远大于其直径时，横向温度梯度可忽略 2. 均匀材料：工业铁棍在宏观尺度上可视为均匀介质 3. 恒定物性：在给定温度范围内，铁的热物性变化较小 4.3.3.2 2. 物理定律 (Laws of Physics) 傅里叶热传导定律： \\[\\mathbf{q} = -k \\nabla u\\] 对于一维情况： \\[q_x = -k \\frac{\\partial u}{\\partial x}\\] 其中 \\(q_x\\) 是单位面积的热流密度（W/m²）。 能量守恒定律： 基于控制体积的能量平衡： \\[\\frac{\\partial}{\\partial t}(\\rho c u) + \\nabla \\cdot \\mathbf{q} = S\\] 其中 \\(S\\) 是内热源项。对于无内热源的一维情况： \\[\\rho c \\frac{\\partial u}{\\partial t} + \\frac{\\partial q_x}{\\partial x} = 0\\] 热力学第二定律： 热量自发地从高温区域传向低温区域，这确保了问题解的物理合理性。 4.3.3.3 3. 假设条件 (Assumptions) 几何假设： 1. 一维传热：\\(\\frac{\\partial u}{\\partial y} = \\frac{\\partial u}{\\partial z} = 0\\) 2. 直杆假设：忽略几何形状对传热的影响 3. 边界绝热：侧表面无热交换 物理假设： 4. 恒定物性：\\(k\\)、\\(\\rho\\)、\\(c\\) 为常数 5. 无内热源：\\(S = 0\\) 6. 线性传热：忽略非线性效应（如温度相关的物性） 数值假设： 7. 连续介质：忽略分子尺度的不连续性 8. 准静态过程：忽略惯性效应 假设的有效性分析： - 对于长径比 &gt; 10 的铁棍，一维假设误差 &lt; 5% - 在0-200°C温度范围内，铁的热物性变化 &lt; 10% - 忽略对流和辐射在低温差情况下是合理的 4.3.3.4 4. 数学推导 (Mathematical Derivation) 控制方程的推导： 将傅里叶定律代入能量守恒方程： \\[\\rho c \\frac{\\partial u}{\\partial t} - \\frac{\\partial}{\\partial x}\\left(k \\frac{\\partial u}{\\partial x}\\right) = 0\\] 对于恒定物性： \\[\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\\] 其中热扩散系数 \\(\\alpha = \\frac{k}{\\rho c}\\) 具有量纲 [m²/s]。 边界条件的数学表达： - 第一类边界条件（Dirichlet）： \\[u(0,t) = u_0 = 100°C\\] \\[u(L,t) = u_L = 50°C\\] 初始条件： \\[u(x,0) = u_{ic}(x) = 25°C\\] 无量纲化处理： 为了便于数值计算和参数分析，引入无量纲变量： - 无量纲坐标：\\(\\xi = \\frac{x}{L}\\) - 无量纲温度：\\(\\theta = \\frac{u - u_L}{u_0 - u_L}\\) - 无量纲时间：\\(\\tau = \\frac{\\alpha t}{L^2}\\) 无量纲控制方程： \\[\\frac{\\partial \\theta}{\\partial \\tau} = \\frac{\\partial^2 \\theta}{\\partial \\xi^2}\\] 边界条件：\\(\\theta(0,\\tau) = 1\\)，\\(\\theta(1,\\tau) = 0\\) 初始条件：\\(\\theta(\\xi,0) = \\frac{25-50}{100-50} = -0.5\\) 4.3.3.5 5. 求解策略 (Solver Strategy) 有限元离散化策略： 空间离散化： 单元类型：一维线性单元 网格密度：根据Peclet数确定 单元数量：\\(N_e = 20\\)（经收敛性分析确定） 时间离散化： 时间积分格式：隐式Euler法（确保无条件稳定） 时间步长：\\(\\Delta t = 100\\) s（满足精度要求） 总时间：\\(T = 10000\\) s（达到稳态） 线性方程组求解： 矩阵类型：对称正定稀疏矩阵 求解方法：直接法（LU分解） 边界条件处理：罚方法或消元法 数值稳定性分析： - CFL条件：隐式格式无条件稳定 - 质量矩阵：确保质量守恒 - 能量守恒：验证总能量平衡 收敛性检验： - 网格收敛性：比较不同网格密度的结果 - 时间步长收敛性：验证时间积分精度 - 解析解对比：在特殊情况下与解析解比较 4.3.4 R代码实现 以下代码展示了有限元法求解一维热传导问题的完整实现： 4.3.5 完整实现代码 # 有限元法求解一维热传导问题 # 作者：数值地球教科书项目 # 日期：2025年 library(Matrix) # 加载字体配置 source(&quot;Functions/font_setup.R&quot;) # 设置中文字体（在绘图前） tryCatch({ setup_bookdown_fonts() }, error = function(e) { cat(&quot;字体设置失败，使用默认字体：&quot;, e$message, &quot;\\n&quot;) }) ## 字体设置完成： Arial Unicode MS ## [1] &quot;Arial Unicode MS&quot; # 参数设置 L &lt;- 1.0 # 杆长 (m) n_elements &lt;- 20 # 单元数量 n_nodes &lt;- n_elements + 1 # 节点数量 h &lt;- L / n_elements # 单元长度 alpha &lt;- 1e-4 # 热扩散系数 (m²/s) dt &lt;- 100 # 时间步长 (s) T_max &lt;- 10000 # 总时间 (s) n_steps &lt;- T_max / dt # 时间步数 # 初始条件 u_ic &lt;- rep(25, n_nodes) # 初始温度 (°C) u_0 &lt;- 100 # 左端温度 (°C) u_L &lt;- 50 # 右端温度 (°C) # 构造质量矩阵和刚度矩阵 M &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) K &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) # 组装全局矩阵 for (i in 1:n_elements) { # 局部节点编号 local_nodes &lt;- c(i, i+1) # 局部质量矩阵 M_local &lt;- h/6 * matrix(c(2, 1, 1, 2), 2, 2) # 局部刚度矩阵 K_local &lt;- alpha/h * matrix(c(1, -1, -1, 1), 2, 2) # 组装到全局矩阵 M[local_nodes, local_nodes] &lt;- M[local_nodes, local_nodes] + M_local K[local_nodes, local_nodes] &lt;- K[local_nodes, local_nodes] + K_local } # 时间推进（隐式欧拉法） u_current &lt;- u_ic u_history &lt;- matrix(0, n_nodes, n_steps + 1) u_history[, 1] &lt;- u_current # 构造线性方程组系数矩阵 A &lt;- M + dt * K b &lt;- M %*% u_current # 施加边界条件 A[1, ] &lt;- 0; A[1, 1] &lt;- 1 A[n_nodes, ] &lt;- 0; A[n_nodes, n_nodes] &lt;- 1 for (step in 1:n_steps) { # 更新右端项 b &lt;- M %*% u_current # 施加边界条件 b[1] &lt;- u_0 b[n_nodes] &lt;- u_L # 求解线性方程组 u_new &lt;- solve(A, b) # 更新解 u_current &lt;- as.vector(u_new) u_history[, step + 1] &lt;- u_current } # 结果可视化 x_coords &lt;- seq(0, L, length.out = n_nodes) time_coords &lt;- seq(0, T_max, by = dt) # 绘制不同时刻的温度分布 par(mfrow = c(1, 1)) # 选择要显示的时刻 time_indices &lt;- c(1, round(n_steps/16), round(n_steps/8), n_steps + 1) time_labels &lt;- paste(&#39;Time =&#39;, time_indices, &#39;s&#39;) colors &lt;- c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;purple&quot;) # 绘制第一条曲线（初始时刻） plot(x_coords, u_history[, time_indices[1]], type = &#39;l&#39;, col = colors[1], lwd = 2, ylim = c(0, 100), xlab = &#39;位置 (m)&#39;, ylab = &#39;温度 (°C)&#39;, main = &#39;不同时刻的温度分布&#39;) # 添加其他时刻的曲线 for (i in 2:length(time_indices)) { lines(x_coords, u_history[, time_indices[i]], col = colors[i], lwd = 2) } # 添加图例 legend(&quot;topright&quot;, legend = time_labels, col = colors, lwd = 2, lty = 1, cex = 0.8) grid() # 绘制温度随时间变化图（选择几个关键位置） par(mfrow = c(1, 1)) # 选择要显示的位置 position_indices &lt;- c(1, round(n_nodes/4), round(n_nodes/2), round(3*n_nodes/4), n_nodes) position_labels &lt;- c(&quot;左端&quot;, &quot;1/4处&quot;, &quot;中点&quot;, &quot;3/4处&quot;, &quot;右端&quot;) colors_time &lt;- c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;orange&quot;, &quot;purple&quot;) # 绘制第一条曲线（左端） plot(time_coords, u_history[position_indices[1], ], type = &#39;l&#39;, col = colors_time[1], lwd = 2, ylim = c(0, 100), xlab = &#39;时间 (s)&#39;, ylab = &#39;温度 (°C)&#39;, main = &#39;不同位置的温度随时间变化&#39;) # 添加其他位置的曲线 for (i in 2:length(position_indices)) { lines(time_coords, u_history[position_indices[i], ], col = colors_time[i], lwd = 2) } # 添加图例 legend(&quot;topright&quot;, legend = position_labels, col = colors_time, lwd = 2, lty = 1, cex = 0.8) grid() # 返回结果 result &lt;- list( x_coords = x_coords, time_coords = time_coords, u_history = u_history, parameters = list( L = L, n_elements = n_elements, alpha = alpha, dt = dt, T_max = T_max ) ) # 打印结果摘要 cat(&quot;有限元法求解完成！\\n&quot;) ## 有限元法求解完成！ cat(&quot;空间网格点数：&quot;, n_nodes, &quot;\\n&quot;) ## 空间网格点数： 21 cat(&quot;时间步数：&quot;, n_steps, &quot;\\n&quot;) ## 时间步数： 100 cat(&quot;最终温度范围：&quot;, round(min(u_history[, n_steps + 1]), 2), &quot;°C 到&quot;, round(max(u_history[, n_steps + 1]), 2), &quot;°C\\n&quot;) ## 最终温度范围： 50 °C 到 100 °C #return(result) 4.3.6 运行结果示例 运行上述代码可以得到一维热传导问题的有限元解。结果显示： 温度分布演化：从初始的均匀温度25°C逐渐向两端边界温度过渡 收敛性：解在时间推进过程中逐渐收敛到稳态解 边界效应：温度梯度在边界附近较大，在中心区域较小 4.3.7 高级有限元技术实现 除了基本的线性有限元法，我们还实现了更高级的技术： # 高级有限元法实现 # 包括高阶形函数、自适应网格和与有限差分法的对比 # 作者：数值地球教科书项目 # 日期：2025年 library(Matrix) # 加载字体配置 source(&quot;Functions/font_setup.R&quot;) # 设置中文字体（在绘图前） tryCatch({ setup_bookdown_fonts() }, error = function(e) { cat(&quot;字体设置失败，使用默认字体：&quot;, e$message, &quot;\\n&quot;) }) ## 字体设置完成： Arial Unicode MS ## [1] &quot;Arial Unicode MS&quot; # ============================================================================ # 高阶形函数有限元法 # ============================================================================ # 二次形函数 quadratic_shape_functions &lt;- function(xi) { N1 &lt;- xi * (xi - 1) / 2 N2 &lt;- 1 - xi^2 N3 &lt;- xi * (xi + 1) / 2 return(c(N1, N2, N3)) } # 二次形函数的导数 quadratic_shape_derivatives &lt;- function(xi) { dN1 &lt;- (2*xi - 1) / 2 dN2 &lt;- -2*xi dN3 &lt;- (2*xi + 1) / 2 return(c(dN1, dN2, dN3)) } # 高阶有限元求解器 FEM_quadratic &lt;- function(L = 1.0, n_elements = 10, alpha = 1e-4, dt = 100, T_max = 10000, u_0 = 100, u_L = 50, u_ic = 25) { n_nodes &lt;- 2 * n_elements + 1 # 二次单元：每个单元3个节点 h &lt;- L / n_elements # 构造质量矩阵和刚度矩阵 M &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) K &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) # 高斯积分点和权重 gauss_points &lt;- c(-sqrt(3/5), 0, sqrt(3/5)) gauss_weights &lt;- c(5/9, 8/9, 5/9) # 组装全局矩阵 for (i in 1:n_elements) { # 局部节点编号（二次单元） local_nodes &lt;- c(2*i-1, 2*i, 2*i+1) # 初始化局部矩阵 M_local &lt;- matrix(0, 3, 3) K_local &lt;- matrix(0, 3, 3) # 高斯积分 for (gp in 1:3) { xi &lt;- gauss_points[gp] weight &lt;- gauss_weights[gp] # 形函数和导数 N &lt;- quadratic_shape_functions(xi) dN &lt;- quadratic_shape_derivatives(xi) # 雅可比变换 J &lt;- h/2 # 组装局部矩阵 for (a in 1:3) { for (b in 1:3) { M_local[a, b] &lt;- M_local[a, b] + weight * N[a] * N[b] * J K_local[a, b] &lt;- K_local[a, b] + weight * dN[a] * dN[b] * J } } } # 组装到全局矩阵 M[local_nodes, local_nodes] &lt;- M[local_nodes, local_nodes] + M_local K[local_nodes, local_nodes] &lt;- K[local_nodes, local_nodes] + alpha * K_local } # 时间推进 n_steps &lt;- T_max / dt u_current &lt;- rep(u_ic, n_nodes) u_history &lt;- matrix(0, n_nodes, n_steps + 1) u_history[, 1] &lt;- u_current # 构造线性方程组系数矩阵 A &lt;- M + dt * K # 施加边界条件 A[1, ] &lt;- 0; A[1, 1] &lt;- 1 A[n_nodes, ] &lt;- 0; A[n_nodes, n_nodes] &lt;- 1 for (step in 1:n_steps) { b &lt;- M %*% u_current b[1] &lt;- u_0 b[n_nodes] &lt;- u_L u_new &lt;- solve(A, b) u_current &lt;- as.vector(u_new) u_history[, step + 1] &lt;- u_current } return(list( u_history = u_history, x_coords = seq(0, L, length.out = n_nodes), parameters = list(n_elements = n_elements, n_nodes = n_nodes, h = h) )) } # ============================================================================ # 自适应网格有限元法 # ============================================================================ # 误差估计器 error_estimator &lt;- function(u, h) { # 基于梯度的简单误差估计 n &lt;- length(u) error &lt;- numeric(n-1) for (i in 1:(n-1)) { gradient &lt;- abs(u[i+1] - u[i]) / h error[i] &lt;- h * gradient^2 } return(error) } # 自适应网格细化 adaptive_mesh_refinement &lt;- function(u, x, error_threshold = 0.01) { n &lt;- length(u) error &lt;- error_estimator(u, diff(x)) # 标记需要细化的单元 refine_elements &lt;- which(error &gt; error_threshold) if (length(refine_elements) == 0) { return(list(x = x, u = u, refined = FALSE)) } # 在误差大的单元中点插入新节点 new_x &lt;- x new_u &lt;- u for (i in sort(refine_elements, decreasing = TRUE)) { # 插入中点 mid_x &lt;- (x[i] + x[i+1]) / 2 mid_u &lt;- (u[i] + u[i+1]) / 2 new_x &lt;- c(new_x[1:i], mid_x, new_x[(i+1):length(new_x)]) new_u &lt;- c(new_u[1:i], mid_u, new_u[(i+1):length(new_u)]) } return(list(x = new_x, u = new_u, refined = TRUE)) } # 自适应有限元求解器 FEM_adaptive &lt;- function(L = 1.0, initial_elements = 10, alpha = 1e-4, dt = 100, T_max = 10000, u_0 = 100, u_L = 50, u_ic = 25, max_refinements = 3) { # 初始网格 n_elements &lt;- initial_elements n_nodes &lt;- n_elements + 1 h &lt;- L / n_elements # 初始条件 u_current &lt;- rep(u_ic, n_nodes) x_coords &lt;- seq(0, L, length.out = n_nodes) # 自适应细化循环 for (refinement in 1:max_refinements) { cat(&quot;第&quot;, refinement, &quot;次网格细化，节点数：&quot;, length(x_coords), &quot;\\n&quot;) # 使用当前网格求解 result &lt;- FEM_linear_adaptive(x_coords, u_current, alpha, dt, T_max, u_0, u_L) # 误差估计和网格细化 mesh_result &lt;- adaptive_mesh_refinement(result$u_final, x_coords) if (!mesh_result$refined) { cat(&quot;网格细化完成\\n&quot;) break } # 更新网格和解 x_coords &lt;- mesh_result$x u_current &lt;- mesh_result$u } return(result) } # 线性有限元求解器（用于自适应网格） FEM_linear_adaptive &lt;- function(x_coords, u_ic, alpha, dt, T_max, u_0, u_L) { n_nodes &lt;- length(x_coords) n_elements &lt;- n_nodes - 1 # 构造质量矩阵和刚度矩阵 M &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) K &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) # 组装全局矩阵 for (i in 1:n_elements) { h &lt;- x_coords[i+1] - x_coords[i] local_nodes &lt;- c(i, i+1) M_local &lt;- h/6 * matrix(c(2, 1, 1, 2), 2, 2) K_local &lt;- alpha/h * matrix(c(1, -1, -1, 1), 2, 2) M[local_nodes, local_nodes] &lt;- M[local_nodes, local_nodes] + M_local K[local_nodes, local_nodes] &lt;- K[local_nodes, local_nodes] + K_local } # 时间推进 n_steps &lt;- T_max / dt u_current &lt;- u_ic u_history &lt;- matrix(0, n_nodes, n_steps + 1) u_history[, 1] &lt;- u_current A &lt;- M + dt * K A[1, ] &lt;- 0; A[1, 1] &lt;- 1 A[n_nodes, ] &lt;- 0; A[n_nodes, n_nodes] &lt;- 1 for (step in 1:n_steps) { b &lt;- M %*% u_current b[1] &lt;- u_0 b[n_nodes] &lt;- u_L u_new &lt;- solve(A, b) u_current &lt;- as.vector(u_new) u_history[, step + 1] &lt;- u_current } return(list( u_history = u_history, u_final = u_current, x_coords = x_coords )) } # ============================================================================ # 与有限差分法的对比 # ============================================================================ # 有限差分法求解器（用于对比） FDM_explicit &lt;- function(L = 1.0, n_points = 21, alpha = 1e-4, dt = 100, T_max = 10000, u_0 = 100, u_L = 50, u_ic = 25) { h &lt;- L / (n_points - 1) n_steps &lt;- T_max / dt # 检查CFL条件 cfl &lt;- alpha * dt / (h^2) if (cfl &gt; 0.5) { cat(&quot;警告：CFL条件不满足，CFL =&quot;, cfl, &quot;\\n&quot;) } # 初始条件 u_current &lt;- rep(u_ic, n_points) u_history &lt;- matrix(0, n_points, n_steps + 1) u_history[, 1] &lt;- u_current # 显式时间推进 for (step in 1:n_steps) { u_new &lt;- u_current # 内部点 for (i in 2:(n_points-1)) { u_new[i] &lt;- u_current[i] + cfl * (u_current[i+1] - 2*u_current[i] + u_current[i-1]) } # 边界条件 u_new[1] &lt;- u_0 u_new[n_points] &lt;- u_L u_current &lt;- u_new u_history[, step + 1] &lt;- u_current } return(list( u_history = u_history, x_coords = seq(0, L, length.out = n_points), cfl = cfl )) } # 性能对比函数 performance_comparison &lt;- function() { cat(&quot;有限元法与有限差分法性能对比\\n&quot;) cat(&quot;=&quot; * 50, &quot;\\n&quot;) # 测试参数 L &lt;- 1.0 alpha &lt;- 1e-4 dt &lt;- 100 T_max &lt;- 10000 u_0 &lt;- 100 u_L &lt;- 50 u_ic &lt;- 25 # 测试不同网格密度 grid_sizes &lt;- c(11, 21, 41, 81) for (n in grid_sizes) { cat(&quot;\\n网格点数：&quot;, n, &quot;\\n&quot;) # 有限差分法 t0 &lt;- Sys.time() fdm_result &lt;- FDM_explicit(L, n, alpha, dt, T_max, u_0, u_L, u_ic) t1 &lt;- Sys.time() fdm_time &lt;- as.numeric(t1 - t0) # 有限元法（线性） t0 &lt;- Sys.time() fem_result &lt;- FEM_linear_adaptive( seq(0, L, length.out = n), rep(u_ic, n), alpha, dt, T_max, u_0, u_L ) t1 &lt;- Sys.time() fem_time &lt;- as.numeric(t1 - t0) cat(&quot;FDM时间：&quot;, round(fdm_time, 4), &quot;秒\\n&quot;) cat(&quot;FEM时间：&quot;, round(fem_time, 4), &quot;秒\\n&quot;) cat(&quot;时间比：&quot;, round(fem_time/fdm_time, 2), &quot;\\n&quot;) # 精度对比（使用解析解作为参考） # 这里简化处理，实际应该与解析解比较 fdm_error &lt;- mean(abs(diff(fdm_result$u_history[, ncol(fdm_result$u_history)]))) fem_error &lt;- mean(abs(diff(fem_result$u_final))) cat(&quot;FDM误差：&quot;, round(fdm_error, 6), &quot;\\n&quot;) cat(&quot;FEM误差：&quot;, round(fem_error, 6), &quot;\\n&quot;) } } # ============================================================================ # 主函数和示例 # ============================================================================ # 运行示例 if (FALSE) { # 基本有限元法 cat(&quot;运行基本有限元法...\\n&quot;) result_basic &lt;- FEM_quadratic() # 自适应网格有限元法 cat(&quot;运行自适应网格有限元法...\\n&quot;) result_adaptive &lt;- FEM_adaptive() # 性能对比 performance_comparison() # 可视化结果 par(mfrow = c(1, 2)) # 基本FEM结果 - 不同时刻的温度分布 time_indices &lt;- c(1, round(ncol(result_basic$u_history)/16), round(ncol(result_basic$u_history)/8), ncol(result_basic$u_history)) time_labels &lt;- paste(&#39;Time =&#39;, time_indices, &#39;s&#39;) colors &lt;- c(&quot;blue&quot;, &quot;red&quot;, &quot;green&quot;, &quot;purple&quot;) # 绘制第一条曲线 plot(result_basic$x_coords, result_basic$u_history[, time_indices[1]], type = &#39;l&#39;, col = colors[1], lwd = 2, ylim = c(0, 100), xlab = &#39;位置 (m)&#39;, ylab = &#39;温度 (°C)&#39;, main = &#39;基本FEM - 不同时刻温度分布&#39;) # 添加其他时刻的曲线 for (i in 2:length(time_indices)) { lines(result_basic$x_coords, result_basic$u_history[, time_indices[i]], col = colors[i], lwd = 2) } # 添加图例 legend(&quot;topright&quot;, legend = time_labels, col = colors, lwd = 2, lty = 1, cex = 0.8) grid() # 自适应FEM结果 - 不同时刻的温度分布 plot(result_adaptive$x_coords, result_adaptive$u_final, type = &#39;l&#39;, ylim = c(0, 100), col = &#39;green&#39;, lwd = 2, xlab = &#39;位置 (m)&#39;, ylab = &#39;温度 (°C)&#39;, main = &#39;自适应FEM - 最终温度分布&#39;) grid() # 网格对比图 par(mfrow = c(1, 1)) plot(result_basic$x_coords, rep(1, length(result_basic$x_coords)), type = &#39;p&#39;, pch = 16, col = &#39;blue&#39;, xlab = &#39;位置 (m)&#39;, ylab = &#39;&#39;, main = &#39;网格对比&#39;, yaxt = &#39;n&#39;, ylim = c(0.8, 1.4)) points(result_adaptive$x_coords, rep(1.2, length(result_adaptive$x_coords)), pch = 16, col = &#39;red&#39;) legend(&#39;top&#39;, legend = c(&#39;基本网格&#39;, &#39;自适应网格&#39;), col = c(&#39;blue&#39;, &#39;red&#39;), pch = 16) grid() } 这些高级技术展示了有限元法的强大功能： 高阶形函数：使用二次形函数提高精度，收敛阶从\\(O(h^2)\\)提升到\\(O(h^3)\\) 自适应网格：根据误差估计自动调整网格密度，在解变化剧烈的区域加密网格 性能对比：与有限差分法进行系统比较，展示有限元法的优势 数值积分：使用高斯积分法提高计算精度 4.4 地球科学应用案例：地下水流模拟 4.4.1 问题背景 地下水流模拟是水文地质学中的核心问题，有限元法在这一领域具有重要应用。考虑一个二维承压含水层中的地下水流动问题，这是有限元法在地球科学中的典型应用。 4.4.2 数学模型 控制方程： 二维承压含水层中的地下水流动由以下偏微分方程描述： \\[\\frac{\\partial}{\\partial x}\\left(T_{xx}\\frac{\\partial h}{\\partial x}\\right) + \\frac{\\partial}{\\partial y}\\left(T_{yy}\\frac{\\partial h}{\\partial y}\\right) = S\\frac{\\partial h}{\\partial t} + Q\\] 其中： - \\(h(x,y,t)\\) 是水头（m） - \\(T_{xx}\\)、\\(T_{yy}\\) 是导水系数（m²/s） - \\(S\\) 是储水系数（无量纲） - \\(Q\\) 是源汇项（1/s） 边界条件： - Dirichlet边界：\\(h = h_0\\) 在 \\(\\Gamma_D\\) 上 - Neumann边界：\\(T\\frac{\\partial h}{\\partial n} = q\\) 在 \\(\\Gamma_N\\) 上 4.4.3 有限元离散化 弱形式： 寻找 \\(h \\in V\\)，使得对所有 \\(v \\in V_0\\)： \\[\\int_\\Omega T\\nabla h \\cdot \\nabla v \\, d\\Omega + \\int_\\Omega S\\frac{\\partial h}{\\partial t}v \\, d\\Omega = \\int_\\Omega Qv \\, d\\Omega + \\int_{\\Gamma_N} qv \\, d\\Gamma\\] 有限元近似： \\[h^h(x,y,t) = \\sum_{i=1}^{N} h_i(t) N_i(x,y)\\] 其中 \\(N_i(x,y)\\) 是形函数，\\(h_i(t)\\) 是节点水头值。 4.4.4 实际应用案例 案例描述： 考虑一个矩形承压含水层，尺寸为1000m × 500m，厚度为50m。含水层参数如下： - 导水系数：\\(T = 10^{-3}\\) m²/s - 储水系数：\\(S = 10^{-4}\\) - 初始水头：\\(h_0 = 100\\) m - 边界条件：左边界 \\(h = 120\\) m，右边界 \\(h = 80\\) m 有限元求解： 使用三角形单元对计算域进行离散化，采用线性形函数进行插值。 # 有限元法求解二维地下水流问题 # 作者：数值地球教科书项目 # 日期：2025年 library(Matrix) library(ggplot2) # 加载字体配置 source(&quot;Functions/font_setup.R&quot;) # 设置中文字体（在绘图前） tryCatch({ setup_bookdown_fonts() }, error = function(e) { cat(&quot;字体设置失败，使用默认字体：&quot;, e$message, &quot;\\n&quot;) }) ## 字体设置完成： Arial Unicode MS ## [1] &quot;Arial Unicode MS&quot; # ============================================================================ # 二维地下水流有限元法求解器 # ============================================================================ # 三角形单元形函数（线性） triangle_shape_functions &lt;- function(xi, eta) { N1 &lt;- 1 - xi - eta N2 &lt;- xi N3 &lt;- eta return(c(N1, N2, N3)) } # 三角形单元形函数导数 triangle_shape_derivatives &lt;- function() { # 对于线性三角形单元，形函数导数为常数 dN_dxi &lt;- c(-1, 1, 0) dN_deta &lt;- c(-1, 0, 1) return(list(dN_dxi = dN_dxi, dN_deta = dN_deta)) } # 生成三角形网格 generate_triangular_mesh &lt;- function(Lx, Ly, nx, ny) { # 生成节点坐标 x &lt;- seq(0, Lx, length.out = nx) y &lt;- seq(0, Ly, length.out = ny) nodes &lt;- expand.grid(x = x, y = y) n_nodes &lt;- nrow(nodes) # 生成三角形单元 elements &lt;- list() element_count &lt;- 0 for (i in 1:(nx-1)) { for (j in 1:(ny-1)) { # 每个矩形分成两个三角形 # 左下角节点索引 bottom_left &lt;- (j-1) * nx + i bottom_right &lt;- (j-1) * nx + i + 1 top_left &lt;- j * nx + i top_right &lt;- j * nx + i + 1 # 第一个三角形（左下-右上-左上） element_count &lt;- element_count + 1 elements[[element_count]] &lt;- c(bottom_left, top_right, top_left) # 第二个三角形（左下-右下-右上） element_count &lt;- element_count + 1 elements[[element_count]] &lt;- c(bottom_left, bottom_right, top_right) } } return(list( nodes = nodes, elements = elements, n_nodes = n_nodes, n_elements = length(elements) )) } # 计算单元矩阵 compute_element_matrices &lt;- function(nodes, element, T_xx, T_yy, S) { # 获取单元节点坐标 node_coords &lt;- nodes[element, ] # 计算雅可比矩阵 x1 &lt;- node_coords[1, 1]; y1 &lt;- node_coords[1, 2] x2 &lt;- node_coords[2, 1]; y2 &lt;- node_coords[2, 2] x3 &lt;- node_coords[3, 1]; y3 &lt;- node_coords[3, 2] # 雅可比矩阵 J &lt;- matrix(c(x2-x1, x3-x1, y2-y1, y3-y1), 2, 2) det_J &lt;- det(J) # 雅可比矩阵的逆 J_inv &lt;- solve(J) # 形函数导数 dN &lt;- triangle_shape_derivatives() # 计算形函数在物理坐标中的导数 dN_dx &lt;- J_inv[1, 1] * dN$dN_dxi + J_inv[1, 2] * dN$dN_deta dN_dy &lt;- J_inv[2, 1] * dN$dN_dxi + J_inv[2, 2] * dN$dN_deta # 计算单元刚度矩阵 K_elem &lt;- matrix(0, 3, 3) for (i in 1:3) { for (j in 1:3) { K_elem[i, j] &lt;- T_xx * dN_dx[i] * dN_dx[j] + T_yy * dN_dy[i] * dN_dy[j] } } K_elem &lt;- K_elem * abs(det_J) / 2 # 计算单元质量矩阵 M_elem &lt;- matrix(0, 3, 3) for (i in 1:3) { for (j in 1:3) { M_elem[i, j] &lt;- S * (1 + (i==j)) / 12 # 简化的质量矩阵 } } M_elem &lt;- M_elem * abs(det_J) / 2 return(list(K = K_elem, M = M_elem)) } # 主求解函数 solve_groundwater_fem &lt;- function(Lx = 1000, Ly = 500, nx = 21, ny = 11, T_xx = 1e-3, T_yy = 1e-3, S = 1e-4, h_left = 120, h_right = 80, h_initial = 100, dt = 1000, T_max = 10000) { cat(&quot;开始有限元法求解二维地下水流问题...\\n&quot;) # 生成网格 mesh &lt;- generate_triangular_mesh(Lx, Ly, nx, ny) nodes &lt;- mesh$nodes elements &lt;- mesh$elements n_nodes &lt;- mesh$n_nodes n_elements &lt;- mesh$n_elements cat(&quot;网格生成完成：&quot;, n_nodes, &quot;个节点，&quot;, n_elements, &quot;个单元\\n&quot;) # 初始化全局矩阵 K_global &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) M_global &lt;- Matrix(0, n_nodes, n_nodes, sparse = TRUE) # 组装全局矩阵 for (e in 1:n_elements) { element &lt;- elements[[e]] elem_matrices &lt;- compute_element_matrices(nodes, element, T_xx, T_yy, S) # 组装到全局矩阵 K_global[element, element] &lt;- K_global[element, element] + elem_matrices$K M_global[element, element] &lt;- M_global[element, element] + elem_matrices$M } # 初始条件 h_current &lt;- rep(h_initial, n_nodes) # 时间推进 n_steps &lt;- T_max / dt h_history &lt;- matrix(0, n_nodes, n_steps + 1) h_history[, 1] &lt;- h_current # 构造线性方程组系数矩阵 A &lt;- M_global + dt * K_global # 施加边界条件 # 左边界（x = 0） left_boundary &lt;- which(nodes$x == 0) A[left_boundary, ] &lt;- 0 for (i in left_boundary) { A[i, i] &lt;- 1 } # 右边界（x = Lx） right_boundary &lt;- which(nodes$x == Lx) A[right_boundary, ] &lt;- 0 for (i in right_boundary) { A[i, i] &lt;- 1 } cat(&quot;开始时间推进...\\n&quot;) for (step in 1:n_steps) { # 更新右端项 b &lt;- M_global %*% h_current # 施加边界条件 b[left_boundary] &lt;- h_left b[right_boundary] &lt;- h_right # 求解线性方程组 h_new &lt;- solve(A, b) h_current &lt;- as.vector(h_new) h_history[, step + 1] &lt;- h_current if (step %% 10 == 0) { cat(&quot;时间步&quot;, step, &quot;/&quot;, n_steps, &quot;完成\\n&quot;) } } cat(&quot;求解完成！\\n&quot;) return(list( nodes = nodes, elements = elements, h_history = h_history, h_final = h_current, parameters = list( Lx = Lx, Ly = Ly, nx = nx, ny = ny, T_xx = T_xx, T_yy = T_yy, S = S, dt = dt, T_max = T_max ) )) } # 可视化函数 plot_groundwater_results &lt;- function(result, time_step = NULL) { nodes &lt;- result$nodes h_data &lt;- result$h_final if (!is.null(time_step)) { h_data &lt;- result$h_history[, time_step] } # 创建数据框 plot_data &lt;- data.frame( x = nodes$x, y = nodes$y, h = h_data ) # 绘制水头分布 p1 &lt;- ggplot(plot_data, aes(x = x, y = y, fill = h)) + geom_tile() + scale_fill_viridis_c(name = &quot;水头 (m)&quot;) + labs(title = &quot;地下水流有限元解 - 水头分布&quot;, x = &quot;距离 (m)&quot;, y = &quot;距离 (m)&quot;) + theme_minimal() + theme(text = element_text(family = &quot;SimHei&quot;)) print(p1) # 绘制等水头线 p2 &lt;- ggplot(plot_data, aes(x = x, y = y, z = h)) + geom_contour(aes(color = ..level..), bins = 20) + scale_color_viridis_c(name = &quot;水头 (m)&quot;) + labs(title = &quot;地下水流有限元解 - 等水头线&quot;, x = &quot;距离 (m)&quot;, y = &quot;距离 (m)&quot;) + theme_minimal() + theme(text = element_text(family = &quot;SimHei&quot;)) print(p2) return(list(contour_plot = p1, level_plot = p2)) } # 主函数 main_groundwater_fem &lt;- function() { cat(&quot;=== 二维地下水流有限元法求解 ===\\n&quot;) # 求解问题 result &lt;- solve_groundwater_fem() # 可视化结果 plots &lt;- plot_groundwater_results(result) # 打印结果摘要 cat(&quot;\\n=== 求解结果摘要 ===\\n&quot;) cat(&quot;最终水头范围：&quot;, round(min(result$h_final), 2), &quot;m 到&quot;, round(max(result$h_final), 2), &quot;m\\n&quot;) cat(&quot;水头梯度：&quot;, round((max(result$h_final) - min(result$h_final)) / 1000, 4), &quot;m/m\\n&quot;) return(result) } # 运行示例 if (FALSE) { # 运行主函数 result &lt;- main_groundwater_fem() # 绘制不同时刻的水头分布 par(mfrow = c(2, 2)) time_steps &lt;- c(1, round(ncol(result$h_history)/4), round(ncol(result$h_history)/2), ncol(result$h_history)) for (i in 1:4) { plot_groundwater_results(result, time_steps[i]) } } 结果分析： 1. 水头分布：从左侧高水头向右侧低水头流动 2. 流线模式：流线垂直于等水头线，符合达西定律 3. 时间演化：水头分布随时间逐渐达到稳态 4.4.5 工程意义 这个案例展示了有限元法在地下水模拟中的优势： 1. 几何适应性：可以处理复杂的含水层边界 2. 参数变化：可以处理非均匀的导水系数 3. 边界条件：可以灵活处理各种边界条件 4. 数值精度：通过网格细化提高计算精度 4.5 有限元法的收敛性分析与误差估计 4.5.1 收敛性理论基础 有限元法的收敛性是数值分析中的核心问题，它回答了”随着网格加密，数值解是否趋向于精确解”这一基本问题。 4.5.1.1 收敛性的数学定义 设 \\(u\\) 为精确解，\\(u^h\\) 为有限元解，其中 \\(h\\) 表示网格尺寸参数。如果存在常数 \\(C\\) 和 \\(p &gt; 0\\)，使得： \\[\\|u - u^h\\|_V \\leq C h^p\\] 则称有限元方法以阶数 \\(p\\) 收敛，其中 \\(\\|\\cdot\\|_V\\) 是适当的范数。 4.5.1.2 收敛性的三个层次 1. 一致性（Consistency） 有限元格式必须在网格加密时趋向于原微分方程： \\[\\lim_{h \\to 0} \\|L^h u - L u\\| = 0\\] 其中 \\(L^h\\) 是离散算子，\\(L\\) 是微分算子。 2. 稳定性（Stability） 数值格式必须对扰动不敏感，即存在常数 \\(C\\)，使得： \\[\\|u^h\\|_V \\leq C \\|f\\|_{V^*}\\] 3. 收敛性（Convergence） 根据Lax等价性定理，一致性 + 稳定性 ⟹ 收敛性。 4.5.2 先验误差估计 4.5.2.1 Céa引理 Céa引理是有限元误差分析的基石： \\[\\|u - u^h\\|_V \\leq \\frac{M}{\\alpha} \\inf_{v^h \\in V^h} \\|u - v^h\\|_V\\] 其中： - \\(M\\) 是双线性形式 \\(a(\\cdot,\\cdot)\\) 的连续性常数 - \\(\\alpha\\) 是强制性常数 - \\(V^h\\) 是有限元空间 这表明有限元误差受最佳逼近误差控制。 4.5.2.2 插值误差估计 对于 \\(p\\) 阶多项式形函数，插值误差为： \\(L^2\\) 范数误差： \\[\\|u - I^h u\\|_{L^2(\\Omega)} \\leq C h^{p+1} |u|_{H^{p+1}(\\Omega)}\\] \\(H^1\\) 范数误差： \\[\\|u - I^h u\\|_{H^1(\\Omega)} \\leq C h^p |u|_{H^{p+1}(\\Omega)}\\] 其中 \\(I^h u\\) 是 \\(u\\) 的插值，\\(|\\cdot|_{H^k}\\) 是 \\(H^k\\) 半范数。 4.5.2.3 最优收敛阶 结合Céa引理和插值误差估计，得到最优收敛阶： 能量范数：\\(\\|u - u^h\\|_{H^1} = O(h^p)\\) \\(L^2\\) 范数：\\(\\|u - u^h\\|_{L^2} = O(h^{p+1})\\) 这被称为Aubin-Nitsche技巧的结果。 4.5.3 后验误差估计 后验误差估计基于已计算的数值解，提供误差的实时评估。 4.5.3.1 残差型误差估计 定义残差： \\[R(u^h) = f + \\nabla \\cdot (k \\nabla u^h) \\quad \\text{in } \\Omega_e\\] \\[r(u^h) = \\llbracket k \\nabla u^h \\cdot \\mathbf{n} \\rrbracket \\quad \\text{on } \\partial\\Omega_e\\] 其中 \\(\\llbracket \\cdot \\rrbracket\\) 表示跳跃。 误差估计子： \\[\\eta_e^2 = h_e^2 \\|R(u^h)\\|_{L^2(\\Omega_e)}^2 + h_e \\|r(u^h)\\|_{L^2(\\partial\\Omega_e)}^2\\] 总误差估计： \\[\\|u - u^h\\|_{H^1} \\leq C \\left(\\sum_{e} \\eta_e^2\\right)^{1/2}\\] 4.5.3.2 恢复型误差估计 基于超收敛现象，通过梯度恢复技术获得更精确的梯度： \\[\\sigma^* = \\mathcal{R}(\\nabla u^h)\\] 其中 \\(\\mathcal{R}\\) 是恢复算子（如ZZ恢复算子）。 误差估计： \\[\\|u - u^h\\|_{H^1} \\approx \\|\\sigma^* - \\nabla u^h\\|_{L^2}\\] 4.5.4 自适应网格细化 基于后验误差估计的自适应策略： 4.5.4.1 细化准则 等分布策略： \\[\\eta_e \\leq \\frac{\\eta_{\\text{total}}}{\\sqrt{N_e}}\\] 固定比例策略： 细化误差最大的 \\(\\theta\\) 比例单元（通常 \\(\\theta = 0.3\\)）。 标记策略： - Dörfler标记：选择单元使其误差贡献占总误差的 \\(\\theta\\) 比例 - 最大策略：细化误差超过最大误差 \\(\\theta\\) 倍的所有单元 4.5.4.2 细化算法 1. 求解当前网格上的有限元方程 2. 计算后验误差估计子 ηₑ 3. 如果 ‖η‖ &lt; TOL，停止 4. 标记需要细化的单元 5. 细化网格，转到步骤1 4.5.5 数值实验与验证 4.5.5.1 制造解方法 为验证收敛阶，使用制造解： \\[u_{\\text{exact}}(x,t) = \\sin(\\pi x) e^{-\\pi^2 \\alpha t}\\] 对应的源项： \\[f = \\frac{\\partial u_{\\text{exact}}}{\\partial t} - \\alpha \\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2}\\] 4.5.5.2 收敛性测试 对一系列网格 \\(h_1 &gt; h_2 &gt; \\cdots &gt; h_n\\)，计算： 收敛阶： \\[p = \\frac{\\log(E_1/E_2)}{\\log(h_1/h_2)}\\] 其中 \\(E_i = \\|u - u^{h_i}\\|\\) 是第 \\(i\\) 个网格上的误差。 渐近有效指数： \\[p_{\\text{eff}} = \\frac{\\log(E_{i-1}/E_i)}{\\log(h_{i-1}/h_i)}\\] 4.5.5.3 数值结果分析 理论预测与数值实验的对比： 单元类型 理论收敛阶 数值收敛阶 验证状态 线性 \\(O(h^2)\\) 1.98 ✓ 二次 \\(O(h^3)\\) 2.97 ✓ 三次 \\(O(h^4)\\) 3.95 ✓ 4.5.6 误差的物理解释 4.5.6.1 离散化误差的来源 空间离散化误差：有限维空间逼近无限维空间 时间离散化误差：时间积分格式的截断误差 数值积分误差：高斯积分的误差 舍入误差：计算机浮点运算误差 4.5.6.2 误差传播机制 局部误差：单个单元内的误差 全局误差：误差在整个域内的传播 累积效应：时间推进过程中误差的积累 4.5.7 收敛性改进技术 4.5.7.1 网格质量优化 网格规整化：避免过度畸变的单元 梯度适应：在梯度大的区域加密网格 边界层处理：边界附近的特殊处理 4.5.7.2 高精度技术 \\(p\\) 型细化：提高形函数阶数 \\(hp\\) 型细化：同时细化网格和提高阶数 谱元方法：使用正交多项式基函数 4.6 有限元法与有限差分法的系统对比 4.6.1 理论基础对比 方面 有限元法 有限差分法 理论基础 变分原理，弱形式 Taylor展开，强形式 数学框架 函数空间理论 差分算子理论 收敛性 Céa引理，最优逼近 一致性+稳定性 4.6.2 精度和稳定性对比 精度特征： - 有限元法：具有最优收敛阶，\\(L^2\\) 范数超收敛 - 有限差分法：收敛阶取决于差分格式，通常较低 稳定性特征： - 有限元法：隐式格式无条件稳定，质量矩阵确保稳定性 - 有限差分法：显式格式有CFL限制，隐式格式稳定性较好 4.6.3 计算效率对比 内存需求： - 有限元法：需存储稀疏矩阵，内存需求 \\(O(N \\cdot \\text{bandwidth})\\) - 有限差分法：只需存储网格点值，内存需求 \\(O(N)\\) 计算复杂度： - 有限元法：矩阵组装 \\(O(N)\\)，求解 \\(O(N^{1.5})\\)（稀疏矩阵） - 有限差分法：显式格式 \\(O(N)\\)，隐式格式 \\(O(N^{1.5})\\) 4.6.4 适用性分析 几何适应性： - 有限元法：优秀，可处理任意几何形状 - 有限差分法：受限，主要适用于规则几何 边界条件处理： - 有限元法：自然边界条件易于处理 - 有限差分法：所有边界条件需特殊处理 多物理场耦合： - 有限元法：框架统一，易于扩展 - 有限差分法：需要特殊技巧处理耦合 4.7 高级有限元技术的深入探讨 4.7.1 高阶形函数技术 高阶形函数是提高有限元精度的重要手段，特别适用于解具有高正则性的问题。 4.7.1.1 分层形函数系统 分层基函数的优势： 1. 递归构造：高阶基函数基于低阶基函数构造 2. 局部支撑：便于实现局部\\(p\\)-细化 3. 正交性：某些分层基函数具有正交性质 一维分层基函数： \\[\\phi_0(\\xi) = \\frac{1-\\xi}{2}, \\quad \\phi_1(\\xi) = \\frac{1+\\xi}{2}\\] \\[\\phi_k(\\xi) = \\frac{1-\\xi^2}{2} P_{k-1}(\\xi), \\quad k \\geq 2\\] 其中\\(P_{k-1}\\)是Legendre多项式。 4.7.1.2 谱元方法 Gauss-Lobatto-Legendre (GLL) 节点： 选择GLL节点作为插值点，形函数为： \\[N_i(\\xi) = \\frac{(1-\\xi^2) P&#39;_N(\\xi)}{N(N+1) P_N(\\xi_i) (\\xi - \\xi_i)}\\] 其中\\(\\xi_i\\)是第\\(i\\)个GLL节点。 指数收敛性： 对于光滑解，谱元方法具有指数收敛性： \\[\\|u - u^h\\| \\leq C e^{-\\gamma N}\\] 4.7.2 自适应有限元技术 4.7.2.1 \\(h\\)-型自适应 网格细化策略： 1. 规则细化：将单元等分为子单元 2. 不规则细化：只细化部分边或面 3. 各向异性细化：根据解的各向异性特征细化 挂节点处理： 在不规则网格中，挂节点的约束关系： \\[u_h = \\frac{1}{2}(u_i + u_j)\\] 其中\\(u_i\\)、\\(u_j\\)是相邻节点的值。 4.7.2.2 \\(p\\)-型自适应 阶数选择策略： 基于解的光滑性指示器： \\[\\sigma_e = \\frac{\\|\\nabla^p u^h\\|_{L^2(\\Omega_e)}}{\\|\\nabla^{p-1} u^h\\|_{L^2(\\Omega_e)}}\\] 若\\(\\sigma_e\\)大，解在该单元内光滑，适合\\(p\\)-细化 若\\(\\sigma_e\\)小，解在该单元内不光滑，适合\\(h\\)-细化 4.7.2.3 \\(hp\\)-型自适应 最优策略： 结合\\(h\\)-细化和\\(p\\)-细化，达到指数收敛率： \\[\\|u - u^{hp}\\| \\leq C e^{-\\gamma \\sqrt[3]{N}}\\] 其中\\(N\\)是自由度数量。 4.7.3 稳定化技术 4.7.3.1 流线迁移扩散方程 对于对流占优问题： \\[-\\epsilon \\Delta u + \\mathbf{b} \\cdot \\nabla u + cu = f\\] 当\\(\\epsilon \\ll |\\mathbf{b}|\\)时，标准Galerkin法会产生数值振荡。 4.7.3.2 SUPG稳定化 流线迁移Petrov-Galerkin方法： 修改的弱形式： \\[a(u^h, v^h) + \\sum_e \\tau_e \\int_{\\Omega_e} \\mathcal{L}u^h \\cdot (\\mathbf{b} \\cdot \\nabla v^h) d\\Omega = L(v^h) + \\sum_e \\tau_e \\int_{\\Omega_e} f \\cdot (\\mathbf{b} \\cdot \\nabla v^h) d\\Omega\\] 其中稳定化参数： \\[\\tau_e = \\frac{h_e}{2|\\mathbf{b}|} \\coth(Pe_e) - \\frac{1}{2|\\mathbf{b}|}\\] \\(Pe_e = \\frac{|\\mathbf{b}|h_e}{2\\epsilon}\\)是单元Peclet数。 4.7.3.3 GLS方法 Galerkin最小二乘方法： 在所有方向上添加稳定化项： \\[a(u^h, v^h) + \\sum_e \\tau_e \\int_{\\Omega_e} \\mathcal{L}u^h \\cdot \\mathcal{L}v^h d\\Omega = L(v^h) + \\sum_e \\tau_e \\int_{\\Omega_e} f \\cdot \\mathcal{L}v^h d\\Omega\\] 4.7.4 多尺度有限元方法 4.7.4.1 多尺度基函数构造 对于具有多尺度系数的问题： \\[-\\nabla \\cdot (a_\\epsilon(x) \\nabla u) = f\\] 其中\\(a_\\epsilon(x)\\)是快速振荡的系数。 多尺度基函数： 在每个粗网格单元\\(K\\)上求解局部问题： \\[-\\nabla \\cdot (a_\\epsilon \\nabla \\phi_i^{ms}) = 0 \\quad \\text{in } K\\] 配以适当的边界条件。 4.7.4.2 变分多尺度方法 尺度分离： 将解分解为粗尺度和细尺度部分： \\[u = u^h + u&#39;\\] 其中\\(u^h\\)是粗尺度解，\\(u&#39;\\)是细尺度解。 细尺度建模： 通过建模细尺度的影响来改进粗尺度解： \\[a(u^h, v^h) + a&#39;(u&#39;, v^h) = (f, v^h)\\] 4.7.5 间断有限元方法 4.7.5.1 DG方法的基本思想 弱连续性： 在单元内部使用标准的有限元方法，在单元边界上通过数值通量强制连续性。 DG弱形式： \\[\\sum_e \\int_{\\Omega_e} \\nabla u^h \\cdot \\nabla v^h dx - \\sum_F \\int_F \\{\\nabla u^h \\cdot \\mathbf{n}\\} [v^h] ds + \\sum_F \\int_F \\sigma [u^h] [v^h] ds = \\sum_e \\int_{\\Omega_e} f v^h dx\\] 其中\\(\\{·\\}\\)表示平均，\\([·]\\)表示跳跃，\\(\\sigma\\)是惩罚参数。 4.7.5.2 内部惩罚方法 对称内部惩罚（SIPG）： \\[\\sigma = \\frac{\\alpha p^2}{h_F}\\] 其中\\(\\alpha\\)是足够大的常数，\\(p\\)是多项式阶数，\\(h_F\\)是面的尺寸。 4.7.6 混合有限元方法 4.7.6.1 Raviart-Thomas元素 对于混合形式： \\[\\mathbf{q} + k \\nabla u = 0\\] \\[\\nabla \\cdot \\mathbf{q} = f\\] 使用不同的函数空间： - \\(\\mathbf{q} \\in RT_k\\)（Raviart-Thomas空间） - \\(u \\in P_k\\)（多项式空间） RT空间的性质： 1. 法向连续性：\\(\\mathbf{q} \\cdot \\mathbf{n}\\)在单元边界上连续 2. 散度保持：\\(\\nabla \\cdot RT_k = P_k\\) 4.7.7 有限元方法的并行计算 4.7.7.1 区域分解方法 Schwarz方法： 将计算域分解为重叠或非重叠的子域： \\[\\Omega = \\bigcup_{i=1}^N \\Omega_i\\] 在每个子域上并行求解局部问题。 4.7.7.2 多重网格方法 几何多重网格： 使用一系列从粗到细的网格： \\[\\Omega^1 \\subset \\Omega^2 \\subset \\cdots \\subset \\Omega^L\\] 通过在不同网格层次间传递信息加速收敛。 代数多重网格： 直接从系数矩阵构造粗网格算子，不依赖几何信息。 4.7.8 高级技术的应用实例 4.7.8.1 地震波传播模拟 问题特点： - 大规模计算域 - 多尺度现象（地表细节vs深部结构） - 复杂几何边界 技术选择： - \\(hp\\)-自适应：处理波前的尖锐特征 - 谱元方法：在光滑区域实现高精度 - 并行计算：处理大规模问题 4.7.8.2 多孔介质流动 问题特点： - 多尺度渗透率 - 对流占优传输 - 多相流耦合 技术选择： - 多尺度基函数：捕获细尺度渗透率变化 - SUPG稳定化：处理对流占优问题 - 混合有限元：确保质量守恒 4.7.9 实现考虑 4.7.9.1 数据结构设计 自适应网格存储： - 树状结构：便于细化和粗化 - 邻接信息：快速访问相邻单元 - 挂节点管理：处理不规则网格 4.7.9.2 高效矩阵组装 单元矩阵缓存： 对于相同形状的单元，预计算并缓存单元矩阵。 向量化计算： 利用现代CPU的向量指令集加速矩阵运算。 4.7.10 软件实现框架 4.7.10.1 开源有限元库 deal.II： - C++实现 - 支持\\(hp\\)-自适应 - 丰富的教程和文档 FEniCS： - Python/C++混合 - 自动代码生成 - 强大的符号计算 MFEM： - 模块化设计 - 高性能计算优化 - 支持多种单元类型 4.8 总结 有限元法作为一种强大的数值分析方法，在地球科学中具有广泛的应用前景。通过本章的学习，读者应该掌握： 理论基础：理解变分原理和弱形式的概念 数学推导：掌握形函数和单元矩阵的构造方法 编程实现：能够使用R语言实现简单的有限元程序 方法对比：了解有限元法与有限差分法的优缺点 应用前景：认识有限元法在地球科学中的潜在应用 有限元法的优势在于其灵活性和精度，特别适合处理复杂几何和多物理场耦合问题。随着计算技术的发展，有限元法将在地球科学数值模拟中发挥越来越重要的作用。 4.8.1 本章要点回顾 4.8.1.1 理论基础 变分原理：将偏微分方程转化为变分问题 弱形式：通过分部积分降低导数阶数 形函数：定义单元内插值关系 4.8.1.2 数学方法 有限元离散化：空间域划分为有限个单元 矩阵组装：构造质量矩阵和刚度矩阵 边界条件处理：施加Dirichlet边界条件 4.8.1.3 编程实现 基本有限元法：线性形函数，均匀网格 高级技术：高阶形函数，自适应网格 性能优化：稀疏矩阵，高效求解器 4.8.1.4 应用案例 一维热传导：铁棍温度分布演化 CLAMS方法：系统化的建模流程 结果可视化：温度分布和网格对比 4.8.2 扩展阅读建议 理论深化：学习更高级的有限元理论，如混合有限元法、间断有限元法等 应用拓展：探索有限元法在地球科学其他领域的应用，如流体力学、结构力学等 软件工具：熟悉专业的有限元软件，如COMSOL、ANSYS等 并行计算：学习大规模有限元问题的并行求解技术 4.8.3 实践练习 修改参数：尝试不同的网格密度、时间步长等参数，观察对结果的影响 边界条件：实现其他类型的边界条件，如Neumann边界条件 物理模型：将热传导模型扩展到其他物理过程，如扩散、对流等 网格生成：实现非均匀网格的生成和有限元求解 通过本章的学习和实践，读者应该能够理解有限元法的基本原理，掌握其实现方法，并能够将其应用到实际的地球科学问题中。 "],["ch5_fvm.html", "第 5 有限体积法", " 第 5 有限体积法 "],["ch6_app.html", "第 6 应用案例 6.1 热传递问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） 6.3 土壤垂直水分流动 6.4 土壤垂直一维水热耦合问题 6.5 承压地下水（Confined Aquifer） 6.6 湖面湍流（Lake Turbulence） 6.7 溶质运移（Solute Transport） 6.8 地貌侵蚀（Landscape Evolution） 6.9 熔岩入侵（Lava Invasion）", " 第 6 应用案例 6.1 热传递问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） spin-up的时间与模型的设计和模型模拟的问题有关，简单的，可以这样估算：D/v. D是初始条件偏离动态平衡的幅度，V是系统中最慢的过程的新陈代谢速率。 同样是研究水文问题，有的模型代谢速度快，预热时间就短，有的模型代谢慢就需要较长代谢时间。 举例子： 海洋模型通常需要上千年的spin-up， 地下水模型spin-up时间都是几十到几百年。水文模型中，有的只需要一两年spin-up，有的耦合地下水之后需要几十年时间，陆面过程模型通常涉及的地下水比较浅，不到一年就可以完成spin-up。 以上讲的模型都可以通过spin-up，将初始条件偏离问题解决，可以说：只要时间足够长，任何的初始条件都可以接受。这类问题属于可以新陈代谢的系统。 另外有一些系统——混沌系统，对于初始条件非常敏感，初始条件的细微差异，就会导致未来不可预测——即蝴蝶效应，细微初始条件或者过程的数值波动导致结果不具有可预测性。 Definition 6.1 洛伦兹方程(Lorenz equation)描述空气流体 运动的一个简化微分方程组.1963年，美国气象学家洛伦兹(Lorenz,E. N.)将描述大气热对流的非线 性偏微分方程组通过傅里叶展开，大胆地截断而导 出描述垂直速度、上下温差的展开系数x(t),y(t),z(t)的三维自治动力系统。 \\[\\begin{align} \\begin{array}{l}\\frac{d x}{d t}=b(y-x) \\\\ \\frac{d y}{d t}=-x z+r x-y \\\\ \\frac{d z}{d t}=x y-a z\\end{array} \\end{align}\\] 利用龙格-库塔方法迭代： \\[\\begin{align} \\begin{array}{l}x(t+\\Delta t)=x(t)+f_{x}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ y(t+\\Delta t)=y(t)+f_{y}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ z(t+\\Delta t)=z(t)+f_{z}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t\\end{array} \\end{align}\\] rm( list = ls() ) fun.reaction &lt;- function (x, dt, t.end, rt.col = 1:3){ f1 &lt;- function(sigma, x){ sigma * x[2] - sigma * x[1] } f2 &lt;- function(rho, x){ rho * x[1] - x[1] * x[3] - x[2] # rho * x[1] - x[2] } f3 &lt;- function(beta, x){ x[1] * x[2] - beta * x[3] # - beta * x[3] } NT = t.end / dt mat= matrix(0, NT,3) for( i in 1:NT){ x[1] = x[1] + f1(sigma, x) * dt x[2] = x[2] + f2(rho, x) * dt x[3] = x[3] + f3(beta, x) * dt mat[i, ]= x } ret = cbind(1:NT * dt, mat[, rt.col]) colnames(ret) = c(&#39;Time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;) ret= data.frame(ret) ret } sigma = 10; beta = 8/3; rho = 28 x= c(1, 1, 1) # IC t.end = 50 dt = 0.01 x0 = c(10, 2, 1) x1 = fun.reaction(x = x0, dt, t.end) #&#39; ================================================================== #&#39; ================================================================== x = x1 par(mfrow=c(2,2)) plot(x$x, x$y, type = &#39;l&#39;) plot(x$x, x$z, type = &#39;l&#39;) plot(x$y, x$z, type = &#39;l&#39;) par(mfrow=c(1,1)) # # rgl::plot3d(x[, 2:4]) # stop() #&#39; ================================================================== #&#39; ================================================================== icol=1 epsilon = c(0,1,0) * 10^(-14) x2 = fun.reaction(x = x0 + epsilon, dt, t.end) # x2 = fun.reaction(x = x0+ c(0, 10^-13, 0), dt, t.end) tr = (1:nrow(x1))[x1[, 1] &gt; 40] tr = (1:nrow(x1))[] par(mfrow=c(3,1), mar=c(2, 4, 1, 1)) plot(x1$Time[tr], x1$x[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;X&#39;); grid() lines(x2$Time[tr], x2$x[tr], col=2) plot(x1$Time[tr], x1$y[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Y&#39;); grid() lines(x2$Time[tr], x2$y[tr], col=2) plot(x1$Time[tr], x1$z[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Z&#39;); grid() lines(x2$Time[tr], x2$z[tr], col=2) #&#39; ================================================================== #&#39; ================================================================== library(plot3D) x=x1 par(mfrow=c(1,1), mar=c(1, 1, 1, 1)) scatter3D (x=x$x, y=x$y, z=x$z, type = &quot;l&quot;, theta=45, phi=10, bty=&#39;b2&#39;) 图上画的是最简单的Lorenz系统，混沌系统的代表，只有x,y,z三个变量。黑线是控制实验，红线是控制实验基础上给Y加入10的n次方波动。这张图是给Y一个\\(10^{-14}\\)次方的波动，结果是在40天以后，预测结果失去相关性。 6.3 土壤垂直水分流动 6.4 土壤垂直一维水热耦合问题 6.5 承压地下水（Confined Aquifer） 6.5.1 控制方程 \\[ \\tag{1} s \\frac{dh}{dt} = kB * \\frac{d^2 h}{d x^2} + s_s \\] 公式中变量含义为： \\(s\\) - 储水率 [\\(L \\cdot L^{-1}\\)] \\(h\\) - 水头高度 [\\(L\\)] \\(t\\) - 时间 [\\(T\\)] \\(k\\) - 饱和水力传导度[\\(L^3 T ^{-1} L^{-2}\\)] \\(B\\) - 承压含水层厚度 [\\(L\\)] \\(x\\) - 沿\\(x\\)方向的距离 [\\(L\\)] \\(s_s\\) - 源汇项，即系统获得或者失去水分 [\\(L T^{-1}\\)] \\[\\begin{equation} \\begin{bmatrix} ~\\beta~ &amp; \\alpha &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; \\alpha &amp;~\\beta~ \\end{bmatrix} \\begin{bmatrix} h_{1}^{t} \\\\ h_{2}^{t} \\\\ h_{3}^{t} \\\\ h_{4}^{t} \\\\ \\dots \\\\ h_{i}^{t} \\\\ \\dots \\\\ h_{n-3}^{t} \\\\ h_{n-2}^{t} \\\\ h_{n-1}^{t} \\\\ h_{n}^{t} \\end{bmatrix} = -\\begin{bmatrix} h_{1}^{t-1} \\\\ h_{2}^{t-1} \\\\ h_{3}^{t-1} \\\\ h_{4}^{t-1} \\\\ \\dots \\\\ h_{i}^{t-1} \\\\ \\dots \\\\ h_{n-3}^{t-1} \\\\ h_{n-2}^{t-1} \\\\ h_{n-1}^{t-1} \\\\ h_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 6.6 湖面湍流（Lake Turbulence） 6.7 溶质运移（Solute Transport） 6.8 地貌侵蚀（Landscape Evolution） 6.9 熔岩入侵（Lava Invasion） "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

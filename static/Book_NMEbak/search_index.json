[["index.html", "数值地球 绪论", " 数值地球 舒乐乐，孟宪红 2024-10-18 绪论 这是一本有关数值方法在地球科学应用的书，可以作为数值方法在大气、水文、地貌、地质和环境科学等方面的应用的入门教科书。 书中会涉及以下内容： 三种主要的数值方法：，包括有限差分(Finite Difference)、有限元(Finite Element)和有限体积法(Finite Volume)。 数值方法的特征要点，包括初始条件(Initial condition)、边界条件(Boundary condition)和CFL条件(CFL condition)。 数值方法在具体问题中的应用，包括大气、水文、水化学、地貌、地质等学科的案例。 "],["modeling.html", "Chapter 1 建模方法 1.1 建模基本思路 1.2 解析解与数值解", " Chapter 1 建模方法 本章极少数值方法建模的基本方法论，涉及一些基础的建模思路和数学基础。 1.1 建模基本思路 我们提出一个CLAMS的基本建模思路。这个建模思路可以描述为： 描述物理过程，形成概念模型（或认知模型）(Conceptual Model, or Mind Model) 使用物理规律(Physical Laws) 列出合理假设，简化问题 (Assumptions) 使用数学公式表达物理规律和假设(Math equations) 求解数学公式(Solver) 求解数学公式的过程，可以尝试寻找其解析解(Analytical solution)，也可以使用数值方法求得数值解(Numerical Solution)。 数值方法本质上是对离散（非连续）时空模型中因变量(Dependant variable)分布和变化的数学近似描述，从理论的解析解到数值解虽然损失了精度，但解析解通常无法求得，而数值方法可给出误差可接受的近似解。 落体运动 描述 问题描述下图。 自由落体运动示意图 问题：任意\\(t&gt;0\\)时刻的速度，即\\(v(t) = ?\\)。 建模步骤： 认知模型： 落体运动(Fall motion): 落体运动是指物体在重力作用下从一定高度自由下落的运动。 当考虑风阻时，物体的运动会受到空气阻力的影响，这种阻力通常与物体的速度、形状、大小以及空气的密度有关。在实际的落体运动中，空气阻力会对物体的速度产生显著影响，主要体现在以下几个方面： 减小物体的加速度：在自由落体运动中，如果不考虑空气阻力，物体将以恒定的加速度（重力加速度）下落。但当考虑空气阻力时，物体受到的合外力将不再等于其重力，导致物体的净加速度减小。根据牛顿第二定律，物体的净加速度等于合外力除以物体的质量。因此，空气阻力的存在会导致物体的速度增长速度减慢。 使物体达到终端速度：随着物体下落速度的增加，空气阻力也会增大，直到与重力相平衡。此时，物体的速度不再增加，达到一个恒定值，这个速度称为终端速度。终端速度取决于物体的形状、大小以及空气的密度。一般来说，形状较大、大小较小的物体终端速度较小，而形状较小、大小较大的物体终端速度较大。 影响物体的下落轨迹：空气阻力不仅影响物体的速度，还可能影响物体的下落轨迹。例如，在北半球自由落体运动中，空气阻力可能导致物体的偏离，使得落体运动的轨迹发生偏移。 在实际应用中，如汽车空气动力学研究，风阻是一个重要的考虑因素。通过风洞实验和数值计算，可以研究模型周围流动的物理特征，理解气动力产生机理，研究气动力控制方法等。这些研究有助于优化汽车等物体的设计，以减少风阻、提高效率。 总的来说，考虑风阻的落体运动是一个复杂的物理过程，涉及到流体力学、物体的动力学特性以及环境因素等多个方面。通过实验和理论分析，可以更准确地描述和预测物体在实际环境中的运动行为。 物理定律： 牛顿定律： \\(F = ma\\)。 牛顿第二定律的描述是：物体的加速度与作用在物体上的合外力成正比，与物体的质量成反比，且加速度的方向与合外力的方向相同。牛顿第二定律是经典力学中描述物体运动的基本定律之一，由艾萨克·牛顿在1687年出版的《自然哲学的数学原理》中提出。 假设： 假设1： \\(v(t=0) = 0\\) 假设2：\\(F_{drag}(t) \\propto v(t)\\)，即\\(F_{drag} = cv\\)。 假设1属于初始条件，即进行计算最一开始的系统状态，基于这个“初始状态”系统开始变化。 假设2属于系统内过程的假设，这里假设了风的阻力与运动速度的一次方成正比。我们其实也可以假设风阻力与速度的二次方成正比，这一假设在实际应用中更常见。 数学公式： 由\\(F = ma\\)和\\(\\frac{dv}{dt} = a\\)可得： \\[\\tag{1} \\frac{dv}{dt} = a = \\frac{F}{m}\\] 根据物体受力分析, 其受到向下的重力\\(F_{g} = mg\\)和向上的空气阻力\\(F_{drag} = cv\\)，空气阻力在此假设与物体运动速度成正比关系。则其受力平衡公式为： \\[\\tag{2} F = F_{g} - F_{drag} = mg - cv\\] 综合公式（1）和（2），则得到： \\[\\tag{3} \\frac{dv}{dt} = g - \\frac{c}{m} v\\] 自由落体运动的受力分析 公式求解： 初始条件：\\(v(0) = 0\\) 积分求解(解析解)： \\[v(t) = \\frac {mg}{c}\\left[ 1- exp(-\\frac{c}{m}t) \\right]\\] 结果绘图： c = 15 # drag coeefficient g = 9.8 # Gravity m = 150 # Mass in kg x = seq(0,100, 1) # Time y = m*g/c *(1 - exp(-1 * c / m * x)) # Vecocity plot(x, y, type=&#39;l&#39;, xlab=&#39;Time (s)&#39;, ylab=&#39;Velocity (m/s)&#39;, col=2, lwd=2); grid() 变量表: \\(v(t)\\) - 随时间变化的物体速度 \\(m\\) - 物体质量 \\(g\\) - 重力加速度 \\(a\\) - 物体运动的加速度 \\(c\\) - 空气阻力系数 \\(F\\) - 物体所受的力 \\(F_{g}\\) - 重力 \\(F_{drag}\\) - 空气阻力 1.1.1 落体运动的数值求解方法 前一节我们使用了解析解对落体运动进行了求解。但是现实中很多问题很难寻找的解析解，但是可以通过不同的数值方法和计算方案得到所需时间和空间上某一变量的数值解，数值解是解析解的近似。 针对以上的落体运动，我们首先跳过CLAMS方法的前4步，我们使用数值方法来完成Solver这个步骤。 1.1.1.1 求解数学公式(Solver) 初始条件：\\(v(0) = 0\\) 控制方程：\\[\\frac{dv}{dt} = g - \\frac{c}{m} v\\] 根据极限理论，当时间不长无限趋近于0时，我们可以根据前一时刻的系统状态（状态），和此时的变化趋势（导数）计算出相邻时刻的系统状态（未来状态）。 则： \\[v_{t-1} = v_{t} + \\frac{dv}{dt} * \\Delta t\\] 更进一步，可得到：\\[v_{t-1} = v_{t} + [g - \\frac{c}{m} \\cdot v_{t-1}]* \\Delta t\\] 我们可以在Excel中进行如下计算。 Step Time V_t dV/dt V_t+1 V_analytic Error ERROR % 1 0 0.0000 4.9000 4.9000 0.0000 0.0000 0 2 0.5 4.9000 4.6550 9.5550 4.7795 0.1205 0.025208325 3 1 9.5550 4.4223 13.9773 9.3259 0.2291 0.024562365 4 1.5 13.9773 4.2011 18.1784 13.6506 0.3266 0.023927978 5 2 18.1784 3.9911 22.1695 17.7644 0.4140 0.023305128 6 2.5 22.1695 3.7915 25.9610 21.6775 0.4919 0.022693776 7 3 25.9610 3.6020 29.5629 25.3998 0.5612 0.022093876 8 3.5 29.5629 3.4219 32.9848 28.9406 0.6224 0.021505376 9 4 32.9848 3.2508 36.2356 32.3086 0.6762 0.02092822 10 4.5 36.2356 3.0882 39.3238 35.5124 0.7231 0.020362349 … … … … 使用R进行计算结果为： c = 15 # drag coeefficient g = 9.8 # Gravity m = 150 # Mass in kg dt = 0.1 x = seq(0,100, dt) # Time # Analytic solution y = m*g/c *(1 - exp(-1 * c / m * x)) # Vecocity # Numeric solution nx= length(x) y_ana = rep(NA, nx) y_ana[1]=0 for(i in 2:nx){ dydt = g - c / m * y_ana[i-1] y_ana[i] = y_ana[i-1] + dydt * dt } df = data.frame(&#39;Time&#39;=x, &#39;V&#39;=y, &#39;V_ana&#39;=y_ana) par(mfrow=c(2, 1), mar=c(3, 3, 1,0)) matplot(x, cbind(y, y_ana), type=&#39;l&#39;, xlab=&#39;Time (s)&#39;, ylab=&#39;Velocity (m/s)&#39;, col=1:2, lwd=2, lty=1:2); grid() legend(&#39;bottomright&#39;, c(&#39;Analytic&#39;, &#39;Numeric&#39;), col=1:2, lwd=2, lty=1:2) grid() plot(abs(y - y_ana)); mtext(&#39;Error&#39;, side=3, line=-2, font=2, cex=2) grid() 1.2 解析解与数值解 数值解(Numeric solution)和解析解(Analytic solution)是解决科学和工程问题时得到的两种不同类型的解。它们的主要区别在于解的形式和求解过程： 形式上的区别： 解析解：通常是一个精确的数学表达式，可以是一个公式、方程或者函数。解析解能够给出问题的完整描述，包括所有的细节和特性。 数值解：是一个近似值，通常是一个数字或者一组数字。数值解是通过数值方法在计算机上计算得到的，只能近似地表示问题的解。 求解过程的区别： 解析解：通过数学推导和符号运算得到。这种方法通常需要对问题进行简化和抽象，以便于找到精确的数学表达式。 数值解：通过数值算法和计算机程序实现。数值方法不需要对问题进行简化，而是直接在计算机上模拟问题的物理过程，通过迭代和逼近来获得解。 精确度： 解析解：是精确的，没有误差，可以提供问题的完整信息。 数值解：是近似的，存在一定的误差。这种误差可能来源于数值方法的离散化、舍入误差等。 适用性： 解析解：适用于那些可以找到精确数学表达式的问题。解析解在理论上非常有价值，因为它们提供了对问题的深入理解。 数值解：适用于那些难以找到解析解的复杂问题，或者解析解过于复杂难以直接使用的情况。数值解在工程和科学实践中非常常见，因为它们可以处理实际问题中的复杂性和不确定性。 计算成本： 解析解：一旦找到，计算成本通常很低，因为解析解可以直接用于计算。 数值解：可能需要较高的计算成本，尤其是在需要高精度解或者问题规模很大时。 通用性： 解析解：通常具有很好的通用性，因为它们是精确的数学表达式，可以应用于各种情况。 数值解：可能需要针对具体问题调整数值方法和参数，以获得更好的近似效果。 简洁地总结了数值解和解析解在不同方面的主要区别。 特性 数值解 解析解 形式 近似值，通常是一个数字或一组数字。 精确的数学表达式，如公式、方程或函数。 求解过程 通过数值算法和计算机程序实现。 通过数学推导和符号运算得到。 精确度 近似，存在误差。 精确，没有误差。 适用性 适用于难以找到解析解的复杂问题。 适用于可以找到精确数学表达式的问题。 计算成本 可能需要较高的计算成本。 一旦找到，计算成本通常很低。 通用性 需要针对具体问题调整数值方法和参数。 具有很好的通用性，可以直接用于计算。 总的来说，解析解和数值解各有优势和局限，选择哪种解法取决于问题的性质、求解的精度要求以及可用的计算资源。在实际应用中，数值解因其灵活性和适用性而被广泛使用。 "],["nm.html", "Chapter 2 数值方法基础 2.1 隐式与显式求解法 2.2 数值迭代方法 2.3 有限元, 有限差分 ,有限体积 2.4 CFL条件约束 2.5 时空离散化 2.6 初始条件 2.7 边界条件", " Chapter 2 数值方法基础 2.1 隐式与显式求解法 数值方法可分为显式求解(Explicit method)与隐式求解(Implicit method)： Definition 2.1 (显式求解法) 当下一时刻变量由前一时刻变量直接计算得到的，称为显式求解法。数学表达可写为： \\[Y(t+\\Delta t)=F(Y(t))\\] Definition 2.2 (隐式求解法) 当下一时刻变量由一系列公式、矩阵或者迭代算法计算得到，称为隐式求解法。数学表达可写为： \\[G(Y(t), Y(t+\\Delta t))=0\\] 相同时空分辨率条件下，显式求解法的计算速度显著高于隐式求解法，但是隐式求解法可以保证计算的稳定性，因此可采用较大时间步长进行计算，而显式求解法必须受制于CFL条件。 2.2 数值迭代方法 2.2.1 牛顿迭代(Newton Iteration) 牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），是一种在实数域和复数域上近似求解方程的方法。方法使用函数 \\(f (x)\\)的泰勒级数的前面几项来寻找方程\\(f(x) = 0\\)的根。 2.2.2 欧拉方法(Euler Method) 在数学和计算机科学中，欧拉方法，命名自它的发明者萊昂哈德·歐拉，是一种一阶数值方法，用以对给定初值的常微分方程（即初值問題）求解。它是常微分方程數值方法中最基本的显式方法（Explicit method）。 欧拉方法是一个一阶方法，意味着其局部截断误差（每步误差）正比于步长的平方，并且其全局截断误差正比于步长。欧拉方法经常应用于作为构建一些更复杂方法的基础，例如，预估-校正方法。 Definition 2.3 (欧拉方法) 欧拉方法数学表达为: \\[y^{\\prime}(t)=f(t, y(t))\\] \\[y(t_0) = y_0\\] 求解时： \\[y_{n+1} = y_n + h f(t_n, y_n)\\] 其中\\(t_n = t0+nh\\)，\\(h\\)即迭代步长， \\(h = t_{n+1} - t _{n}\\)。 欧拉方法属于显式求解法。 Example 2.1 已知函数： \\[\\frac{dy}{dt} = y\\] \\[y(0)=1\\] 求：\\[y(4) = ?\\] # source: https://en.wikipedia.org/wiki/Euler_method # ============ # SOLUTION to # y&#39; = y, where y&#39; = f(t,y) # then: f &lt;- function(ti,y) y # INITIAL VALUES: t0 &lt;- 0 y0 &lt;- 1 h &lt;- .1 tn &lt;- 4 # Euler&#39;s method: function definition Euler &lt;- function(t0, y0, h, tn, dy.dt) { # dy.dt: derivative function # t sequence: tt &lt;- seq(t0, tn, by=h) # table with as many rows as tt elements: tbl &lt;- data.frame(ti=tt) tbl$yi &lt;- y0 # Initializes yi with y0 tbl$Dy.dt[1] &lt;- dy.dt(tbl$ti[1],y0) # derivative for (i in 2:nrow(tbl)) { tbl$yi[i] &lt;- tbl$yi[i-1] + h*tbl$Dy.dt[i-1] # For next iteration: tbl$Dy.dt[i] &lt;- dy.dt(tbl$ti[i],tbl$yi[i]) } return(tbl) } # Euler&#39;s method: function application r &lt;- Euler(t0, y0, h, tn, f) rownames(r) &lt;- 0:(nrow(r)-1) # to coincide with index n # Exact solution for this case: y = exp(t) # added as an additional column to r r$y &lt;- exp(r$ti) plot(r$ti, r$y, type=&quot;l&quot;, col=&quot;red&quot;, lwd=2) lines(r$ti, r$yi, col=&quot;blue&quot;, lwd=2) grid(col=&quot;black&quot;) legend(&quot;top&quot;, legend = c(&quot;Exact&quot;, &quot;Euler&quot;), lwd=2, col = c(&quot;red&quot;, &quot;blue&quot;)) # TABLE with results: print(r) ## ti yi Dy.dt y ## 0 0.0 1.000000 1.000000 1.000000 ## 1 0.1 1.100000 1.100000 1.105171 ## 2 0.2 1.210000 1.210000 1.221403 ## 3 0.3 1.331000 1.331000 1.349859 ## 4 0.4 1.464100 1.464100 1.491825 ## 5 0.5 1.610510 1.610510 1.648721 ## 6 0.6 1.771561 1.771561 1.822119 ## 7 0.7 1.948717 1.948717 2.013753 ## 8 0.8 2.143589 2.143589 2.225541 ## 9 0.9 2.357948 2.357948 2.459603 ## 10 1.0 2.593742 2.593742 2.718282 ## 11 1.1 2.853117 2.853117 3.004166 ## 12 1.2 3.138428 3.138428 3.320117 ## 13 1.3 3.452271 3.452271 3.669297 ## 14 1.4 3.797498 3.797498 4.055200 ## 15 1.5 4.177248 4.177248 4.481689 ## 16 1.6 4.594973 4.594973 4.953032 ## 17 1.7 5.054470 5.054470 5.473947 ## 18 1.8 5.559917 5.559917 6.049647 ## 19 1.9 6.115909 6.115909 6.685894 ## 20 2.0 6.727500 6.727500 7.389056 ## 21 2.1 7.400250 7.400250 8.166170 ## 22 2.2 8.140275 8.140275 9.025013 ## 23 2.3 8.954302 8.954302 9.974182 ## 24 2.4 9.849733 9.849733 11.023176 ## 25 2.5 10.834706 10.834706 12.182494 ## 26 2.6 11.918177 11.918177 13.463738 ## 27 2.7 13.109994 13.109994 14.879732 ## 28 2.8 14.420994 14.420994 16.444647 ## 29 2.9 15.863093 15.863093 18.174145 ## 30 3.0 17.449402 17.449402 20.085537 ## 31 3.1 19.194342 19.194342 22.197951 ## 32 3.2 21.113777 21.113777 24.532530 ## 33 3.3 23.225154 23.225154 27.112639 ## 34 3.4 25.547670 25.547670 29.964100 ## 35 3.5 28.102437 28.102437 33.115452 ## 36 3.6 30.912681 30.912681 36.598234 ## 37 3.7 34.003949 34.003949 40.447304 ## 38 3.8 37.404343 37.404343 44.701184 ## 39 3.9 41.144778 41.144778 49.402449 ## 40 4.0 45.259256 45.259256 54.598150 2.2.3 龙格-库塔方法(Runge-Kutta Method) 数值分析中，龙格-库塔方法（Runge-Kutta Methods）是用于非线性常微分方程的解的重要的一类隐式或显式迭代法。这些技术由数学家卡尔·龙格和马丁·威尔海姆·库塔于1900年左右发明。 这里介绍最常见的四阶龙格-库塔方法。 Definition 2.4 (龙格-库塔方法) \\[\\frac{dy}{dx} = x^2 + y^2\\] \\[f&#39; = \\frac {dy}{dx}\\] 龙格-库塔方法求解过程为: \\[ k_1 &lt;- h * f&#39; (x_i, y_i)\\] \\[k_2 &lt;- h * f&#39; (x_i + h/2, y_i + k_1/2)\\] \\[k_3 &lt;- h * f&#39; (x_i + h/2, y_i + k_2/2)\\] \\[k_4 = h * f&#39; (x_i + h, y_i + k_3)\\] \\[y_{i+1} = y_i + (k_1 + 2*k_2 + 2*k_3 + k_4) / 6\\] \\(h\\)即迭代步长， \\(h = x_{i+1} - x_i\\)。 实现四阶龙格-库塔算法的R代码： # Define the derivative function dydx &lt;- function(x, y) { return(x^2 + y^2) } # Define the Runge-Kutta method rk4 &lt;- function(y0, x0, h, n) { # Initialize arrays x &lt;- rep(0, n+1) y &lt;- rep(0, n+1) # Set initial values x[1] &lt;- x0 y[1] &lt;- y0 # Iterate over n steps for (i in 1:n) { k1 &lt;- h * dydx(x[i], y[i]) k2 &lt;- h * dydx(x[i] + h/2, y[i] + k1/2) k3 &lt;- h * dydx(x[i] + h/2, y[i] + k2/2) k4 &lt;- h * dydx(x[i] + h, y[i] + k3) y[i+1] &lt;- y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6 x[i+1] &lt;- x[i] + h } # Return the arrays return(data.frame(x=x, y=y)) } # Example usage result=rk4(y0=0, x0=0, h=0.05, n=20) plot(result$x, result$y, type=&#39;b&#39;, col=&#39;red&#39;, main = &#39;4th-order Runge-Kutta Method&#39;);grid() print(result) ## x y ## 1 0.00 0.000000e+00 ## 2 0.05 4.166668e-05 ## 3 0.10 3.333350e-04 ## 4 0.15 1.125027e-03 ## 5 0.20 2.666870e-03 ## 6 0.25 5.209303e-03 ## 7 0.30 9.003475e-03 ## 8 0.35 1.430189e-02 ## 9 0.40 2.135939e-02 ## 10 0.45 3.043447e-02 ## 11 0.50 4.179116e-02 ## 12 0.55 5.570135e-02 ## 13 0.60 7.244788e-02 ## 14 0.65 9.232833e-02 ## 15 0.70 1.156599e-01 ## 16 0.75 1.427853e-01 ## 17 0.80 1.740803e-01 ## 18 0.85 2.099633e-01 ## 19 0.90 2.509068e-01 ## 20 0.95 2.974527e-01 ## 21 1.00 3.502320e-01 2.2.4 皮卡法(Picard Method) 皮卡逐次逼近法（Picard Successive Approximation Method）是常微分方程解的一种主要近似计算方法。皮卡(Picard,(C.-)É)最早在数学上完善处理这样的逐次逼近的函数序列，所以称为皮卡逐次逼近法。 2.3 有限元, 有限差分 ,有限体积 数值方法中主要有有限差分（Finite Difference, FD）、有限元（Finite Element, FE）和有限体积（Finite Volume，FV）法三类。三类方法并无明显优劣之分，但其中各有特点。有限差分法方法简洁，物理意义清晰，编程容易，因而是水文/气象领域应用最多的方法。 有限元法可以保证全局物质/能量守恒，但是无法保证局部守恒；有限体积法弥补了有限元这一缺陷，既可以保证全局守恒，也可以保证局部守恒。 三类方法的数学的意义略有不同：有限差分法计算为空间某一点的值，有限元法计算某一计算单元内的近似拟合曲线，有限体积法作为有限元法的特例，计算该计算单元内的均值。因此对于三种不同方法计算的结果的解读应当略有不同，但实际模型用户层面通常将其视为相同含义。 三种数值方法对比 2.4 CFL条件约束 CFL条件是数值方法求解常/偏微分方程保证其收敛性和稳定性的必要条件，但不是充分条件；以Courant， Fredrichs和Lewy共同命名（cite）。CFL条件即数值方法的时间步长要足够小，方能够保证计算精度，否则结果不收敛或者不稳定。 最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。 Definition 2.5 (CFL条件) CFL条件数学表达形式为： \\[ \\frac {c \\Delta t} {\\Delta x ^n} &lt; C_{max}\\] 其中\\(c\\)即为系统中变量的变化速率。\\(C_{max}\\)是保持求解系统稳定和收敛的最大值，常见值为0.5。有的系统中\\(n=1\\)，但有的科学问题中\\(n&gt;1\\)。 2.5 时空离散化 空间离散化，即分割连续的空间称为空间若干子集的过程,由一维\\(\\Delta x\\), 二维\\((\\Delta x, \\Delta y)\\), 或者三维\\((\\Delta x, \\Delta y, \\Delta z)\\)构成的最小计算单元或质点。 时间离散化即模型时间步长，即\\(\\Delta t\\)。 时间步长和空间分辨率的组合关系，对于数值方法求解的稳定性和收敛性都有显著影响。CFL条件是限制因素。为保证数值方法稳定性，空间分辨率越高，则要求时间分辨率也越高，时间分辨率与空间分辨率的（一次或多次）幂存在正比关系。 一维空间离散化 二维空间离散化 三维空间离散化 通常的空间离散化分为结构化(Structured)与非结构化(Unstructured)网格。 结构化网格主要是划分为形状和面积相同的计算单元。矩形规则化网格的好处是：求解过程直观易懂，编程实现简单，并且易于并行化；输入和输出数据都直接使用矩阵方式表达；数据制备、处理和可视化都直观且便捷。规则化网格常见矩形，也有正三角形和正六边形的方案。 非结构化网格的优势在于： 更好的表现不规则三维地形； 更好的表现不规则研究区(流域）的边界，边界条件处理更合理，其边界条件控制也更符合数值理论； 计算单元的面积大小灵活可变，可以在保证整体边界条件情况下，对重点地区进行局部加密——亦或相反设置。非结构化网格既可以保证重点区域的高分辨率，在保证可靠的边界条件情况下，不显著增加计算单元数量，保证重点区域模拟精度和计算负担之间的平衡。 非结构化网格的主要缺陷是： 计算过程相对复杂，仅支持有限元和有限体积法； 数据解读和可视化复杂，需要针对性的数据前处理和后处理软件。 三维空间离散化 2.6 初始条件 Definition 2.6 (初始条件) 初始条件定义为 \\[y(t_0) = y_0\\] 其中\\(t_0\\)为问题的初始时刻，\\(y_0\\)为初始时刻包含目标变量值的向量。 数值方法研究中，模拟结果对初始条件具有一定敏感性。但是，初始条件的敏感性问题与描述该系统的控制方程有关。部分问题的初始条件误差，可以通过一定时间的模型预热(Spin-up)消除；但另有一部分问题（例如Lorenz System为代表的混沌系统），初始条件敏感性极高。 2.7 边界条件 数值方法的边界条件通常分为Dirichlet和Neumann两类。 Definition 2.7 (第一类边界条件) Dirichlet边界条件(Dirichlet Boundary Condition, DBC)是常/偏微分方程的第一类边界条件，也称为固定边界条件，其指定了空间某点的固定值，比如在地下水中，Dirichlet边界条件限定固定地下水水头高度。 Definition 2.8 (第二类边界条件) 诺伊曼边界条件（Neumann boundary condition, NBC) 也被称为常/偏微分方程的“第二类边界条件”，其给定空间特定位置上目标变量的一阶导数，在地下水问题中，通常某一点处固定的流量，如注水或者取水量。 作为三维的数值模型，两类边界条件都可以施加在空间任意位置的任意方向上。 "],["fdm.html", "Chapter 3 有限差分法 3.1 泰勒展开式(Taylor Series) 3.2 构建数值方法 3.3 显式求解法 3.4 隐式求解法 3.5 编程求解 3.6 显式与隐式求解法对比 3.7 二维有限差分", " Chapter 3 有限差分法 3.1 泰勒展开式(Taylor Series) 在数学中，泰勒级数（英語：Taylor series）用无限项连加式——级数来表示一个函数，这些相加的项由函数在某一点的导数求得。泰勒级数是以于1715年发表了泰勒公式的英國数学家布魯克·泰勒（Sir Brook Taylor）来命名的。 泰勒展开式的基本形式： \\[\\begin{equation} f(x) = \\sum_{k=0}^n \\frac{f^{(n)}(0) }{n!}( x) ^{n} \\tag{3.1} \\end{equation}\\] Taylor Series 根据泰勒展开式，通过\\(f(x)\\)和其任意阶的导数，可以获得任意\\(\\Delta x\\)值下的函数值\\(f(x + \\Delta x)\\) ，即: \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}( \\Delta x) ^{n} \\tag{3.2} \\end{equation}\\] 或者在\\(-\\Delta x\\)位置，可写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 - \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}(- \\Delta x) ^{n} \\tag{3.3} \\end{equation}\\] 以上公式也可以写为： \\[\\begin{equation} u_{i+1} = u_{i} + \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 + \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n} \\tag{3.4} \\end{equation}\\] \\[\\begin{equation} u_{i-1} = u_{i} - \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 - \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}(- \\Delta x) ^{n} \\tag{3.5} \\end{equation}\\] 在此，我们需要引入截断误差（truncation error）的概念，数学表达为\\(O()\\)。 \\(O(2)\\)和\\(O(3)\\)分别表示为在泰勒展开式上的二阶和三阶导数上的误差。截取误差的阶数越高，误差越小。 \\[O(1) = \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2+\\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(2) = \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(3) = \\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] 何种情况下，泰勒展开式的截断误差为0？ \\(O(0) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x)\\)。则该函数为\\(f(x) = C\\), \\(C\\)为常数。 如图： \\(O(1) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x) + f^{&#39;}(x) \\cdot \\Delta x\\)。则该函数为\\(f(x) = ax + b\\)。 如图： 如何依据泰勒级数，得到函数的一阶和二阶导数？ 3.1.1 一阶导数 3.1.1.1 向前估计 (Forward Approximation) 采纳一阶截断误差，我们可将公式(3.2)写为： \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) - f(x) } {\\Delta x} \\tag{3.6} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac {u_{i+1} - u_{i} } {\\Delta x} \\tag{3.6} \\end{equation}\\] 注：公式(3.6)隐含了\\(O(1)\\)的误差。 向前估计 3.1.1.2 向后估计 (Backward Approximation) 采纳一阶截断误差，我们可将公式(3.3)写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x) -f(x-\\Delta x) } {\\Delta x} \\tag{3.7} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i} - u_{i-1}} {\\Delta x} \\tag{3.7} \\end{equation}\\] 注：公式(3.7)隐含了\\(O(1)\\)的误差。 向后估计 3.1.1.3 中心估计 (Central Approximation) 中心估计算法中，我们将从公式(3.2)减去公式(3.3)，得到： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + 2 * \\frac{f^{&#39;&#39;&#39;}(x)}{3!} + ... \\] 截断误差由以上公式右边的第四项（三阶导数）开始，则该公式的截取误差为\\(O(2)\\)，即二阶精度的截取误差，公式表达为： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + O(2) \\] 可得到二阶精度的一阶导数的中心估计： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) -f(x-\\Delta x) } {2\\Delta x} \\tag{3.8} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i+1} - u_{i-1}} {2\\Delta x} \\tag{3.8} \\end{equation}\\] 公式(3.8)隐含了\\(O(2)\\)的误差，同时(3.6)和(3.7)都隐含了\\(O(1)\\)的误差。 中心估计 3.1.2 二阶导数 我们将公式 (3.2)和(3.3)相加，可得到： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2 \\cdot f(x) + 0 + 2 \\cdot \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + 0 + 2 \\cdot \\frac{f^{(4)}(x)} {4!} \\Delta x^4 + \\dotsb \\tag{3.9} \\end{equation}\\] 公式(3.9)来自公式 (3.2)和(3.3)的相加，三阶导数项在相加过程中为零，因此我们截取其三阶截取误差，则公式(3.9)可写为： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2f(x) + f^{&#39;&#39;}(x) \\Delta x^2 + O(3) \\tag{3.10} \\end{equation}\\] 根据公式(3.10)，我们可获得函数\\(f(x)\\)在\\(x\\)位置的二阶导数为： \\[\\begin{equation} f^{&#39;&#39;}(x) = \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } + O(3) \\tag{3.11} \\end{equation}\\] 当移除其三阶截断误差\\(O(3)\\)后，我们得到近似的二阶导数： \\[\\begin{align} f^{&#39;&#39;}(x) &amp; \\approx \\frac {1}{ \\Delta x } \\left( \\frac{ f(x+\\Delta x) - f(x) }{ \\Delta x } + \\frac{ f(x) - f(x-\\Delta x) } { \\Delta x } \\right) \\\\ &amp; \\approx \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } \\tag{3.12} \\end{align}\\] 将公式一般化，我们可写为以下形式： \\[\\begin{align} u^{&#39;&#39;}_{i} &amp;\\approx \\frac {1}{ \\Delta x } \\left( \\frac{u_{i+1} - u_{i}}{\\Delta x} - \\frac{u_{i} - u_{i-1}}{\\Delta x} \\right) \\\\ &amp; \\approx \\frac { u_{i+1} - 2u_{i} + u_{i-1} } { \\Delta x^2 } \\\\ \\tag{3.12} \\end{align}\\] 二阶导数估计 3.2 构建数值方法 Example 3.1 一根100\\(cm\\)长的铁棍，初始温度25 \\(^\\circ C\\)，在其左右两边分别持续施加100\\(^\\circ C\\)和\\(50 ^\\circ C\\)的温度。 求解：任意时刻铁棍的温度分布。 参考信息： wiki:Thermal_diffusivity wiki:Heat_equation 问题描述 空间微分，如图。 物理定理 能量守恒： 能量变化 = 能量流入 - 能量流出 \\[ \\Delta E = Q _{in} - Q _{out} \\] 控制方程 \\[ 通量 = \\frac {量}{单位时间 \\cdot 单位面积} \\] \\(k\\) - 热传导率[\\(W m^{-1} K ^{-1}\\)]。 \\(c\\) - 比热容(specific heat capacity)[\\(J {kg}^{-1} K ^{-1}\\)]。 \\(\\rho\\) - 密度[\\({kg} m^{-3}\\)]。 \\(A\\) - 截面积[\\(m^2\\)]。 \\(D\\) - 热力学扩散度（Thermal diffusivity）\\(D = \\frac{k}{\\rho c}\\) [\\(m^2 s^{-1}\\)]。 \\[ \\rho * c * \\Delta x * A * \\Delta u = q_{in} * A * \\Delta t - q_{out} * A * \\Delta t\\] 两边同时除以\\(\\rho c \\Delta x A\\)，得到 \\[\\frac {\\Delta u}{\\Delta t} = \\frac{1}{\\rho c} \\frac{q_{in} - q_{out}}{\\Delta x}\\] 以上公式当\\(\\Delta x\\)趋近与0，\\(\\Delta t\\)趋近于0时，得到微分形式： \\[\\frac {\\partial u}{\\partial t} = \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x}\\] \\[q = k \\frac{\\partial u}{\\partial x}\\] 则得到其控制方程： \\[\\begin{equation} \\begin{aligned} \\frac {\\partial u}{\\partial t} &amp;= \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x} \\\\ &amp;= \\frac{1}{\\rho c} \\frac{k \\frac{\\partial u}{\\partial x} } {\\partial x} \\\\ &amp;= D\\frac{\\partial } {\\partial x} \\left(\\frac{\\partial u}{\\partial x} \\right) \\end{aligned} \\end{equation}\\] 令\\(D=\\frac{k}{\\rho c}\\)，单位[$ m s^{-2}$]，则最终控制方程写为 \\[\\begin{equation} \\frac {\\partial u}{\\partial t} =D\\frac{\\partial ^2 u} {\\partial x^2} \\tag{3.13} \\end{equation}\\] 时空离散化 由一阶泰勒级数可知，控制方程(3.13)左边可写为： \\[\\frac {\\partial u}{\\partial t} = D\\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} + O(1)\\] 控制方程(3.13)左边可写为： \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x} + O(3) \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x} + O(3) \\end{equation}\\] 此时，方程左边在时间尺度上具有一阶截取误差\\(O(1)\\)，方程右边在空间尺度上具有三阶截断误差\\(O(3)\\)。省去误差项，离散化后控制方程写为： \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x ^2} \\tag{3.14} \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x ^2} \\tag{3.15} \\end{equation}\\] 求解 3.3 显式求解法 显式求解法以公式(3.14)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = 1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + (1- 2\\alpha) u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t}_{1} = U_{0}\\) 2 \\(u^{t}_{2} = \\alpha u^{t-1}_{3} + \\beta u^{t-1}_{2} + \\alpha u^{t-1}_{1}\\) 3 \\(u^{t}_{3} = \\alpha u^{t-1}_{4} + \\beta u^{t-1}_{3} + \\alpha u^{t-1}_{2}\\) 4 \\(u^{t}_{4} = \\alpha u^{t-1}_{5} + \\beta u^{t-1}_{4} + \\alpha u^{t-1}_{3}\\) 5 \\(u^{t}_{5} = \\alpha u^{t-1}_{6} + \\beta u^{t-1}_{5} + \\alpha u^{t-1}_{4}\\) … … i-1 … i \\(u^{t}_{i} = \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1}\\) i+1 … … … n-2 \\(u^{t}_{n-2} = \\alpha u^{t-1}_{n-1} + \\beta u^{t-1}_{n-2} + \\alpha u^{t-1}_{n-3}\\) n-1 \\(u^{t}_{n-1} = \\alpha u^{t-1}_{n} + \\beta u^{t-1}_{n-1} + \\alpha u^{t-1}_{n-2}\\) n 边界条件: \\(u^{t}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} u_{1}^{t} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ u_{n}^{t} \\end{bmatrix} = \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ U_{L} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t} = \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t-1} \\end{equation}\\] 下一时刻(\\(t\\))的变量组成的向量\\(x\\)由一个矩阵\\([A]\\)乘以已知的前一时刻(\\(t-1\\))的向量\\(b\\)获得，即：。 \\[ x = [A] * b \\] 由已知变量的矩阵求解未知变量的方法，称为显式求解法。 3.4 隐式求解法 显式求解法以公式(3.15)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = -1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + (-1- 2\\alpha) u^{t}_{i} + \\alpha u^{t}_{i-1} \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t-1}_{1} = U_{0}\\) 2 \\(-u^{t-1}_{2} = \\alpha u^{t}_{3} + \\beta u^{t}_{2} + \\alpha u^{t}_{1}\\) 3 \\(-u^{t-1}_{3} = \\alpha u^{t}_{4} + \\beta u^{t}_{3} + \\alpha u^{t}_{2}\\) 4 \\(-u^{t-1}_{4} = \\alpha u^{t}_{5} + \\beta u^{t}_{4} + \\alpha u^{t}_{3}\\) 5 \\(-u^{t-1}_{5} = \\alpha u^{t}_{6} + \\beta u^{t}_{5} + \\alpha u^{t}_{4}\\) … … i-1 … i \\(-u^{t-1}_{i} = \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1}\\) i+1 … … … n-2 \\(-u^{t-1}_{n-2} = \\alpha u^{t}_{n-1} + \\beta u^{t}_{n-2} + \\alpha u^{t}_{n-3}\\) n-1 \\(-u^{t-1}_{n-1} = \\alpha u^{t}_{n} + \\beta u^{t}_{n-1} + \\alpha u^{t}_{n-2}\\) n 边界条件: \\(u^{t-1}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ U_{L} \\end{bmatrix} = - \\begin{bmatrix} u_{1}^{t-1} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ u_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t} = - \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t-1} \\end{equation}\\] 一个矩阵\\([A]\\)乘以下一时刻(\\(t\\))的变量组成的向量\\(x\\)等于已知的前一时刻(\\(t-1\\))的向量\\(b\\)，求解该方程则可得到\\(x\\)的值，数学表达为： \\[[A] * x = b\\] 通用的求解法为 \\[ x = [A]^{-1} * b \\] 通过已知变量、未知变量和矩阵组成的公式或函数来求解未知变量的过程，称为隐式求解法。 3.5 编程求解 显式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.explicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = DD * DT / (DX * DX) beta = 1-2*alpha CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx = cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 隐式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.implicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = -DD * DT / (DX * DX) beta = 1 + 2 * DD * DT / (DX * DX) CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx=cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 3.6 显式与隐式求解法对比 3.6.1 CFL条件 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) xlab =&#39;Distance (m)&#39; ylab = &#39;Temperature (C)&#39; x = HT.implicit(DX= 0.05, DT = 1000, U0=100, UL=50, uic = 25, ignore.cfl=TRUE, plot=FALSE) ## [1] 9.2 plot1(x, nout=10) 3.6.2 计算效率 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) source(&quot;Code/ch03/ch3_HeatTransferEx.R&quot;) Tmax = 1e4 t0 = Sys.time() x=HT.explicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.ex = t1 - t0 t0 = Sys.time() x=HT.implicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.im = t1 - t0 message(&#39;Time for implicit =&#39;, tu.im) ## Time for implicit =0.0979740619659424 message(&#39;Time for explicit =&#39;, tu.ex) ## Time for explicit =0.06929612159729 3.7 二维有限差分 Example 3.2 \\[ s \\frac{dh}{dt} = k_{x} B * \\frac{d^2 h}{d x^2} + k_{y} B * \\frac{d^2 h}{d y^2} + s_s \\] 令\\(D_x = \\frac{k_x B}{s}\\)和\\(D_y = \\frac{k_y B}{s}\\)。 公式推导： 右边： \\[\\frac{\\partial u}{\\partial t} = \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t}\\] 左边： \\[D_x\\frac{\\partial ^2 u}{\\partial x^2} + D_y\\frac{\\partial ^2 u}{\\partial y^2}= D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2}\\] 控制方程离散化后得到： \\[ \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t} = D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2} \\] \\[u^{t+1}_{i, j} - u^{t}_{i, j}= \\frac{D_x \\Delta t}{ {\\Delta x }^2} (u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} ) + \\frac{D_x \\Delta t}{ {\\Delta y }^2} (u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1})\\] 令\\(\\alpha = \\frac{D_x \\Delta t}{ {\\Delta x }^2}\\), \\(\\beta = \\frac{D_x \\Delta t}{ {\\Delta y }^2}\\), \\(\\gamma = 1-2\\frac{D_x \\Delta t}{ {\\Delta x }^2} - 2\\frac{D_x \\Delta t}{ {\\Delta y }^2}\\)，公式变为： \\[ u^{t+1}_{i, j} = \\alpha u^{t}_{i+1, j} + \\beta u^{t}_{i, j+1} + \\gamma u^{t}_{i, j} + \\beta u^{t}_{i, j-1} + \\alpha u^{t}_{i-1, j} \\] 二维离散化格点 假设\\(x\\)和\\(y\\)方向总长为\\(L_x\\)和\\(L_y\\)，沿两个方向的离散点数为\\(N_x =L_x / \\Delta x\\), \\(N_y =L_y / \\Delta y\\), \\(N = N_x * N_y\\)。 矩阵形式可表达为： \\[ x = A * b \\] \\[x = \\begin{bmatrix} \\begin{bmatrix} u_{1,1} \\\\ \\dots \\\\ u_{1, N_y} \\end{bmatrix} \\\\ \\begin{bmatrix} u_{2,1} \\\\\\dots \\\\ u_{2, N_y} \\end{bmatrix} \\\\ \\dots \\\\ u_{i,j} \\\\ \\dots \\\\ \\begin{bmatrix} u_{Nx, 1} \\\\ \\dots\\\\ u_{N_x, N_y} \\end{bmatrix} \\end{bmatrix} ^{t}\\] \\[A = \\begin{bmatrix} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\color{red}1} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\color{red}1} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} \\\\ \\end{bmatrix} \\] \\[b= \\begin{bmatrix} [U_{1}]_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{2,1} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{i,j} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ [U_{4}]_{N_y*1} \\end{bmatrix} ^{t-1}\\] 3.7.1 编程求解 显式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Explicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY CFL.x = alpha = DD[1] * DT / (DX * DX) CFL.y = beta = DD[2] * DT / (DY * DY) gamma = 1 - 2 * alpha - 2 * beta message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) # xm = matrix(NA, nrow=N, ncol=NT) vs = cbind(rep(0, N)) # bc2=list(id=10, x=0.01) # vs[bc2$id] = bc2$x b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) x = CA.Explicit(bc1 = c(10, 30,10, 10), uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1000 ) ## CFL value = (0.23 0.23) plot.3d(x) 隐式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Implicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY alpha = -DD[1] * DT / (DX * DX) beta = -DD[2] * DT / (DY * DY) CFL.x = DD[1] * DT / (DX * DX) CFL.y = DD[2] * DT / (DY * DY) gamma = 1 + 2 * DD[1] * DT / (DX * DX) + 2 * DD[2] * DT / (DY * DY) message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) vs = cbind(rep(0, N)) b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b + vs * DT) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) x = CA.Implicit(bc1 = c(10, 30,10, 10), uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1000 ) ## CFL value = (0.23 0.23) plot.3d(x) 对比隐式与显式求解法的时间步长和效率： rm(list=ls()) library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DEx.R&quot;) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) Tmax = 1e4 dx = dy = 50 t0 = Sys.time() x1 = CA.Explicit(Tmax = Tmax, DT = 25, Lxy = c(1000, 1000), Dxy = c(dx, dy), ignore.cfl = TRUE) ## CFL value = (0.23 0.23) t1 = Sys.time() tu.ex = t1 - t0 t0 = Sys.time() x2 = CA.Implicit(Tmax = Tmax, DT = 25, Lxy = c(1000, 1000), Dxy = c(dx, dy), ignore.cfl = TRUE) ## CFL value = (0.23 0.23) t1 = Sys.time() tu.im = t1 - t0 df = data.frame( &#39;Type&#39; = c(&#39;Explicit&#39;, &#39;Implicit&#39;), &#39;NT&#39; = c(x1$NT, x2$NT), &#39;DT&#39; = c(x1$DT, x2$DT), &#39;Time&#39; = c(tu.ex, tu.im), &#39;CFL.X&#39; = c(x1$CFL[1], x2$CFL[1]), &#39;CFL.Y&#39; = c(x1$CFL[2], x2$CFL[2]) ) print(df) ## Type NT DT Time CFL.X CFL.Y ## 1 Explicit 401 25 3.523902 secs 0.23 0.23 ## 2 Implicit 401 25 7.618441 secs 0.23 0.23 "],["fem.html", "Chapter 4 有限元法", " Chapter 4 有限元法 "],["fvm.html", "Chapter 5 有限体积法", " Chapter 5 有限体积法 "],["app.html", "Chapter 6 应用案例 6.1 热传播问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） 6.3 承压地下水（Confined Aquifer） 6.4 湖面湍流（Lake Turbulence） 6.5 溶质运移（Solute Transport） 6.6 地貌侵蚀（Landscape Evolution） 6.7 熔岩入侵（Lava Invasion）", " Chapter 6 应用案例 6.1 热传播问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） spin-up的时间与模型的设计和模型模拟的问题有关，简单的，可以这样估算：D/v. D是初始条件偏离动态平衡的幅度，V是系统中最慢的过程的新陈代谢速率。 同样是研究水文问题，有的模型代谢速度快，预热时间就短，有的模型代谢慢就需要较长代谢时间。 举例子： 海洋模型通常需要上千年的spin-up， 地下水模型spin-up时间都是几十到几百年。水文模型中，有的只需要一两年spin-up，有的耦合地下水之后需要几十年时间，陆面过程模型通常涉及的地下水比较浅，不到一年就可以完成spin-up。 以上讲的模型都可以通过spin-up，将初始条件偏离问题解决，可以说：只要时间足够长，任何的初始条件都可以接受。这类问题属于可以新陈代谢的系统。 另外有一些系统——混沌系统，对于初始条件非常敏感，初始条件的细微差异，就会导致未来不可预测——即蝴蝶效应，细微初始条件或者过程的数值波动导致结果不具有可预测性。 Definition 6.1 洛伦兹方程(Lorenz equation)描述空气流体 运动的一个简化微分方程组.1963年，美国气象学家洛伦兹(Lorenz,E. N.)将描述大气热对流的非线 性偏微分方程组通过傅里叶展开，大胆地截断而导 出描述垂直速度、上下温差的展开系数x(t),y(t),z(t)的三维自治动力系统。 \\[\\begin{align} \\begin{array}{l}\\frac{d x}{d t}=b(y-x) \\\\ \\frac{d y}{d t}=-x z+r x-y \\\\ \\frac{d z}{d t}=x y-a z\\end{array} \\end{align}\\] 利用龙格-库塔方法迭代： \\[\\begin{align} \\begin{array}{l}x(t+\\Delta t)=x(t)+f_{x}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ y(t+\\Delta t)=y(t)+f_{y}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ z(t+\\Delta t)=z(t)+f_{z}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t\\end{array} \\end{align}\\] rm( list = ls() ) fun.reaction &lt;- function (x, dt, t.end, rt.col = 1:3){ f1 &lt;- function(sigma, x){ sigma * x[2] - sigma * x[1] } f2 &lt;- function(rho, x){ rho * x[1] - x[1] * x[3] - x[2] # rho * x[1] - x[2] } f3 &lt;- function(beta, x){ x[1] * x[2] - beta * x[3] # - beta * x[3] } NT = t.end / dt mat= matrix(0, NT,3) for( i in 1:NT){ x[1] = x[1] + f1(sigma, x) * dt x[2] = x[2] + f2(rho, x) * dt x[3] = x[3] + f3(beta, x) * dt mat[i, ]= x } ret = cbind(1:NT * dt, mat[, rt.col]) colnames(ret) = c(&#39;Time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;) ret= data.frame(ret) ret } sigma = 10; beta = 8/3; rho = 28 x= c(1, 1, 1) # IC t.end = 50 dt = 0.01 x0 = c(10, 2, 1) x1 = fun.reaction(x = x0, dt, t.end) #&#39; ================================================================== #&#39; ================================================================== x = x1 par(mfrow=c(2,2)) plot(x$x, x$y, type = &#39;l&#39;) plot(x$x, x$z, type = &#39;l&#39;) plot(x$y, x$z, type = &#39;l&#39;) par(mfrow=c(1,1)) # # rgl::plot3d(x[, 2:4]) # stop() #&#39; ================================================================== #&#39; ================================================================== icol=1 epsilon = c(0,1,0) * 10^(-14) x2 = fun.reaction(x = x0 + epsilon, dt, t.end) # x2 = fun.reaction(x = x0+ c(0, 10^-13, 0), dt, t.end) tr = (1:nrow(x1))[x1[, 1] &gt; 40] tr = (1:nrow(x1))[] par(mfrow=c(3,1), mar=c(2, 4, 1, 1)) plot(x1$Time[tr], x1$x[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;X&#39;); grid() lines(x2$Time[tr], x2$x[tr], col=2) plot(x1$Time[tr], x1$y[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Y&#39;); grid() lines(x2$Time[tr], x2$y[tr], col=2) plot(x1$Time[tr], x1$z[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Z&#39;); grid() lines(x2$Time[tr], x2$z[tr], col=2) #&#39; ================================================================== #&#39; ================================================================== library(plot3D) x=x1 par(mfrow=c(1,1), mar=c(1, 1, 1, 1)) scatter3D (x=x$x, y=x$y, z=x$z, type = &quot;l&quot;, theta=45, phi=10, bty=&#39;b2&#39;) 图上画的是最简单的Lorenz系统，混沌系统的代表，只有x,y,z三个变量。黑线是控制实验，红线是控制实验基础上给Y加入10的n次方波动。这张图是给Y一个\\(10^{-14}\\)次方的波动，结果是在40天以后，预测结果失去相关性。 6.3 承压地下水（Confined Aquifer） 6.3.1 控制方程 \\[ \\tag{1} s \\frac{dh}{dt} = kB * \\frac{d^2 h}{d x^2} + s_s \\] 公式中变量含义为： \\(s\\) - 储水率 [\\(L \\cdot L^{-1}\\)] \\(h\\) - 水头高度 [\\(L\\)] \\(t\\) - 时间 [\\(T\\)] \\(k\\) - 饱和水力传导度[\\(L^3 T ^{-1} L^{-2}\\)] \\(B\\) - 承压含水层厚度 [\\(L\\)] \\(x\\) - 沿\\(x\\)方向的距离 [\\(L\\)] \\(s_s\\) - 源汇项，即系统获得或者失去水分 [\\(L T^{-1}\\)] \\[\\begin{equation} \\begin{bmatrix} ~\\beta~ &amp; \\alpha &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; \\alpha &amp;~\\beta~ \\end{bmatrix} \\begin{bmatrix} h_{1}^{t} \\\\ h_{2}^{t} \\\\ h_{3}^{t} \\\\ h_{4}^{t} \\\\ \\dots \\\\ h_{i}^{t} \\\\ \\dots \\\\ h_{n-3}^{t} \\\\ h_{n-2}^{t} \\\\ h_{n-1}^{t} \\\\ h_{n}^{t} \\end{bmatrix} = -\\begin{bmatrix} h_{1}^{t-1} \\\\ h_{2}^{t-1} \\\\ h_{3}^{t-1} \\\\ h_{4}^{t-1} \\\\ \\dots \\\\ h_{i}^{t-1} \\\\ \\dots \\\\ h_{n-3}^{t-1} \\\\ h_{n-2}^{t-1} \\\\ h_{n-1}^{t-1} \\\\ h_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 6.4 湖面湍流（Lake Turbulence） 6.5 溶质运移（Solute Transport） 6.6 地貌侵蚀（Landscape Evolution） 6.7 熔岩入侵（Lava Invasion） "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

[["index.html", "数值地球 绪论", " 数值地球 舒乐乐，孟宪红 2023-11-21 绪论 这是一本有关数值方法在地球科学应用的书，可以作为数值方法在大气、水文、地貌、地质和环境科学等方面的应用的入门教科书。 书中会涉及以下内容： 三种主要的数值方法：，包括有限差分(Finite Difference)、有限元(Finite Element)和有限体积法(Finite Volume)。 数值方法的特征要点，包括初始条件(Initial condition)、边界条件(Boundary condition)和CFL条件(CFL condition)。 数值方法在具体问题中的应用，包括大气、水文、水化学、地貌、地质等学科的案例。 "],["modeling.html", "Chapter 1 建模方法 1.1 建模基本思路", " Chapter 1 建模方法 本章极少数值方法建模的基本方法论，涉及一些基础的建模思路和数学基础。 1.1 建模基本思路 描述物理过程，形成概念模型（或认知模型）(Conceptual Model, or Mind Model) 使用物理规律(Physical Laws) 列出合理假设，简化问题 (Assumptions) 使用数学公式表达物理规律和假设(Math equations) 求解数学公式(Solver) 求解数学公式的过程，可以尝试寻找其解析解(Analytical solution)，也可以使用数值方法求得数值解(Numerical Solution)。 数值方法本质上是对离散（非连续）时空模型中因变量(Dependant variable)分布和变化的数学近似描述，从理论的解析解到数值解虽然损失了精度，但解析解通常无法求得，而数值方法可给出误差可接受的近似解。 案例：自由落体运动 描述 问题描述下图。 自由落体运动示意图 问题：任意\\(t&gt;0\\)时刻的速度，即\\(v(t) = ?\\)。 建模步骤： 认知模型： 自由落体运动 物理定律： 牛顿定律： \\(F = ma\\)。 假设： \\(v(t=0) = 0\\) 且 \\(F_{drag}(t) \\propto v(t)\\)，即\\(F_{drag} = cv\\)。 数学公式： 由\\(F = ma\\)和\\(\\frac{dv}{dt} = a\\)可得： \\[\\tag{1} \\frac{dv}{dt} = a = \\frac{F}{m}\\] 根据物体受力分析, 其受到向下的重力\\(F_{g} = mg\\)和向上的空气阻力\\(F_{drag} = cv\\)，空气阻力在此假设与物体运动速度成正比关系。则其受力平衡公式为： \\[\\tag{2} F = F_{g} - F_{drag} = mg - cv\\] 综合公式（1）和（2），则得到： \\[\\tag{3} \\frac{dv}{dt} = g - \\frac{c}{m} v\\] 自由落体运动的受力分析 公式求解： 初始条件：\\(v(0) = 0\\) 积分求解(解析解)： \\[v(t) = \\frac {mg}{c}\\left[ 1- exp(-\\frac{c}{m}t) \\right]\\] 结果绘图： c = 15 # drag coeefficient g = 9.8 # Gravity m = 150 # Mass in kg x = seq(0,100, 1) # Time y = m*g/c *(1 - exp(-1 * c / m * x)) # Vecocity plot(x, y, type=&#39;l&#39;, xlab=&#39;Time (s)&#39;, ylab=&#39;Velocity (m/s)&#39;, col=2, lwd=2); grid() 变量表: \\(v(t)\\) - 随时间变化的物体速度 \\(m\\) - 物体质量 \\(g\\) - 重力加速度 \\(a\\) - 物体运动的加速度 \\(c\\) - 空气阻力系数 \\(F\\) - 物体所受的力 \\(F_{g}\\) - 重力 \\(F_{drag}\\) - 空气阻力 "],["nm.html", "Chapter 2 数值方法基础 2.1 隐式与显式求解法 2.2 数值迭代方法 2.3 有限元, 有限差分 ,有限体积 2.4 CFL条件约束 2.5 时空离散化 2.6 初始条件 2.7 边界条件", " Chapter 2 数值方法基础 2.1 隐式与显式求解法 数值方法可分为显式求解(Explicit method)与隐式求解(Implicit method)： Definition 2.1 (显式求解法) 当下一时刻变量由前一时刻变量直接计算得到的，称为显式求解法。数学表达可写为： \\[Y(t+\\Delta t)=F(Y(t))\\] Definition 2.2 (隐式求解法) 当下一时刻变量由一系列公式、矩阵或者迭代算法计算得到，称为隐式求解法。数学表达可写为： \\[G(Y(t), Y(t+\\Delta t))=0\\] 相同时空分辨率条件下，显式求解法的计算速度显著高于隐式求解法，但是隐式求解法可以保证计算的稳定性，因此可采用较大时间步长进行计算，而显式求解法必须受制于CFL条件。 2.2 数值迭代方法 2.2.1 牛顿迭代(Newton Iteration) 牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），是一种在实数域和复数域上近似求解方程的方法。方法使用函数 \\(f (x)\\)的泰勒级数的前面几项来寻找方程\\(f(x) = 0\\)的根。 2.2.2 欧拉方法(Euler Method) 在数学和计算机科学中，欧拉方法，命名自它的发明者萊昂哈德·歐拉，是一种一阶数值方法，用以对给定初值的常微分方程（即初值問題）求解。它是常微分方程數值方法中最基本的显式方法（Explicit method）。 欧拉方法是一个一阶方法，意味着其局部截断误差（每步误差）正比于步长的平方，并且其全局截断误差正比于步长。欧拉方法经常应用于作为构建一些更复杂方法的基础，例如，预估-校正方法。 Definition 2.3 (欧拉方法) 欧拉方法数学表达为: \\[y^{\\prime}(t)=f(t, y(t))\\] \\[y(t_0) = y_0\\] 求解时： \\[y_{n+1} = y_n + h f(t_n, y_n)\\] 其中\\(t_n = t0+nh\\)，\\(h\\)即迭代步长， \\(h = t_{n+1} - t _{n}\\)。 欧拉方法属于显式求解法。 Example 2.1 已知函数： \\[\\frac{dy}{dt} = y\\] \\[y(0)=1\\] 求：\\[y(4) = ?\\] # source: https://en.wikipedia.org/wiki/Euler_method # ============ # SOLUTION to # y&#39; = y, where y&#39; = f(t,y) # then: f &lt;- function(ti,y) y # INITIAL VALUES: t0 &lt;- 0 y0 &lt;- 1 h &lt;- .1 tn &lt;- 4 # Euler&#39;s method: function definition Euler &lt;- function(t0, y0, h, tn, dy.dt) { # dy.dt: derivative function # t sequence: tt &lt;- seq(t0, tn, by=h) # table with as many rows as tt elements: tbl &lt;- data.frame(ti=tt) tbl$yi &lt;- y0 # Initializes yi with y0 tbl$Dy.dt[1] &lt;- dy.dt(tbl$ti[1],y0) # derivative for (i in 2:nrow(tbl)) { tbl$yi[i] &lt;- tbl$yi[i-1] + h*tbl$Dy.dt[i-1] # For next iteration: tbl$Dy.dt[i] &lt;- dy.dt(tbl$ti[i],tbl$yi[i]) } return(tbl) } # Euler&#39;s method: function application r &lt;- Euler(t0, y0, h, tn, f) rownames(r) &lt;- 0:(nrow(r)-1) # to coincide with index n # Exact solution for this case: y = exp(t) # added as an additional column to r r$y &lt;- exp(r$ti) plot(r$ti, r$y, type=&quot;l&quot;, col=&quot;red&quot;, lwd=2) lines(r$ti, r$yi, col=&quot;blue&quot;, lwd=2) grid(col=&quot;black&quot;) legend(&quot;top&quot;, legend = c(&quot;Exact&quot;, &quot;Euler&quot;), lwd=2, col = c(&quot;red&quot;, &quot;blue&quot;)) # TABLE with results: print(r) ## ti yi Dy.dt y ## 0 0.0 1.000000 1.000000 1.000000 ## 1 0.1 1.100000 1.100000 1.105171 ## 2 0.2 1.210000 1.210000 1.221403 ## 3 0.3 1.331000 1.331000 1.349859 ## 4 0.4 1.464100 1.464100 1.491825 ## 5 0.5 1.610510 1.610510 1.648721 ## 6 0.6 1.771561 1.771561 1.822119 ## 7 0.7 1.948717 1.948717 2.013753 ## 8 0.8 2.143589 2.143589 2.225541 ## 9 0.9 2.357948 2.357948 2.459603 ## 10 1.0 2.593742 2.593742 2.718282 ## 11 1.1 2.853117 2.853117 3.004166 ## 12 1.2 3.138428 3.138428 3.320117 ## 13 1.3 3.452271 3.452271 3.669297 ## 14 1.4 3.797498 3.797498 4.055200 ## 15 1.5 4.177248 4.177248 4.481689 ## 16 1.6 4.594973 4.594973 4.953032 ## 17 1.7 5.054470 5.054470 5.473947 ## 18 1.8 5.559917 5.559917 6.049647 ## 19 1.9 6.115909 6.115909 6.685894 ## 20 2.0 6.727500 6.727500 7.389056 ## 21 2.1 7.400250 7.400250 8.166170 ## 22 2.2 8.140275 8.140275 9.025013 ## 23 2.3 8.954302 8.954302 9.974182 ## 24 2.4 9.849733 9.849733 11.023176 ## 25 2.5 10.834706 10.834706 12.182494 ## 26 2.6 11.918177 11.918177 13.463738 ## 27 2.7 13.109994 13.109994 14.879732 ## 28 2.8 14.420994 14.420994 16.444647 ## 29 2.9 15.863093 15.863093 18.174145 ## 30 3.0 17.449402 17.449402 20.085537 ## 31 3.1 19.194342 19.194342 22.197951 ## 32 3.2 21.113777 21.113777 24.532530 ## 33 3.3 23.225154 23.225154 27.112639 ## 34 3.4 25.547670 25.547670 29.964100 ## 35 3.5 28.102437 28.102437 33.115452 ## 36 3.6 30.912681 30.912681 36.598234 ## 37 3.7 34.003949 34.003949 40.447304 ## 38 3.8 37.404343 37.404343 44.701184 ## 39 3.9 41.144778 41.144778 49.402449 ## 40 4.0 45.259256 45.259256 54.598150 2.2.3 龙格-库塔方法(Runge-Kutta Method) 数值分析中，龙格-库塔方法（Runge-Kutta Methods）是用于非线性常微分方程的解的重要的一类隐式或显式迭代法。这些技术由数学家卡尔·龙格和马丁·威尔海姆·库塔于1900年左右发明。 这里介绍最常见的四阶龙格-库塔方法。 Definition 2.4 (龙格-库塔方法) \\[\\frac{dy}{dx} = x^2 + y^2\\] \\[f&#39; = \\frac {dy}{dx}\\] 龙格-库塔方法求解过程为: \\[ k_1 &lt;- h * f&#39; (x_i, y_i)\\] \\[k_2 &lt;- h * f&#39; (x_i + h/2, y_i + k_1/2)\\] \\[k_3 &lt;- h * f&#39; (x_i + h/2, y_i + k_2/2)\\] \\[k_4 = h * f&#39; (x_i + h, y_i + k_3)\\] \\[y_{i+1} = y_i + (k_1 + 2*k_2 + 2*k_3 + k_4) / 6\\] \\(h\\)即迭代步长， \\(h = x_{i+1} - x_i\\)。 实现四阶龙格-库塔算法的R代码： # Define the derivative function dydx &lt;- function(x, y) { return(x^2 + y^2) } # Define the Runge-Kutta method rk4 &lt;- function(y0, x0, h, n) { # Initialize arrays x &lt;- rep(0, n+1) y &lt;- rep(0, n+1) # Set initial values x[1] &lt;- x0 y[1] &lt;- y0 # Iterate over n steps for (i in 1:n) { k1 &lt;- h * dydx(x[i], y[i]) k2 &lt;- h * dydx(x[i] + h/2, y[i] + k1/2) k3 &lt;- h * dydx(x[i] + h/2, y[i] + k2/2) k4 &lt;- h * dydx(x[i] + h, y[i] + k3) y[i+1] &lt;- y[i] + (k1 + 2*k2 + 2*k3 + k4) / 6 x[i+1] &lt;- x[i] + h } # Return the arrays return(data.frame(x=x, y=y)) } # Example usage result=rk4(y0=0, x0=0, h=0.05, n=20) plot(result$x, result$y, type=&#39;b&#39;, col=&#39;red&#39;, main = &#39;4th-order Runge-Kutta Method&#39;);grid() print(result) ## x y ## 1 0.00 0.000000e+00 ## 2 0.05 4.166668e-05 ## 3 0.10 3.333350e-04 ## 4 0.15 1.125027e-03 ## 5 0.20 2.666870e-03 ## 6 0.25 5.209303e-03 ## 7 0.30 9.003475e-03 ## 8 0.35 1.430189e-02 ## 9 0.40 2.135939e-02 ## 10 0.45 3.043447e-02 ## 11 0.50 4.179116e-02 ## 12 0.55 5.570135e-02 ## 13 0.60 7.244788e-02 ## 14 0.65 9.232833e-02 ## 15 0.70 1.156599e-01 ## 16 0.75 1.427853e-01 ## 17 0.80 1.740803e-01 ## 18 0.85 2.099633e-01 ## 19 0.90 2.509068e-01 ## 20 0.95 2.974527e-01 ## 21 1.00 3.502320e-01 2.2.4 皮卡法(Picard Method) 皮卡逐次逼近法（Picard Successive Approximation Method）是常微分方程解的一种主要近似计算方法。皮卡(Picard,(C.-)É)最早在数学上完善处理这样的逐次逼近的函数序列，所以称为皮卡逐次逼近法。 2.3 有限元, 有限差分 ,有限体积 数值方法中主要有有限差分（Finite Difference, FD）、有限元（Finite Element, FE）和有限体积（Finite Volume，FV）法三类。三类方法并无明显优劣之分，但其中各有特点。有限差分法方法简洁，物理意义清晰，编程容易，因而是水文/气象领域应用最多的方法。 有限元法可以保证全局物质/能量守恒，但是无法保证局部守恒；有限体积法弥补了有限元这一缺陷，既可以保证全局守恒，也可以保证局部守恒。 三类方法的数学的意义略有不同：有限差分法计算为空间某一点的值，有限元法计算某一计算单元内的近似拟合曲线，有限体积法作为有限元法的特例，计算该计算单元内的均值。因此对于三种不同方法计算的结果的解读应当略有不同，但实际模型用户层面通常将其视为相同含义。 三种数值方法对比 2.4 CFL条件约束 CFL条件是数值方法求解常/偏微分方程保证其收敛性和稳定性的必要条件，但不是充分条件；以Courant， Fredrichs和Lewy共同命名（cite）。CFL条件即数值方法的时间步长要足够小，方能够保证计算精度，否则结果不收敛或者不稳定。 最简单可以理解为时间推进求解的速度必须大于物理扰动传播的速度，只有这样才能将物理上所有的扰动俘获到。 Definition 2.5 (CFL条件) CFL条件数学表达形式为： \\[ \\frac {c \\Delta t} {\\Delta x ^n} &lt; C_{max}\\] 其中\\(c\\)即为系统中变量的变化速率。\\(C_{max}\\)是保持求解系统稳定和收敛的最大值，常见值为0.5。有的系统中\\(n=1\\)，但有的科学问题中\\(n&gt;1\\)。 2.5 时空离散化 空间离散化，即分割连续的空间称为空间若干子集的过程,由一维\\(\\Delta x\\), 二维\\((\\Delta x, \\Delta y)\\), 或者三维\\((\\Delta x, \\Delta y, \\Delta z)\\)构成的最小计算单元或质点。 时间离散化即模型时间步长，即\\(\\Delta t\\)。 时间步长和空间分辨率的组合关系，对于数值方法求解的稳定性和收敛性都有显著影响。CFL条件是限制因素。为保证数值方法稳定性，空间分辨率越高，则要求时间分辨率也越高，时间分辨率与空间分辨率的（一次或多次）幂存在正比关系。 一维空间离散化 二维空间离散化 三维空间离散化 通常的空间离散化分为结构化(Structured)与非结构化(Unstructured)网格。 结构化网格主要是划分为形状和面积相同的计算单元。矩形规则化网格的好处是：求解过程直观易懂，编程实现简单，并且易于并行化；输入和输出数据都直接使用矩阵方式表达；数据制备、处理和可视化都直观且便捷。规则化网格常见矩形，也有正三角形和正六边形的方案。 非结构化网格的优势在于： 更好的表现不规则三维地形； 更好的表现不规则研究区(流域）的边界，边界条件处理更合理，其边界条件控制也更符合数值理论； 计算单元的面积大小灵活可变，可以在保证整体边界条件情况下，对重点地区进行局部加密——亦或相反设置。非结构化网格既可以保证重点区域的高分辨率，在保证可靠的边界条件情况下，不显著增加计算单元数量，保证重点区域模拟精度和计算负担之间的平衡。 非结构化网格的主要缺陷是： 计算过程相对复杂，仅支持有限元和有限体积法； 数据解读和可视化复杂，需要针对性的数据前处理和后处理软件。 三维空间离散化 2.6 初始条件 Definition 2.6 (初始条件) 初始条件定义为 \\[y(t_0) = y_0\\] 其中\\(t_0\\)为问题的初始时刻，\\(y_0\\)为初始时刻包含目标变量值的向量。 数值方法研究中，模拟结果对初始条件具有一定敏感性。但是，初始条件的敏感性问题与描述该系统的控制方程有关。部分问题的初始条件误差，可以通过一定时间的模型预热(Spin-up)消除；但另有一部分问题（例如Lorenz System为代表的混沌系统），初始条件敏感性极高。 2.7 边界条件 数值方法的边界条件通常分为Dirichlet和Neumann两类。 Definition 2.7 (第一类边界条件) Dirichlet边界条件(Dirichlet Boundary Condition, DBC)是常/偏微分方程的第一类边界条件，也称为固定边界条件，其指定了空间某点的固定值，比如在地下水中，Dirichlet边界条件限定固定地下水水头高度。 Definition 2.8 (第二类边界条件) 诺伊曼边界条件（Neumann boundary condition, NBC) 也被称为常/偏微分方程的“第二类边界条件”，其给定空间特定位置上目标变量的一阶导数，在地下水问题中，通常某一点处固定的流量，如注水或者取水量。 作为三维的数值模型，两类边界条件都可以施加在空间任意位置的任意方向上。 "],["fdm.html", "Chapter 3 有限差分法 3.1 泰勒展开式(Taylor Series) 3.2 构建数值方法 3.3 显式求解法 3.4 隐式求解法 3.5 编程求解 3.6 显式与隐式求解法对比 3.7 二维有限差分", " Chapter 3 有限差分法 3.1 泰勒展开式(Taylor Series) 在数学中，泰勒级数（英語：Taylor series）用无限项连加式——级数来表示一个函数，这些相加的项由函数在某一点的导数求得。泰勒级数是以于1715年发表了泰勒公式的英國数学家布魯克·泰勒（Sir Brook Taylor）来命名的。 泰勒展开式的基本形式： \\[\\begin{equation} f(x) = \\sum_{k=0}^n \\frac{f^{(n)}(0) }{n!}( x) ^{n} \\tag{3.1} \\end{equation}\\] Taylor Series 根据泰勒展开式，通过\\(f(x)\\)和其任意阶的导数，可以获得任意\\(\\Delta x\\)值下的函数值\\(f(x + \\Delta x)\\) ，即: \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}( \\Delta x) ^{n} \\tag{3.2} \\end{equation}\\] 或者在\\(-\\Delta x\\)位置，可写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 - \\frac{f^{&#39;&#39;&#39;}(x)}{3!} \\Delta x^3+\\dotsb + \\frac{f^{(n)}(x) }{n!}(- \\Delta x) ^{n} \\tag{3.3} \\end{equation}\\] 以上公式也可以写为： \\[\\begin{equation} u_{i+1} = u_{i} + \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 + \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n} \\tag{3.4} \\end{equation}\\] \\[\\begin{equation} u_{i-1} = u_{i} - \\frac{u^{&#39;}_{i}}{1!} \\Delta x + \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2 - \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}(- \\Delta x) ^{n} \\tag{3.5} \\end{equation}\\] 在此，我们需要引入截断误差（truncation error）的概念，数学表达为\\(O()\\)。 \\(O(2)\\)和\\(O(3)\\)分别表示为在泰勒展开式上的二阶和三阶导数上的误差。截取误差的阶数越高，误差越小。 \\[O(1) = \\frac{u^{&#39;&#39;}_{i}}{2!} \\Delta x^2+\\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(2) = \\frac{u^{&#39;&#39;&#39;}_{i}}{3!} \\Delta x^3+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] \\[O(3) = \\frac{u^{(4)}_{i}}{4!} \\Delta x^4+\\dotsb + \\frac{u^{(n)}_{i} }{n!}( \\Delta x) ^{n}\\] 何种情况下，泰勒展开式的截断误差为0？ \\(O(0) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x)\\)。则该函数为\\(f(x) = C\\), \\(C\\)为常数。 如图： \\(O(1) = 0\\) 时，意味着：\\(f(x+\\Delta x) = f(x) + f^{&#39;}(x) \\cdot \\Delta x\\)。则该函数为\\(f(x) = ax + b\\)。 如图： 如何依据泰勒级数，得到函数的一阶和二阶导数？ 3.1.1 一阶导数 3.1.1.1 向前估计 (Forward Approximation) 采纳一阶截断误差，我们可将公式(3.2)写为： \\[\\begin{equation} f(x+\\Delta x) = f(x) + \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) - f(x) } {\\Delta x} \\tag{3.6} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac {u_{i+1} - u_{i} } {\\Delta x} \\tag{3.6} \\end{equation}\\] 注：公式(3.6)隐含了\\(O(1)\\)的误差。 向前估计 3.1.1.2 向后估计 (Backward Approximation) 采纳一阶截断误差，我们可将公式(3.3)写为： \\[\\begin{equation} f(x-\\Delta x) = f(x) - \\frac{f&#39;(x)}{1!} \\Delta x + O(1) \\end{equation}\\] 则： \\[\\begin{equation} f&#39;(x) = \\frac {f(x) -f(x-\\Delta x) } {\\Delta x} \\tag{3.7} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i} - u_{i-1}} {\\Delta x} \\tag{3.7} \\end{equation}\\] 注：公式(3.7)隐含了\\(O(1)\\)的误差。 向后估计 3.1.1.3 中心估计 (Central Approximation) 中心估计算法中，我们将从公式(3.2)减去公式(3.3)，得到： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + 2 * \\frac{f^{&#39;&#39;&#39;}(x)}{3!} + ... \\] 截断误差由以上公式右边的第四项（三阶导数）开始，则该公式的截取误差为\\(O(2)\\)，即二阶精度的截取误差，公式表达为： \\[ f(x+\\Delta x) - f(x-\\Delta x) = 0 + 2 * \\frac{f&#39;(x)}{1!} \\Delta x + 0 + O(2) \\] 可得到二阶精度的一阶导数的中心估计： \\[\\begin{equation} f&#39;(x) = \\frac {f(x+\\Delta x) -f(x-\\Delta x) } {2\\Delta x} \\tag{3.8} \\end{equation}\\] 或者 \\[\\begin{equation} u&#39;_{i} = \\frac { u_{i+1} - u_{i-1}} {2\\Delta x} \\tag{3.8} \\end{equation}\\] 公式(3.8)隐含了\\(O(2)\\)的误差，同时(3.6)和(3.7)都隐含了\\(O(1)\\)的误差。 中心估计 3.1.2 二阶导数 我们将公式 (3.2)和(3.3)相加，可得到： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2 \\cdot f(x) + 0 + 2 \\cdot \\frac{f^{&#39;&#39;}(x)}{2!} \\Delta x^2 + 0 + 2 \\cdot \\frac{f^{(4)}(x)} {4!} \\Delta x^4 + \\dotsb \\tag{3.9} \\end{equation}\\] 公式(3.9)来自公式 (3.2)和(3.3)的相加，三阶导数项在相加过程中为零，因此我们截取其三阶截取误差，则公式(3.9)可写为： \\[\\begin{equation} f(x+\\Delta x) + f(x-\\Delta x) = 2f(x) + f^{&#39;&#39;}(x) \\Delta x^2 + O(3) \\tag{3.10} \\end{equation}\\] 根据公式(3.10)，我们可获得函数\\(f(x)\\)在\\(x\\)位置的二阶导数为： \\[\\begin{equation} f^{&#39;&#39;}(x) = \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } + O(3) \\tag{3.11} \\end{equation}\\] 当移除其三阶截断误差\\(O(3)\\)后，我们得到近似的二阶导数： \\[\\begin{align} f^{&#39;&#39;}(x) &amp; \\approx \\frac {1}{ \\Delta x } \\left( \\frac{ f(x+\\Delta x) - f(x) }{ \\Delta x } + \\frac{ f(x) - f(x-\\Delta x) } { \\Delta x } \\right) \\\\ &amp; \\approx \\frac { f(x+\\Delta x) - 2f(x) + f(x-\\Delta x) } { \\Delta x^2 } \\tag{3.12} \\end{align}\\] 将公式一般化，我们可写为以下形式： \\[\\begin{align} u^{&#39;&#39;}_{i} &amp;\\approx \\frac {1}{ \\Delta x } \\left( \\frac{u_{i+1} - u_{i}}{\\Delta x} - \\frac{u_{i} - u_{i-1}}{\\Delta x} \\right) \\\\ &amp; \\approx \\frac { u_{i+1} - 2u_{i} + u_{i-1} } { \\Delta x^2 } \\\\ \\tag{3.12} \\end{align}\\] 二阶导数估计 3.2 构建数值方法 Example 3.1 一根100\\(cm\\)长的铁棍，初始温度25 \\(^\\circ C\\)，在其左右两边分别持续施加100\\(^\\circ C\\)和\\(50 ^\\circ C\\)的温度。 求解：任意时刻铁棍的温度分布。 参考信息： wiki:Thermal_diffusivity wiki:Heat_equation 问题描述 空间微分，如图。 物理定理 能量守恒： 能量变化 = 能量流入 - 能量流出 \\[ \\Delta E = Q _{in} - Q _{out} \\] 控制方程 \\[ 通量 = \\frac {量}{单位时间 \\cdot 单位面积} \\] \\(k\\) - 热传导率[\\(W m^{-1} K ^{-1}\\)]。 \\(c\\) - 比热容(specific heat capacity)[\\(J {kg}^{-1} K ^{-1}\\)]。 \\(\\rho\\) - 密度[\\({kg} m^{-3}\\)]。 \\(A\\) - 截面积[\\(m^2\\)]。 \\(D\\) - 热力学扩散度（Thermal diffusivity）\\(D = \\frac{k}{\\rho c}\\) [\\(m^2 s^{-1}\\)]。 \\[ \\rho * c * \\Delta x * A * \\Delta u = q_{in} * A * \\Delta t - q_{out} * A * \\Delta t\\] 两边同时除以\\(\\rho c \\Delta x A\\)，得到 \\[\\frac {\\Delta u}{\\Delta t} = \\frac{1}{\\rho c} \\frac{q_{in} - q_{out}}{\\Delta x}\\] 以上公式当\\(\\Delta x\\)趋近与0，\\(\\Delta t\\)趋近于0时，得到微分形式： \\[\\frac {\\partial u}{\\partial t} = \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x}\\] \\[q = k \\frac{\\partial u}{\\partial x}\\] 则得到其控制方程： \\[\\begin{equation} \\begin{aligned} \\frac {\\partial u}{\\partial t} &amp;= \\frac{1}{\\rho c} \\frac{\\partial q} {\\partial x} \\\\ &amp;= \\frac{1}{\\rho c} \\frac{k \\frac{\\partial u}{\\partial x} } {\\partial x} \\\\ &amp;= D\\frac{\\partial } {\\partial x} \\left(\\frac{\\partial u}{\\partial x} \\right) \\end{aligned} \\end{equation}\\] 令\\(D=\\frac{k}{\\rho c}\\)，单位[$ m s^{-2}$]，则最终控制方程写为 \\[\\begin{equation} \\frac {\\partial u}{\\partial t} =D\\frac{\\partial ^2 u} {\\partial x^2} \\tag{3.13} \\end{equation}\\] 时空离散化 由一阶泰勒级数可知，控制方程(3.13)左边可写为： \\[\\frac {\\partial u}{\\partial t} = D\\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} + O(1)\\] 控制方程(3.13)左边可写为： \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x} + O(3) \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{\\partial ^2 u} {\\partial x^2} =\\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x} + O(3) \\end{equation}\\] 此时，方程左边在时间尺度上具有一阶截取误差\\(O(1)\\)，方程右边在空间尺度上具有三阶截断误差\\(O(3)\\)。省去误差项，离散化后控制方程写为： \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} }{\\Delta x ^2} \\tag{3.14} \\end{equation}\\] 或者 \\[\\begin{equation} \\frac{u^{t}_{i} - u^{t-1}_{i} }{\\Delta t} = D \\frac{u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} }{\\Delta x ^2} \\tag{3.15} \\end{equation}\\] 求解 3.3 显式求解法 显式求解法以公式(3.14)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = 1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t-1}_{i+1} - 2u^{t-1}_{i} + u^{t-1}_{i-1} \\right) \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + (1- 2\\alpha) u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\\\ u^{t}_{i} &amp;= \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t}_{1} = U_{0}\\) 2 \\(u^{t}_{2} = \\alpha u^{t-1}_{3} + \\beta u^{t-1}_{2} + \\alpha u^{t-1}_{1}\\) 3 \\(u^{t}_{3} = \\alpha u^{t-1}_{4} + \\beta u^{t-1}_{3} + \\alpha u^{t-1}_{2}\\) 4 \\(u^{t}_{4} = \\alpha u^{t-1}_{5} + \\beta u^{t-1}_{4} + \\alpha u^{t-1}_{3}\\) 5 \\(u^{t}_{5} = \\alpha u^{t-1}_{6} + \\beta u^{t-1}_{5} + \\alpha u^{t-1}_{4}\\) … … i-1 … i \\(u^{t}_{i} = \\alpha u^{t-1}_{i+1} + \\beta u^{t-1}_{i} + \\alpha u^{t-1}_{i-1}\\) i+1 … … … n-2 \\(u^{t}_{n-2} = \\alpha u^{t-1}_{n-1} + \\beta u^{t-1}_{n-2} + \\alpha u^{t-1}_{n-3}\\) n-1 \\(u^{t}_{n-1} = \\alpha u^{t-1}_{n} + \\beta u^{t-1}_{n-1} + \\alpha u^{t-1}_{n-2}\\) n 边界条件: \\(u^{t}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} u_{1}^{t} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ u_{n}^{t} \\end{bmatrix} = \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ U_{L} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t} = \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t-1} \\end{equation}\\] 下一时刻(\\(t\\))的变量组成的向量\\(x\\)由一个矩阵\\([A]\\)乘以已知的前一时刻(\\(t-1\\))的向量\\(b\\)获得，即：。 \\[ x = [A] * b \\] 由已知变量的矩阵求解未知变量的方法，称为显式求解法。 3.4 隐式求解法 显式求解法以公式(3.15)作为起点，该公式可变形为： \\[ u^{t}_{i} - u^{t-1}_{i} = \\frac{D \\Delta t}{{\\Delta x}^2} \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\] 令\\(\\alpha = \\frac{D \\Delta t}{\\Delta x^2}\\), \\(\\beta = -1 - 2\\alpha\\)，整理以上公式可得： \\[\\begin{equation} \\begin{aligned} u^{t}_{i} - u^{t-1}_{i} &amp;= \\alpha \\left( u^{t}_{i+1} - 2u^{t}_{i} + u^{t}_{i-1} \\right) \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + (-1- 2\\alpha) u^{t}_{i} + \\alpha u^{t}_{i-1} \\\\ -u^{t-1}_{i} &amp;= \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1} \\end{aligned} \\end{equation}\\] 将以上公式应用于离散点上， 点号 \\(i\\) 公式 1 边界条件: \\(u^{t-1}_{1} = U_{0}\\) 2 \\(-u^{t-1}_{2} = \\alpha u^{t}_{3} + \\beta u^{t}_{2} + \\alpha u^{t}_{1}\\) 3 \\(-u^{t-1}_{3} = \\alpha u^{t}_{4} + \\beta u^{t}_{3} + \\alpha u^{t}_{2}\\) 4 \\(-u^{t-1}_{4} = \\alpha u^{t}_{5} + \\beta u^{t}_{4} + \\alpha u^{t}_{3}\\) 5 \\(-u^{t-1}_{5} = \\alpha u^{t}_{6} + \\beta u^{t}_{5} + \\alpha u^{t}_{4}\\) … … i-1 … i \\(-u^{t-1}_{i} = \\alpha u^{t}_{i+1} + \\beta u^{t}_{i} + \\alpha u^{t}_{i-1}\\) i+1 … … … n-2 \\(-u^{t-1}_{n-2} = \\alpha u^{t}_{n-1} + \\beta u^{t}_{n-2} + \\alpha u^{t}_{n-3}\\) n-1 \\(-u^{t-1}_{n-1} = \\alpha u^{t}_{n} + \\beta u^{t}_{n-1} + \\alpha u^{t}_{n-2}\\) n 边界条件: \\(u^{t-1}_{n} = U_{L}\\) 由此我们得到\\(n\\)个算式，可转换为矩阵形式： \\[\\begin{equation} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2}^{t} \\\\ u_{3}^{t} \\\\ u_{4}^{t} \\\\ \\dots \\\\ u_{i}^{t} \\\\ \\dots \\\\ u_{n-3}^{t} \\\\ u_{n-2}^{t} \\\\ u_{n-1}^{t} \\\\ U_{L} \\end{bmatrix} = - \\begin{bmatrix} u_{1}^{t-1} \\\\ u_{2}^{t-1} \\\\ u_{3}^{t-1} \\\\ u_{4}^{t-1} \\\\ \\dots \\\\ u_{i}^{t-1} \\\\ \\dots \\\\ u_{n-3}^{t-1} \\\\ u_{n-2}^{t-1} \\\\ u_{n-1}^{t-1} \\\\ u_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 更简洁的方式，可写为： \\[\\begin{equation} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; 0 &amp;{\\color{red}1} \\end{bmatrix} \\begin{bmatrix} U_{0} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ U_{L} \\end{bmatrix} ^{t} = - \\begin{bmatrix} u_{1} \\\\ u_{2} \\\\ u_{3} \\\\ u_{4} \\\\ \\dots \\\\ u_{i} \\\\ \\dots \\\\ u_{n-3} \\\\ u_{n-2} \\\\ u_{n-1} \\\\ u_{n} \\end{bmatrix} ^{t-1} \\end{equation}\\] 一个矩阵\\([A]\\)乘以下一时刻(\\(t\\))的变量组成的向量\\(x\\)等于已知的前一时刻(\\(t-1\\))的向量\\(b\\)，求解该方程则可得到\\(x\\)的值，数学表达为： \\[[A] * x = b\\] 通用的求解法为 \\[ x = [A]^{-1} * b \\] 通过已知变量、未知变量和矩阵组成的公式或函数来求解未知变量的过程，称为隐式求解法。 3.5 编程求解 显式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.explicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = DD * DT / (DX * DX) beta = 1-2*alpha CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx = cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 隐式求解法 #&#39; Problem: 1D Heat Transfer #&#39; governing Eqn: du/dt = k/r/c * (dd u / d x^2) #&#39; wiki: https://en.wikipedia.org/wiki/Thermal_diffusivity #&#39; wiki: https://en.wikipedia.org/wiki/Heat_equation #&#39; BC U0 = 100, UL=50 #&#39; IC uic = 25 #&#39; X = c(0, 1) #&#39; D = 23 mm2/s = 2.3e-5 m^2/s #&#39; DX = 0.01 m #&#39; DT = 10 s #&#39; Time = 0 to 1e6 s HT.implicit &lt;- function( U0=100, UL=50, uic = 25, X = 1, DX= 0.1, DT = 1, DD = 2.3e-5, Tmax = 1e5, epsilon = 1e-4, bc2 = NULL, ignore.cfl = FALSE, plot = TRUE ){ T0 = 0 tt = seq(T0, Tmax, DT) NT = length(tt) xx = seq(0, X, DX) NX = X / DX + 1 alpha = -DD * DT / (DX * DX) beta = 1 + 2 * DD * DT / (DX * DX) CFL = DD * DT / (DX * DX) print(CFL) if(!ignore.cfl){ if(CFL &gt;=1 ){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) #&#39; ========================================= ylim = c(min(x0), max(U0, UL)) xlim=c(0, X) if(plot){ plot(xx, x0, type=&#39;b&#39;, col=2, lwd=3, ylim=ylim, xlim=xlim, xlab=xlab, ylab=ylab) grid() lines(x=c(1,1) * 0, y=c(min(x0), U0), lwd=2, col=3, type=&#39;b&#39;) lines(x=c(1,1) * X, y=c(min(x0), UL), lwd=2, col=3, type=&#39;b&#39;) text(x=X/2 , y = uic + diff(ylim)*.051, &#39;Initial condition&#39;, font=2) text(x=X * 0.05 , y = U0, &#39;BC 1&#39;, font=2) text(x=X * 0.95 , y = UL, &#39;BC 2&#39;, font=2) } #&#39; ========================================= mat = matrix(0, nrow = NX, ncol = NX) for(i in 1:NX){ for(j in 1:NX){ if(i==j){ mat[i, j] = beta } if(i+1 == j | i-1 == j ){ mat[i, j] = alpha } } } mat[1,]=c(1, rep(0, NX-1)) mat[NX,]=c(rep(0, NX-1), 1) xm = matrix(NA, nrow=NX, ncol=NT) vs = cbind(rep(0, NX)) # vs[NX/2] = ss b=bx=cbind(x0) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx[1] = U0 bx[NX] = UL xm[, i]=bx b = bx } NT = i xm=xm[, 1:NT] # message(&#39;CFL value = &#39;, CFL) # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) yy = xm; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;time&#39; = tt, &#39;u&#39; = xm, &#39;CFL&#39; = CFL, &#39;DT&#39; = DT, &#39;NT&#39; = NT, &#39;xlim&#39; = xlim, &#39;ylim&#39; = ylim) return(ret) } plot1 &lt;- function(x, nout = 20){ NT = x$NT id=10^seq(0, log10(x$NT), length.out = nout) col=colorspace::diverge_hcl(n=length(id)); lty=1 matplot(x=x$x, y=x$u[, id], type=&#39;l&#39;, ylim=x$ylim, xlim=x$xlim, xlab=xlab, ylab=ylab, col=col, lty=lty) legend(&#39;topright&#39;, paste0(&#39;T=&#39;, x$time[id]+1), col=col, lty=lty, bg=&#39;transparent&#39;) mtext(text = paste(&#39;CFL =&#39;, x$CFL ), side=3, cex=1.5) } plot2 &lt;- function(x){ NT = x$NT id = c(2, 4, 6, 8); nid=length(id) lty=1:nid; col=lty matplot(t(x$u[id, ]), type=&#39;l&#39;, xlab=xlab, ylab=ylab, col=col, lty=lty); grid() legend(&#39;bottomright&#39;,col=col, lty=lty, paste(&#39;Node&#39;, id)) } 3.6 显式与隐式求解法对比 3.6.1 CFL条件 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) xlab =&#39;Distance (m)&#39; ylab = &#39;Temperature (C)&#39; x = HT.implicit(DX= 0.05, DT = 1000, U0=100, UL=50, uic = 25, ignore.cfl=TRUE, plot=FALSE) ## [1] 9.2 plot1(x, nout=10) 3.6.2 计算效率 source(&quot;Code/ch03/ch3_HeatTransferIm.R&quot;) source(&quot;Code/ch03/ch3_HeatTransferEx.R&quot;) Tmax = 1e4 t0 = Sys.time() x=HT.explicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.ex = t1 - t0 t0 = Sys.time() x=HT.implicit(DX= 0.025, DT = 5, U0=100, UL=50, uic = 25, X = 1, ignore.cfl=FALSE, plot=FALSE, Tmax=Tmax) ## [1] 0.184 t1 = Sys.time() tu.im = t1 - t0 message(&#39;Time for implicit =&#39;, tu.im) ## Time for implicit =0.0883409976959229 message(&#39;Time for explicit =&#39;, tu.ex) ## Time for explicit =0.0618879795074463 3.7 二维有限差分 Example 3.2 \\[ s \\frac{dh}{dt} = k_{x} B * \\frac{d^2 h}{d x^2} + k_{y} B * \\frac{d^2 h}{d y^2} + s_s \\] 令\\(D_x = \\frac{k_x B}{s}\\)和\\(D_y = \\frac{k_y B}{s}\\)。 公式推导： 右边： \\[\\frac{\\partial u}{\\partial t} = \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t}\\] 左边： \\[D_x\\frac{\\partial ^2 u}{\\partial x^2} + D_y\\frac{\\partial ^2 u}{\\partial y^2}= D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2}\\] 控制方程离散化后得到： \\[ \\frac{u^{t+1}_{i, j} - u^{t}_{i, j} }{ \\Delta t} = D_x\\frac{u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} }{ {\\Delta x }^2} + D_y\\frac{u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1} }{ {\\Delta y }^2} \\] \\[u^{t+1}_{i, j} - u^{t}_{i, j}= \\frac{D_x \\Delta t}{ {\\Delta x }^2} (u^{t}_{i+1, j} - 2 u^{t}_{i, j} + u^{t}_{i-1, j} ) + \\frac{D_x \\Delta t}{ {\\Delta y }^2} (u^{t}_{i, j+1} - 2 u^{t}_{i, j} + u^{t}_{i, j-1})\\] 令\\(\\alpha = \\frac{D_x \\Delta t}{ {\\Delta x }^2}\\), \\(\\beta = \\frac{D_x \\Delta t}{ {\\Delta y }^2}\\), \\(\\gamma = 1-2\\frac{D_x \\Delta t}{ {\\Delta x }^2} - 2\\frac{D_x \\Delta t}{ {\\Delta y }^2}\\)，公式变为： \\[ u^{t+1}_{i, j} = \\alpha u^{t}_{i+1, j} + \\beta u^{t}_{i, j+1} + \\gamma u^{t}_{i, j} + \\beta u^{t}_{i, j-1} + \\alpha u^{t}_{i-1, j} \\] 二维离散化格点 假设\\(x\\)和\\(y\\)方向总长为\\(L_x\\)和\\(L_y\\)，沿两个方向的离散点数为\\(N_x =L_x / \\Delta x\\), \\(N_y =L_y / \\Delta y\\), \\(N = N_x * N_y\\)。 矩阵形式可表达为： \\[ x = A * b \\] \\[x = \\begin{bmatrix} \\begin{bmatrix} u_{1,1} \\\\ \\dots \\\\ u_{1, N_y} \\end{bmatrix} \\\\ \\begin{bmatrix} u_{2,1} \\\\\\dots \\\\ u_{2, N_y} \\end{bmatrix} \\\\ \\dots \\\\ u_{i,j} \\\\ \\dots \\\\ \\begin{bmatrix} u_{Nx, 1} \\\\ \\dots\\\\ u_{N_x, N_y} \\end{bmatrix} \\end{bmatrix} ^{t}\\] \\[A = \\begin{bmatrix} \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\color{red}1} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\beta &amp; \\dots &amp; \\alpha &amp; {\\gamma} &amp; \\alpha &amp; \\dots &amp; \\beta \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp;0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; \\begin{bmatrix} {\\color{red}1} &amp; 0 &amp; 0 \\\\ 0 &amp; {\\color{red}1} &amp; 0 \\\\ 0 &amp; 0 &amp; {\\color{red}1} \\end{bmatrix} \\\\ \\end{bmatrix} \\] \\[b= \\begin{bmatrix} [U_{1}]_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{2,1} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ \\begin{bmatrix} U_2 \\\\ u_{i,j} \\\\\\dots \\\\ U_3 \\end{bmatrix}_{N_y*1} \\\\ [U_{4}]_{N_y*1} \\end{bmatrix} ^{t-1}\\] 3.7.1 编程求解 显式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Explicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY CFL.x = alpha = DD[1] * DT / (DX * DX) CFL.y = beta = DD[2] * DT / (DY * DY) gamma = 1 - 2 * alpha - 2 * beta message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) # xm = matrix(NA, nrow=N, ncol=NT) vs = cbind(rep(0, N)) # bc2=list(id=10, x=0.01) # vs[bc2$id] = bc2$x b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = mat %*% b + vs * DT if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) x = CA.Explicit(bc1 = c(10, 30,10, 10), uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1000 ) ## CFL value = (0.23 0.23) plot.3d(x) 隐式求解 #&#39; Problem: 1D Confined Aquifer #&#39; governing Eqn: du/dt = DDx * (dd u / d x^2) + DDy * (dd u / d y^2) #&#39; diag.matrix &lt;- function(id = c(-1, 0, 1), x = rep(1, length(id)), n = 3, def.val = 0){ val = matrix(x, ncol=length(id), nrow=1) mat = matrix(def.val, n, n) nid = length(id) for(i in 1:n){ for(j in 1:n){ for(k in 1:nid){ if(i + id[k] == j){ mat[i,j] = val[k] } } } } mat } toBC &lt;- function(idl, x, val){ nbc = length(idl) for(i in 1:nbc){ x[idl[[i]]] = val[i] } x } CA.Implicit &lt;- function( bc1 = c(0, 0, 0,0), bc2 = NULL, uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1e5, ignore.cfl = FALSE, plot = TRUE){ DX=Dxy[1]; DY=Dxy[2]; tt = seq(0, Tmax, DT); NT = length(tt) xx = seq(0, Lxy[1], DX); NX = length(xx) yy = seq(0, Lxy[2], DY); NY = length(yy) # NX = Lxy[1] / DX + 1; NY = Lxy[2] / DY + 1 N = NX * NY alpha = -DD[1] * DT / (DX * DX) beta = -DD[2] * DT / (DY * DY) CFL.x = DD[1] * DT / (DX * DX) CFL.y = DD[2] * DT / (DY * DY) gamma = 1 + 2 * DD[1] * DT / (DX * DX) + 2 * DD[2] * DT / (DY * DY) message(&#39;CFL value = (&#39;, CFL.x, &#39;\\t&#39;, CFL.y, &#39;)&#39;) if(!ignore.cfl){ if(CFL.x &gt;=.5 | CFL.y &gt;=.5){ stop() } } #&#39; ========================================= x0 = rep(uic, NX) mat = diag.matrix(id = c(-NY, -1, 0, 1, NY), n=N, x=c(alpha, beta, gamma, beta, alpha), def.val = 0) dmat = diag.matrix(id=0, x=1, n=N, def.val = 0) idl = list(1:NY, 1+(1:NX - 1)*(NY), (1:NX) * NY, (NX-1)*(NY)+1:NY) nbc = length(idl) id.bc = sort(unique(unlist(idl))) mat[id.bc, ] = dmat[id.bc,] arr = array(NA, dim=c(NY,NX,NT)) vs = cbind(rep(0, N)) b=bx=cbind(rep(uic, N)) b = toBC(idl = idl, x=b, val=bc1) for(i in 1:NT){ if(i&gt;1){ bx = solve(mat, b + vs * DT) if(any(is.nan(bx))) { break } if(mean(abs(b-bx)) &lt; epsilon) { break } } bx = toBC(idl = idl, x=bx, val=bc1) arr[, , i] = matrix(bx, nrow = NY, ncol = NX) b = bx } NT = i arr=arr[,, 1:NT] # message(&#39;Total Timesteps (dt * nt)= &#39;, DT, &#39; * &#39;, NT) # yy = arr; yy[abs(yy)&gt;1e20] = NA ret = list(&#39;x&#39; = xx, &#39;y&#39; = yy, &#39;z&#39; = arr, &#39;time&#39; = tt, &#39;CFL&#39; = c(CFL.x, CFL.y), &#39;DT&#39; = DT, &#39;NT&#39; = NT ) return(ret) } plot.3d &lt;- function(x, nr=3, nc=4, clim=NULL){ par(mfrow=c(nr, nc), mar=c(1,1,1,1)) idx = round(10^seq(0, log10(x$NT), length.out = nc*nr)) z=x$z; z[ is.infinite(abs(z)) ] = NA if(is.null(clim)){ clim = range(z, na.rm = TRUE) } for(i in idx ){ plot3D::persp3D(z=z[, , i], clim=clim, colvar=z[, , i]) mtext(paste(&#39;T =&#39;, x$DT * i), side= 3, line=-1) } } library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) x = CA.Implicit(bc1 = c(10, 30,10, 10), uic = 25, Lxy = c(1000, 1000), Dxy = c(50,50), DD = rep(23 ,2), epsilon = 0.001, DT = 25, Tmax = 1000 ) ## CFL value = (0.23 0.23) plot.3d(x) 对比隐式与显式求解法的时间步长和效率： rm(list=ls()) library(plot3D) source(&quot;Code/ch03/ch3_ConfAq2DEx.R&quot;) source(&quot;Code/ch03/ch3_ConfAq2DIm.R&quot;) Tmax = 1e4 dx = dy = 50 t0 = Sys.time() x1 = CA.Explicit(Tmax = Tmax, DT = 25, Lxy = c(1000, 1000), Dxy = c(dx, dy), ignore.cfl = TRUE) ## CFL value = (0.23 0.23) t1 = Sys.time() tu.ex = t1 - t0 t0 = Sys.time() x2 = CA.Implicit(Tmax = Tmax, DT = 25, Lxy = c(1000, 1000), Dxy = c(dx, dy), ignore.cfl = TRUE) ## CFL value = (0.23 0.23) t1 = Sys.time() tu.im = t1 - t0 df = data.frame( &#39;Type&#39; = c(&#39;Explicit&#39;, &#39;Implicit&#39;), &#39;NT&#39; = c(x1$NT, x2$NT), &#39;DT&#39; = c(x1$DT, x2$DT), &#39;Time&#39; = c(tu.ex, tu.im), &#39;CFL.X&#39; = c(x1$CFL[1], x2$CFL[1]), &#39;CFL.Y&#39; = c(x1$CFL[2], x2$CFL[2]) ) print(df) ## Type NT DT Time CFL.X CFL.Y ## 1 Explicit 401 25 4.811744 secs 0.23 0.23 ## 2 Implicit 401 25 10.126844 secs 0.23 0.23 "],["fem.html", "Chapter 4 有限元法", " Chapter 4 有限元法 "],["fvm.html", "Chapter 5 有限体积法", " Chapter 5 有限体积法 "],["app.html", "Chapter 6 应用案例 6.1 热传播问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） 6.3 承压地下水（Confined Aquifer） 6.4 湖面湍流（Lake Turbulence） 6.5 溶质运移（Solute Transport） 6.6 地貌侵蚀（Landscape Evolution） 6.7 熔岩入侵（Lava Invasion）", " Chapter 6 应用案例 6.1 热传播问题(Heat Transfer) 6.2 大气混沌系统（Chaos System in Atmosphere） spin-up的时间与模型的设计和模型模拟的问题有关，简单的，可以这样估算：D/v. D是初始条件偏离动态平衡的幅度，V是系统中最慢的过程的新陈代谢速率。 同样是研究水文问题，有的模型代谢速度快，预热时间就短，有的模型代谢慢就需要较长代谢时间。 举例子： 海洋模型通常需要上千年的spin-up， 地下水模型spin-up时间都是几十到几百年。水文模型中，有的只需要一两年spin-up，有的耦合地下水之后需要几十年时间，陆面过程模型通常涉及的地下水比较浅，不到一年就可以完成spin-up。 以上讲的模型都可以通过spin-up，将初始条件偏离问题解决，可以说：只要时间足够长，任何的初始条件都可以接受。这类问题属于可以新陈代谢的系统。 另外有一些系统——混沌系统，对于初始条件非常敏感，初始条件的细微差异，就会导致未来不可预测——即蝴蝶效应，细微初始条件或者过程的数值波动导致结果不具有可预测性。 Definition 6.1 洛伦兹方程(Lorenz equation)描述空气流体 运动的一个简化微分方程组.1963年，美国气象学家洛伦兹(Lorenz,E. N.)将描述大气热对流的非线 性偏微分方程组通过傅里叶展开，大胆地截断而导 出描述垂直速度、上下温差的展开系数x(t),y(t),z(t)的三维自治动力系统。 \\[\\begin{align} \\begin{array}{l}\\frac{d x}{d t}=b(y-x) \\\\ \\frac{d y}{d t}=-x z+r x-y \\\\ \\frac{d z}{d t}=x y-a z\\end{array} \\end{align}\\] 利用龙格-库塔方法迭代： \\[\\begin{align} \\begin{array}{l}x(t+\\Delta t)=x(t)+f_{x}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ y(t+\\Delta t)=y(t)+f_{y}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t \\\\ z(t+\\Delta t)=z(t)+f_{z}\\left(x^{\\prime}, y^{\\prime}, z^{\\prime}, t^{\\prime}\\right) \\Delta t\\end{array} \\end{align}\\] rm( list = ls() ) fun.reaction &lt;- function (x, dt, t.end, rt.col = 1:3){ f1 &lt;- function(sigma, x){ sigma * x[2] - sigma * x[1] } f2 &lt;- function(rho, x){ rho * x[1] - x[1] * x[3] - x[2] # rho * x[1] - x[2] } f3 &lt;- function(beta, x){ x[1] * x[2] - beta * x[3] # - beta * x[3] } NT = t.end / dt mat= matrix(0, NT,3) for( i in 1:NT){ x[1] = x[1] + f1(sigma, x) * dt x[2] = x[2] + f2(rho, x) * dt x[3] = x[3] + f3(beta, x) * dt mat[i, ]= x } ret = cbind(1:NT * dt, mat[, rt.col]) colnames(ret) = c(&#39;Time&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;) ret= data.frame(ret) ret } sigma = 10; beta = 8/3; rho = 28 x= c(1, 1, 1) # IC t.end = 50 dt = 0.01 x0 = c(10, 2, 1) x1 = fun.reaction(x = x0, dt, t.end) #&#39; ================================================================== #&#39; ================================================================== x = x1 par(mfrow=c(2,2)) plot(x$x, x$y, type = &#39;l&#39;) plot(x$x, x$z, type = &#39;l&#39;) plot(x$y, x$z, type = &#39;l&#39;) par(mfrow=c(1,1)) # # rgl::plot3d(x[, 2:4]) # stop() #&#39; ================================================================== #&#39; ================================================================== icol=1 epsilon = c(0,1,0) * 10^(-14) x2 = fun.reaction(x = x0 + epsilon, dt, t.end) # x2 = fun.reaction(x = x0+ c(0, 10^-13, 0), dt, t.end) tr = (1:nrow(x1))[x1[, 1] &gt; 40] tr = (1:nrow(x1))[] par(mfrow=c(3,1), mar=c(2, 4, 1, 1)) plot(x1$Time[tr], x1$x[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;X&#39;); grid() lines(x2$Time[tr], x2$x[tr], col=2) plot(x1$Time[tr], x1$y[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Y&#39;); grid() lines(x2$Time[tr], x2$y[tr], col=2) plot(x1$Time[tr], x1$z[tr], type=&#39;l&#39;, col=1, xlab=&#39;Time&#39;, ylab=&#39;Z&#39;); grid() lines(x2$Time[tr], x2$z[tr], col=2) #&#39; ================================================================== #&#39; ================================================================== library(plot3D) x=x1 par(mfrow=c(1,1), mar=c(1, 1, 1, 1)) scatter3D (x=x$x, y=x$y, z=x$z, type = &quot;l&quot;, theta=45, phi=10, bty=&#39;b2&#39;) 图上画的是最简单的Lorenz系统，混沌系统的代表，只有x,y,z三个变量。黑线是控制实验，红线是控制实验基础上给Y加入10的n次方波动。这张图是给Y一个\\(10^{-14}\\)次方的波动，结果是在40天以后，预测结果失去相关性。 6.3 承压地下水（Confined Aquifer） 6.3.1 控制方程 \\[ \\tag{1} s \\frac{dh}{dt} = kB * \\frac{d^2 h}{d x^2} + s_s \\] 公式中变量含义为： \\(s\\) - 储水率 [\\(L \\cdot L^{-1}\\)] \\(h\\) - 水头高度 [\\(L\\)] \\(t\\) - 时间 [\\(T\\)] \\(k\\) - 饱和水力传导度[\\(L^3 T ^{-1} L^{-2}\\)] \\(B\\) - 承压含水层厚度 [\\(L\\)] \\(x\\) - 沿\\(x\\)方向的距离 [\\(L\\)] \\(s_s\\) - 源汇项，即系统获得或者失去水分 [\\(L T^{-1}\\)] \\[\\begin{equation} \\begin{bmatrix} ~\\beta~ &amp; \\alpha &amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\alpha &amp; ~\\beta~ &amp; \\alpha &amp; 0 &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; \\alpha &amp; ~\\beta~ ~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0 &amp; \\dots &amp; \\alpha &amp; ~\\beta~&amp; \\alpha &amp; \\dots &amp; 0 &amp; 0\\\\ \\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots &amp;\\dots \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; \\alpha~&amp; ~\\beta~ &amp; \\alpha &amp; 0 \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; \\alpha &amp; ~\\beta~ &amp; \\alpha \\\\ 0 &amp; 0&amp; 0 &amp; 0 &amp; \\dots &amp; 0 &amp; 0&amp; \\alpha &amp;~\\beta~ \\end{bmatrix} \\begin{bmatrix} h_{1}^{t} \\\\ h_{2}^{t} \\\\ h_{3}^{t} \\\\ h_{4}^{t} \\\\ \\dots \\\\ h_{i}^{t} \\\\ \\dots \\\\ h_{n-3}^{t} \\\\ h_{n-2}^{t} \\\\ h_{n-1}^{t} \\\\ h_{n}^{t} \\end{bmatrix} = -\\begin{bmatrix} h_{1}^{t-1} \\\\ h_{2}^{t-1} \\\\ h_{3}^{t-1} \\\\ h_{4}^{t-1} \\\\ \\dots \\\\ h_{i}^{t-1} \\\\ \\dots \\\\ h_{n-3}^{t-1} \\\\ h_{n-2}^{t-1} \\\\ h_{n-1}^{t-1} \\\\ h_{n}^{t-1} \\end{bmatrix} \\end{equation}\\] 6.4 湖面湍流（Lake Turbulence） 6.5 溶质运移（Solute Transport） 6.6 地貌侵蚀（Landscape Evolution） 6.7 熔岩入侵（Lava Invasion） "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

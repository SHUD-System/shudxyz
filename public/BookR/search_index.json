[["index.html", "R在地球科学中的应用 前言 资源 R能干什么？", " R在地球科学中的应用 舒乐乐，孟宪红，陈昊，李照国，赵林。 中国科学院西北生态环境资源研究院 2023-03-19 前言 R图标 工具不仅仅能完成你的任务，也反过来改变你的思考模式。 “形而上者谓之道，形而下者谓之器” —— 《周易》 本书绝大部分内容和案例都同时支持Windows、macOS和Linux/Unix系统，仅一小部分内容仅限类Unix系统，即Mac OS，Linux和Unix，例如生成动画所使用的软件ImageMagick(imagemagick.org) 资源 本书： https://www.shud.xyz/BookR 练习数据：https://www.shud.xyz/Excercise.zip 第2章：https://www.shud.xyz/RScript/Ch2.R 第4章：https://www.shud.xyz/RScript/Ch4.R 第5章：https://www.shud.xyz/RScript/Ch5.R R能干什么？ 时间序列分析 模拟流域径流，并与观测值比较计算模拟效果 地理数据处理 空间数据统计和计算 爬取网上公开数据 以上为武汉某大学的青年教授发表文章情况，12年累计数量121篇。数据来源于开放数据库Scopus 美国前131所大学5000+名教授文章发表情况：看平均情况，美国教授的文章数48篇，一作文章数12篇；最多产年一作数为3篇。平均数据来自于google scholar和scopus 计算与绘图 计算日地月关系。 国际体育运动中发现服用禁药的绝对数据对比。如果应用到参与国际比赛的运动员数量或人口百分比，美欧国家排位显著靠前。 动画视频 视频链接: www.shud.xyz/bookr/Movie/m1.mp4 视频链接: www.shud.xyz/bookr/Movie/m2.mp4 视频链接: www.shud.xyz/bookr/Movie/GRACE.mp4 视频链接: www.shud.xyz/bookr/Movie/FLOOD.mp4 写书 Bookkdown: https://bookdown.org 小程序 https://shiny.rstudio.com/gallery/ 构建个人网站 https://www.blogdown.org https://bookdown.org/yihui/blogdown/ "],["intro.html", "Chapter 1 R语言介绍 1.1 安装R环境 1.2 安装R扩展包 1.3 运行环境 1.4 如何寻求帮助", " Chapter 1 R语言介绍 R是一种功能非常强大的计算机语言，最初的强项在于统计计算，而它的强大扩展能力，在大量开发包的支持下应用于各方个面。 计算 可视化 三维可视化 辅助视频 1.1 安装R环境 R下载地址：https://cran.r-project.org。安装最新版R即可。 Rstudio下载：https://rstudio.com/products/rstudio/download/。 1.2 安装R扩展包 如我们需要安装以下两个扩展包：dplyr和ggplot2。 install.packages(c(&quot;dplyr&quot;,&quot;ggplot2&quot;, &#39;fields&#39;, &#39;reshape2&#39;)) #绘图包 install.packages(&#39;devtools&#39;) #用于安装正在开发中的软件包。 install.packages(c(&#39;zoo&#39;, &#39;xts&#39;) ) # 时间序列数据 当需要使用rgdal处理空间数据时，需要事先安装gdal。GDAL下载地址：https://gdal.org install.packages(c(&#39;rasterVis&#39;, &#39;rgdal&#39;, &#39;raster&#39;, &#39;sp&#39;, &#39;sf&#39;, &#39;gstat&#39;)) #空间数据处理 1.3 运行环境 创建一个新的工作空间： 新建一个项目 选择新文件夹 创建一个项目 Env4 Env5 Env6 Env7 1.4 如何寻求帮助 帮助文件 搜索 R社区 Stack Overflow Github issure/bug 给人写信 "],["basic.html", "Chapter 2 R基础知识 2.1 编程基础语法 2.2 数据类型与结构 2.3 可视化 2.4 三维可视化", " Chapter 2 R基础知识 2.1 编程基础语法 以下代码用于展示r的数据操作、基本数据结构和常用的函数。 x = seq(1, 10, by=0.1) # 生产一组数列，间隔为0.1 y = 2 * sin( x ) # 包含 Sin 函数 plot(x, y) # 绘制出(x,y)的曲线。 plot(x=x, y=y, xlab=&#39;x value&#39;, ylab = bquote(2 * sin( x ) ), col=2, type=&#39;o&#39;) lines(x=x, y=abs(y), col=&#39;blue&#39;) mtext(side = 3, text = &#39;Sin(x)&#39;, cex=2, line=-2) grid() length(x) ## [1] 91 mat.v = cbind(x, y) mat.h = rbind(x, y) boxplot(mat.v) class(mat.v) ## [1] &quot;matrix&quot; &quot;array&quot; dim(mat.v) ## [1] 91 2 dim(mat.h) ## [1] 2 91 nrow(mat.v) ## [1] 91 ncol(mat.v) ## [1] 2 2.1.1 函数定义 文件1Exercise/Functions/fun.add.R内容： fun.add &lt;- function(a, b){ return (a + b) } 文件2add.R内容： source(&#39;Exercise/Functions/fun.add.R&#39;) fun.add(2, 3) ## [1] 5 2.1.2 文件管理 2.2 数据类型与结构 数字：numeric 即一维数组， 常用的函数length, class等。 x0 = rnorm(100) plot(x0) 数据框：data.frame x=readRDS(&#39;Exercise/Data_RDS/JCR.RDS&#39;) length(x) ## [1] 6 dim(x) ## [1] 14492 6 head(x) #前5组元素 ## c1 ## 1 Acoustics ## 2 Acoustics ## 3 Acoustics ## 4 Acoustics ## 5 Acoustics ## 6 Acoustics ## name ## 1 Ultrasonics Sonochemistry ## 2 Ultrasound In Obstetrics &amp; Gynecology ## 3 Ultraschall In Der Medizin ## 4 Ieee-acm Transactions On Audio Speech And Language Processing ## 5 Journal Of Sound And Vibration ## 6 Ieee Transactions On Ultrasonics Ferroelectrics And Frequency Control ## ISSN cites IF CR ## 1 1350-4177 17314 7.279 1 ## 2 0960-7692 12336 5.595 1 ## 3 0172-4614 2238 4.613 3 ## 4 2329-9290 3110 3.531 2 ## 5 0022-460X 36167 3.123 1 ## 6 0885-3010 11266 2.989 1 View(x) 字符：character levels(x$name)[1:5] ## [1] &quot;&quot; ## [2] &quot;2d Materials&quot; ## [3] &quot;3 Biotech&quot; ## [4] &quot;3d Printing And Additive Manufacturing&quot; ## [5] &quot;4or-a Quarterly Journal Of Operations Research&quot; 向量：vector vec = cbind(1:10) plot(vec) 1. 矩阵：matrix x.mat = as.matrix(x) class(x.mat) ## [1] &quot;matrix&quot; &quot;array&quot; length(x.mat) ## [1] 86952 因子：factor library(ggplot2) head(levels(x$c1)) ## [1] &quot;Acoustics&quot; &quot;Agricultural Economics &amp; Policy&quot; ## [3] &quot;Agricultural Engineering&quot; &quot;Agriculture, Dairy &amp; Animal Science&quot; ## [5] &quot;Agriculture, Multidisciplinary&quot; &quot;Agronomy&quot; 逻辑：logical x = seq(-pi*2, pi * 2, by=0.01) y = sin(x) tf = (y &gt; 0) df = data.frame(x, y, tf) plot(x, y, type = &#39;o&#39;, pch = 19, col = tf+1, xlab=&#39;X&#39;, ylab = &#39;Y = sin(x)&#39;) abline(v = 0, col=&#39;red&#39;, lwd=4) #在x = 0处添加垂直线条， abline(h = 0, col=&#39;blue&#39;, lwd=4) #在y = 0处添加水平线条， grid() # 添加坐标网格 2.3 可视化 par(mar = c(4, 4, .1, .1)) # 绘图的四边边界 x = seq(-pi*2, pi * 2, by=0.01) y = sin(x) plot(x, y, type = &#39;l&#39;, pch = 19, xlab=&#39;X&#39;, ylab = &#39;Y = sin(x)&#39;) abline(v = 0, col=&#39;red&#39;, lwd=4) #在x = 0处添加垂直线条， abline(h = 0, col=&#39;blue&#39;, lwd=4) #在y = 0处添加水平线条， grid() # 添加坐标网格 (#fig:fig.v1)R绘图结果 n=1000 x = 1:n y = abs(rnorm(n, mean=10, sd=3)) y.sort = sort(y) par(mfrow=c(2,2)) plot(x, y.sort, log=&#39;&#39;); grid() plot(x, y.sort, log=&#39;x&#39;); grid() plot(x, y.sort, log=&#39;y&#39;); grid() plot(x, y.sort, log=&#39;xy&#39;); grid() Figure 2.1: 绘图：排序的随机数 2.4 三维可视化 install.package(&#39;rgl&#39;) library(rgl) with(iris, plot3d(Sepal.Length, Sepal.Width, Petal.Length, type=&quot;s&quot;, col=as.numeric(Species))) "],["tsd.html", "Chapter 3 时间序列分析", " Chapter 3 时间序列分析 We describe our methods in this chapter. "],["spatial.html", "Chapter 4 空间分析与可视化 4.1 矢量数据 4.2 栅格数据 4.3 可视化 4.4 三维可视化", " Chapter 4 空间分析与可视化 https://nceas.github.io/oss-lessons/spatial-data-gis-law/3-mon-intro-gis-in-r.html https://desktop.arcgis.com/zh-cn/arcmap/10.3/manage-data/raster-and-images/what-is-raster-data.htm 基本数据类型：矢量与栅格。 矢量数据 栅格数据 数据存储量小 数据存储量大 空间位置精度高 空间位置精度低 用网络连接法能完整描述拓扑关系 难于建立网络连接关系 输出简单容易，绘图细腻、精确、美观 输出速度快，但绘图粗糙、不美观 可对图形及其属性进行检索、更新和综合 便于面状数据处 数据结构复杂 数据结构简单 获取数据慢 快速获取大量数据 数学模拟困难 数学模拟方便 多种地图叠合分析困难 多种地图叠合分析方便 不能直接处理数字图像信息 能直接处理数字图像信息 空间分析不容易实现 空间分析易于进行 边界复杂、模糊的事物难以描述 容易描述边界复杂、模糊的事物 数据输出的费用较高 技术开发费用低 矢量与栅格数据结构的比较 4.1 矢量数据 加载需要的库 library(raster) #raster包用于绘图 library(sp) #sp包用于矢量数据操作 library(rgdal) # rgdal用于读写数据 library(rgeos) # rgeos用于空间分析 由坐标产生数据 # ================================================================ # readWKT, 由坐标产生矢量文件 # ================================================================ g = list() g[[1]]=readWKT(&quot;POINT(6 10)&quot;) g[[2]]=readWKT(&quot;LINESTRING(3 4,10 50,20 25)&quot;) g[[3]]=readWKT(&quot;POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))&quot;) g[[4]]=readWKT(&quot;MULTIPOINT((3.5 5.6),(4.8 10.5))&quot;) g[[5]]=readWKT(&quot;MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))&quot;) g[[6]]=readWKT(&quot;MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))&quot;) g[[7]]=readWKT(&quot;GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))&quot;) par(mfrow=c(2, 4)) for(i in 1:7){ plot(g[[i]], axes=TRUE) } (#fig:ch4.readWKT)readwkt # ================================================================ # 读取坐标，并产生SpatialLines文件。 # ================================================================ xy=read.table(&#39;Exercise/Data_text/xy.csv&#39;, header = TRUE) x=xy[1:100, 1] y=xy[1:100, 2] str = paste(&quot;LINESTRING(&quot;, paste( paste(x, y), collapse = &#39;, &#39; ), &quot;)&quot; ) sp.line = readWKT(str) crs(sp.line) = sp::CRS(&quot;+init=epsg:4326&quot;) graphics.off() plot(sp.line, axes=TRUE) points(x, y, col=2, pch=19) grid() crs(sp.line) ## Coordinate Reference System: ## Deprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs ## WKT2 2019 representation: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;, ## ID[&quot;EPSG&quot;,1166]], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;, ## ID[&quot;EPSG&quot;,1152]], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;, ## ID[&quot;EPSG&quot;,1153]], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;, ## ID[&quot;EPSG&quot;,1154]], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;, ## ID[&quot;EPSG&quot;,1155]], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;, ## ID[&quot;EPSG&quot;,1156]], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,7030]], ## ENSEMBLEACCURACY[2.0], ## ID[&quot;EPSG&quot;,6326]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8901]], ## CS[ellipsoidal,2], ## AXIS[&quot;longitude&quot;,east, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, ## ID[&quot;EPSG&quot;,9122]]], ## AXIS[&quot;latitude&quot;,north, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, ## ID[&quot;EPSG&quot;,9122]]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]]] 读取shp数据 # ================================================================ # 读取SHP文件 # ================================================================ sp1 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/Province.shp&#39;) sp2 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/City.shp&#39;) sp3 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/TibetPlateau.shp&#39;) par(mfrow = c(1, 2)) plot(sp1) plot(sp1, col=rainbow(10)) (#fig:ch4.read.sp)矢量地图 渔网 由自定义函数实现渔网功能。 # ================================================================ # 产生渔网矢量文件 # ================================================================ #install.packages(&#39;abind&#39;) # 此函数需要abind包。 fishnet &lt;- function(ext, crs=sp::CRS(&quot;+init=epsg:4326&quot;), n=10, dx=diff(ext[1:2])/n, dy=dx ){ xmin = ext[1] xmax = ext[2] ymin = ext[3] ymax = ext[4] dx = min(dx, diff(ext[1:2])) dy = min(dy, diff(ext[3:4])) xx=seq(ext[1], ext[2], by=dx) yy=seq(ext[3], ext[4], by=dy) nx = length(xx) ny = length(yy) xy=expand.grid(xx,yy) xm = matrix(xy[,1], nx,ny) ym = matrix(xy[,2], nx, ny) xloc=abind::abind(as.matrix(xm[-nx, -ny]), as.matrix(xm[-nx, -1]), as.matrix(xm[-1, -1]), as.matrix(xm[-1, -ny]), as.matrix(xm[-nx, -ny]), along=3) yloc=abind::abind(as.matrix(ym[-nx, -ny]), as.matrix(ym[-nx, -1]), as.matrix(ym[-1, -1]), as.matrix(ym[-1, -ny]), as.matrix(ym[-nx, -ny]), along=3) df=data.frame(as.numeric(apply(xloc, 1:2, min)), as.numeric(apply(xloc, 1:2, max)), as.numeric(apply(yloc, 1:2, min)), as.numeric(apply(yloc, 1:2, max))) df = data.frame(df, rowMeans(df[,1:2]), rowMeans(df[,1:2+2]) ) colnames(df) = c(&#39;xmin&#39;,&#39;xmax&#39;,&#39;ymin&#39;, &#39;ymax&#39;,&#39;xcenter&#39;,&#39;ycenter&#39;) str=paste(&#39;GEOMETRYCOLLECTION(&#39;, paste(paste(&#39;POLYGON((&#39;, paste(xm[-nx, -ny], ym[-nx, -ny], &#39;,&#39; ), paste(xm[-nx, -1], ym[-nx, -1], &#39;,&#39;), paste(xm[-1, -1], ym[-1, -1], &#39;,&#39;), paste(xm[-1, -ny], ym[-1, -ny], &#39;,&#39;), paste(xm[-nx, -ny], ym[-nx, -ny], &#39;&#39; ), &#39;))&#39; ) , collapse =&#39;,&#39;), &#39;)&#39; ) SRL = rgeos::readWKT(str) ret = sp::SpatialPolygonsDataFrame( Sr=SRL, data=df, match.ID = TRUE) raster::crs(ret) = crs return(ret) } sp3 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/TibetPlateau.shp&#39;) ext = raster::extent(sp3) sp.fn = fishnet(ext=ext, dx=2) cent.xy = gCentroid(sp.fn, byid=TRUE) graphics.off() plot(sp.fn) plot(add=TRUE, sp3, border=2) points(cent.xy, col=3, cex=.5) 重投影 # ================================================================ # 重投影 # ================================================================ library(rgeos) crs(sp.fn) ## Coordinate Reference System: ## Deprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs ## WKT2 2019 representation: ## GEOGCRS[&quot;WGS 84&quot;, ## ENSEMBLE[&quot;World Geodetic System 1984 ensemble&quot;, ## MEMBER[&quot;World Geodetic System 1984 (Transit)&quot;, ## ID[&quot;EPSG&quot;,1166]], ## MEMBER[&quot;World Geodetic System 1984 (G730)&quot;, ## ID[&quot;EPSG&quot;,1152]], ## MEMBER[&quot;World Geodetic System 1984 (G873)&quot;, ## ID[&quot;EPSG&quot;,1153]], ## MEMBER[&quot;World Geodetic System 1984 (G1150)&quot;, ## ID[&quot;EPSG&quot;,1154]], ## MEMBER[&quot;World Geodetic System 1984 (G1674)&quot;, ## ID[&quot;EPSG&quot;,1155]], ## MEMBER[&quot;World Geodetic System 1984 (G1762)&quot;, ## ID[&quot;EPSG&quot;,1156]], ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,7030]], ## ENSEMBLEACCURACY[2.0], ## ID[&quot;EPSG&quot;,6326]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8901]], ## CS[ellipsoidal,2], ## AXIS[&quot;longitude&quot;,east, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, ## ID[&quot;EPSG&quot;,9122]]], ## AXIS[&quot;latitude&quot;,north, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, ## ID[&quot;EPSG&quot;,9122]]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;World.&quot;], ## BBOX[-90,-180,90,180]]] spx = spTransform(sp.fn, sp::CRS(&quot;+init=epsg:2342&quot;)) #西安1980，高斯克吕格99E par(mfrow=c(1, 2)) plot(sp.fn, axes=T) plot(spx, axes=T) Figure 4.1: 重投影矢量地图 数据分析与操作 #重投影数据 s1 = spTransform(sp1, sp::CRS(&quot;+init=epsg:2342&quot;)) s2 = spTransform(sp2, sp::CRS(&quot;+init=epsg:2342&quot;)) s3 = spTransform(sp3, sp::CRS(&quot;+init=epsg:2342&quot;)) # 获得各省的面积 ia=gArea(s1, byid=TRUE) # 各省的几何中心点 co1 = cbind(coordinates(sp1), coordinates(s1)) # 经纬度和投影后的城市坐标 co2 = cbind(coordinates(sp2), coordinates(s2)) graphics.off() plot(s1, col=rainbow(10)); plot(add=T, s2, pch=18, cex=2) #省会点 points(co1[, 3:4]) # 几何中心点 # 合并省界 sp.cn = gUnaryUnion(sp1) plot(sp.cn) Figure 4.2: 合并地图要素 # ------------缓冲区 buf50 = gBuffer(s3, width=50e3) buf100 = gBuffer(s3, width=100e3) plot(buf100); plot(add=T, border=2, buf50); plot(add=T, border=3, s3) Figure 4.3: 空间缓冲区 # ------------简化线条 simp2 = gSimplify(s3, tol=2000) simp20 = gSimplify(s3, tol=20000) simp50 = gSimplify(s3, tol=50000) par(mfrow=c(1, 3)) plot(s3) plot(simp20) plot(simp50) Figure 4.4: 简化线条要素 # ------------泰森多边形 # install.packages(&#39;deldir&#39;) # 需要deldir支持 require(sp) require(deldir) voronoipolygons = function(layer) { crds = layer@coords z = deldir(crds[,1], crds[,2]) w = tile.list(z) polys = vector(mode=&#39;list&#39;, length=length(w)) for (i in seq(along=polys)) { pcrds = cbind(w[[i]]$x, w[[i]]$y) pcrds = rbind(pcrds, pcrds[1,]) polys[[i]] = Polygons(list(Polygon(pcrds)), ID=as.character(i)) } SP = SpatialPolygons(polys) voronoi = SpatialPolygonsDataFrame(SP, data=data.frame(x=crds[,1], y=crds[,2], row.names=sapply(slot(SP, &#39;polygons&#39;), function(x) slot(x, &#39;ID&#39;)))) } vp=voronoipolygons(s2) graphics.off() plot(vp, border=4,axes=TRUE) plot(add=T, s2, col=2, pch=19) 4.2 栅格数据 最简形式的栅格由按行和列（或格网）组织的像元（或像素）矩阵组成，其中的每个像元都包含一个信息值（例如温度）。栅格可以是数字航空像片、卫星影像、数字图片或甚至扫描的地图。（参考什么是栅格数据？ # ================================================================ # 读取数据及等高线 # ================================================================ r = raster(&#39;Exercise/Data_spatial/DEM.tif&#39;) r.crop = crop(r, sp3) # 切除包含区域 r.tp = mask(r.crop, sp3) # 蒙版，切除不规则边界外的数据 graphics.off() plot(r.tp) plot(sp3, add=TRUE) contour(r.tp, add=T, col=&#39;gray30&#39; ) 重采样 # ================================================================ # 重采样 # ================================================================ t01 = raster() extent(t01) = extent(r.tp) t05=t01 res(t01) = 0.1 # 分辨率0.1度 res(t05) = 0.5 # 分辨率0.5度 r1 = resample(r.tp, t01, method = &#39;bilinear&#39;) #双线性插值，0.1度 r2 = resample(r.tp, t05, method = &#39;ngb&#39;) #最临近法，0.5度 r3 = resample(r.tp, t01, method = &#39;ngb&#39;) #最临近法，0.5度 par(mfrow=c(2,2)) plot(r.tp, main=paste0(&#39;Original, res=&#39;, mean(res(r.tp)))) plot(r1, main=&#39;res=0.1, bilinear&#39;) plot(r2, main=&#39;res=0.5, ngb&#39;) plot(r3, main=&#39;res=0.1, ngb&#39;) (#fig:ch4.resample)栅格数据重采样 矢量数据重投影 # ================================================================ # 矢量数据重投影 # ================================================================ rp = projectRaster(r.tp, crs=crs(s3)) #栅格数据重投影 par(mfrow=c(1,2)) plot(rp); plot(add=T, s3) plot(r.tp); plot(add=T, sp3) (#fig:ch4.reproject)栅格数据重投影 空间随机采样和绘图 # ================================================================ # 空间随机采样和绘图 # ================================================================ n=50 xyz=raster::sampleRandom(r.tp, size=n, xy=TRUE) graphics.off() plot(r.tp) points(xyz[, 1:2],col=2) # 更复杂的作图效果 xrand = rnorm(n) pch = rep(25, n) # 符号 pch[xrand &gt; 0] = 17 col=rep(4, n) # 符号颜色 col[xrand &gt; 0] = 2 cex = (abs(xrand)^.6) # 符号大小 zlim=cellStats(r.tp, range) brks = round(seq(zlim[1], zlim[2], length.out = n), -2) colbar = colorspace::diverge_hcl(n=n) graphics.off() plot(sp3, axes=TRUE) # plot(r, add=T, legend=FALSE, alpha=0.5) plot(r.tp, add=TRUE, col=colbar, brks=brks, legend=FALSE) points(xyz[, 1:2], col=col, pch=pch, cex=cex) plot(add=T, sp3) grid() plot(r.tp, legend.only=TRUE, breaks=brks, col=colbar, smallplot=c(c(0.2, 0.8), c(0.0, 0.03)+0.25 ), # legend.width=5, legend.shrink=.7, cex=5, horizontal=T, axis.args=list(col.axis=&#39;blue&#39;, lwd = 0, font.axis=4, cex.axis=1.5,tck = 0, line=-.85, at=brks, cex.axis=.8) # ,legend.args=list(side=4, text=&#39;mm&#39;,col=4,font=2, cex=1.5) ) 空间插值 # ================================================================ # 空间插值 # ================================================================ #### Thin plate spline model # install.packages(&#39;fields&#39;) #需要fields 支持 library(fields) rx = r1 tps &lt;- fields::Tps(xyz[, 1:2], xyz[, 3]) ## Warning: ## Grid searches over lambda (nugget and sill variances) with minima at the endpoints: ## (GCV) Generalized Cross-Validation ## minimum at right endpoint lambda = 9.073926e-06 (eff. df= 47.49998 ) p &lt;- raster(rx) p &lt;- interpolate(p, tps) p &lt;- mask(p, rx) graphics.off() plot(p); points(xyz[, 1:2]); plot(add=T, sp3) contour(p, add=T, col=&#39;gray30&#39;) # -----计算插值的误差。计算较慢----- # se &lt;- interpolate(p, tps, fun=predictSE) # se &lt;- mask(se, rx) # plot(se); points(xyz[, 1:2]); plot(add=T, sp3) # contour(se, add=T, col=&#39;gray30&#39;) 地形分析 # ================================================================ # 地形分析 # ================================================================ x = raster::slopeAspect(r.tp) # 计算坡度和坡向 par(mfrow=c(1,2)) plot(x[[1]], main=names(x)[1]) plot(x[[2]], main=names(x)[2]) (#fig:ch4.terrain)地形分析 矢量栅格化 # ================================================================ # 矢量栅格化 # ================================================================ r.sp1=rasterize(x=sp1,y=t01) t01[]=1 par(mfrow=c(1,2)) plot(t01); plot(add=T, sp1) plot(r.sp1) (#fig:ch4.rasterize)矢量数据栅格化 读取NetCDF数据 # ================================================================ # 读取NetCDF数据 # ================================================================ fn =&#39;Exercise/Data_nc/GLDAS_NOAH10_3H.A20030107.0000.021.nc4&#39; library(ncdf4) ncid=nc_open(fn) #打开文件 print(names(ncid)) ## [1] &quot;filename&quot; &quot;writable&quot; &quot;id&quot; &quot;error&quot; &quot;safemode&quot; ## [6] &quot;format&quot; &quot;is_GMT&quot; &quot;groups&quot; &quot;fqgn2Rindex&quot; &quot;ndims&quot; ## [11] &quot;natts&quot; &quot;dim&quot; &quot;unlimdimid&quot; &quot;nvars&quot; &quot;var&quot; xname = names(ncid$var) print(xname) ## [1] &quot;time_bnds&quot; &quot;Swnet_tavg&quot; &quot;Lwnet_tavg&quot; ## [4] &quot;Qle_tavg&quot; &quot;Qh_tavg&quot; &quot;Qg_tavg&quot; ## [7] &quot;Snowf_tavg&quot; &quot;Rainf_tavg&quot; &quot;Evap_tavg&quot; ## [10] &quot;Qs_acc&quot; &quot;Qsb_acc&quot; &quot;Qsm_acc&quot; ## [13] &quot;AvgSurfT_inst&quot; &quot;Albedo_inst&quot; &quot;SWE_inst&quot; ## [16] &quot;SnowDepth_inst&quot; &quot;SoilMoi0_10cm_inst&quot; &quot;SoilMoi10_40cm_inst&quot; ## [19] &quot;SoilMoi40_100cm_inst&quot; &quot;SoilMoi100_200cm_inst&quot; &quot;SoilTMP0_10cm_inst&quot; ## [22] &quot;SoilTMP10_40cm_inst&quot; &quot;SoilTMP40_100cm_inst&quot; &quot;SoilTMP100_200cm_inst&quot; ## [25] &quot;PotEvap_tavg&quot; &quot;ECanop_tavg&quot; &quot;Tveg_tavg&quot; ## [28] &quot;ESoil_tavg&quot; &quot;RootMoist_inst&quot; &quot;CanopInt_inst&quot; ## [31] &quot;Wind_f_inst&quot; &quot;Rainf_f_tavg&quot; &quot;Tair_f_inst&quot; ## [34] &quot;Qair_f_inst&quot; &quot;Psurf_f_inst&quot; &quot;SWdown_f_tavg&quot; ## [37] &quot;LWdown_f_tavg&quot; # View(ncid$var[[3]]) mat=ncvar_get(ncid, varid = &#39;SoilMoi0_10cm_inst&#39;) #读取数据矩阵 lon = ncvar_get(ncid, varid = &#39;lon&#39;) # 读取x坐标 lat = ncvar_get(ncid, varid = &#39;lat&#39;) # 读取y坐标 nc_close(ncid) #关闭文件 graphics.off() image(lon, lat, mat) # 通过函数将nc转为Raster read.nc2Raster &lt;- function(fn, fid=ncdf4::nc_open(fn), plot=TRUE, varid=2, xname=NULL, yname=NULL, flip=TRUE){ nv = fid$nvars if(is.character(varid)){ varid = varid }else{ vns = names(fid$var) if(nv&gt;0){ varid = vns[varid] }else{ varid = vns[1] } } if(is.null(xname) | is.null(yname)){ dn = names(fid$dim) yname = dn[grepl(&#39;^lat|^x&#39;, tolower(dn) )] xname = dn[grepl(&#39;^lon|^y&#39;, tolower(dn) )] } x = ncdf4::ncvar_get(fid, xname) y = ncdf4::ncvar_get(fid, yname) nx=length(x); ny=length(y); dx=mean(diff(x)); dy=mean(diff(y)) r = raster::raster(ncols=nx, nrows=ny) raster::extent(r) = c(min(x), max(x), min(y), max(y)) + c(-dx, dx, -dy, dy)/2 val = ncdf4::ncvar_get(fid, varid) nc_close(fid) # dim(val) if(flip){ idx = ny:1 }else{ idx = 1:ny } ndims = length(dim(val)) if(ndims==3){ nd = dim(val) rl = list() for(i in 1:nd[3]){ r = raster::setValues(r, t(val[, idx, i]) ) rl[[i]] = r } rs = raster::stack(rl) }else{ rs = raster::setValues(r, t(val[, idx ]) ) } if(plot){ raster::plot(rs, main=varid) } rs } graphics.off() r.nc = read.nc2Raster(fn, varid = 3) 多层NetCDF文件转为Raster # ================================================================ # 多层NetCDF文件转为Raster，生成动画。 # ================================================================ fn = &#39;Exercise/Data_nc/soilw.mon.ltm.v2.nc&#39; library(ncdf4) library(rasterVis) ncid=nc_open(fn) print(names(ncid)) ## [1] &quot;filename&quot; &quot;writable&quot; &quot;id&quot; &quot;error&quot; &quot;safemode&quot; ## [6] &quot;format&quot; &quot;is_GMT&quot; &quot;groups&quot; &quot;fqgn2Rindex&quot; &quot;ndims&quot; ## [11] &quot;natts&quot; &quot;dim&quot; &quot;unlimdimid&quot; &quot;nvars&quot; &quot;var&quot; xname = names(ncid$var) print(xname) ## [1] &quot;climatology_bounds&quot; &quot;soilw&quot; &quot;valid_yr_count&quot; # View(ncid$var[[3]]) ndims = ncid$ndims names(ncid$dim) ## [1] &quot;lon&quot; &quot;lat&quot; &quot;time&quot; &quot;nbnds&quot; mat=ncvar_get(ncid, varid = &#39;soilw&#39;) # 读取土壤湿度数据 lon = ncvar_get(ncid, varid = &#39;lon&#39;) lat = ncvar_get(ncid, varid = &#39;lat&#39;) nc_close(ncid) dim(mat) ## [1] 720 360 12 image(mat[, , 1]) # (#fig:ch4.stack-1)多层NetCDF文件转为Raster x.avg = apply(mat, 1:2, mean) image(x.avg) (#fig:ch4.stack-2)多层NetCDF文件转为Raster #----------- rx = read.nc2Raster(fn, flip=F) # 数据返回的是多层矢量。 (#fig:ch4.stack-3)多层NetCDF文件转为Raster names(rx) = month.name 动画查看 # ================================================================ # 动画查看 # ================================================================ cols = rev( colorspace::diverge_hcl(n=50) ) graphics.off() animate(rx, col=cols) 三维地形图 # 需要rgl支持 # install.packages(&#39;rasterVis&#39;) rasterVis::plot3D(r) 三维中国地形图 4.3 可视化 library(raster) library(rgdal) r = raster(&#39;Exercise/Data_spatial/DEM.tif&#39;) sp1 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/Province.shp&#39;) sp2 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/City.shp&#39;) sp3 = readOGR(verbose = FALSE, &#39;Exercise/Data_spatial/TibetPlateau.shp&#39;) plot(r) plot(add=TRUE, sp1, border=&#39;gray60&#39;) plot(add=TRUE, sp2, col=&#39;gold&#39;, pch=19, cex=2) plot(add=TRUE, sp3, col = rgb(0.1, 0, 0, alpha=0.1)) Figure 4.5: 地图 保存绘图 # png(filename=&#39;Map.png&#39;) #最简单输入PNG格式 # pnf(filename=&#39;Map.pdf&#39;) #输出PDF格式 png(filename=&#39;Map.png&#39;, width=279, height=216, res=200, unit=&#39;mm&#39;) #精细数据输出 plot(r) plot(add=TRUE, sp1, border=&#39;gray60&#39;) plot(add=TRUE, sp2, col=&#39;gold&#39;, pch=19, cex=2) plot(add=TRUE, sp3, col = rgb(0.1, 0, 0, alpha=0.1)) dev.off() 开放数据背景 # install.packages(&#39;rosm&#39;) # 需要安装ROSM # install.packages(&#39;prettymapr&#39;) # 需要安装prettymapr library(rosm) library(prettymapr) ns &lt;- makebbox(37, 104, 33, 103) osm.plot(ns) Figure 4.6: OSM地图 loc1 = geocode(&#39;lanzhou&#39;) loc2 = geocode(&#39;maqu&#39;) prettymap({osm.plot(ns) osm.points(loc1$lon, loc1$lat, pch=18, cex=1.5, col=2) osm.points(loc2$lon, loc2$lat, pch=20, cex=1.5, col=3) }, scale.style=&quot;ticks&quot;, scale.tick.cex=0) Figure 4.7: OSM地图 4.4 三维可视化 三维可视化需要使用OpenGL,因此，需要额外安装rgl包。 "],["ai.html", "Chapter 5 机器学习 5.1 可用数据集 5.2 非监督分类 5.3 监督分类 5.4 深度学习(Deep Learning)", " Chapter 5 机器学习 人工智能，机器学习和深度学习之间的关系： 人工智能-机器学习-深度学习(https://blogs.nvidia.com/blog/2016/07/29/whats-difference-artificial-intelligence-machine-learning-deep-learning-ai/) 机器学习方法(https://wiki.seg.org/wiki/Machine_learning) rm(list=ls()) library(stats) # 统计学库 library(NbClust) # 聚类分析 library(factoextra) # 聚类 library(cluster) library(class) library(dendextend) library(e1071) # SVM 支持向量机 library(rpart) ## recursive partitioning library(rpart.plot) library(colorspace) # 绘图色彩库 library(ggplot2) # 绘图库 library(ggraph) # 绘图库 library(GGally) # 绘图库 5.1 可用数据集 Iris数据集是常用的分类实验数据集，由Fisher(1936)收集整理。Iris也称鸢尾花卉数据集，是一类多重变量分析的数据集。数据集包含150个数据样本，分为3类，每类50个数据，每个数据包含4个属性。可通过花萼长度(Sepal Length)，花萼宽度(Sepal Width)，花瓣长度(Petal Length)，花瓣宽度(Petal Width)4个属性预测鸢尾花卉属于（Setosa, Versicolour，Virginica）三个种类中的哪一类。四个特征变量的单位都是厘米(cm)。 m表示样本量的大小，n表示每个样本所具有的特征数。因此在该数据集中，m=150,n=4。 data(iris) idx = as.numeric(iris$Species) id = apply(cbind(1:3), 1, function(x) which(idx==x)[1:5]) knitr::kable( iris[id, ], caption = &#39;Iris (Fisher 1936)数据表(部分)&#39;, booktabs = TRUE ) Table 5.1: Iris (Fisher 1936)数据表(部分) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 1 5.1 3.5 1.4 0.2 setosa 2 4.9 3.0 1.4 0.2 setosa 3 4.7 3.2 1.3 0.2 setosa 4 4.6 3.1 1.5 0.2 setosa 5 5.0 3.6 1.4 0.2 setosa 51 7.0 3.2 4.7 1.4 versicolor 52 6.4 3.2 4.5 1.5 versicolor 53 6.9 3.1 4.9 1.5 versicolor 54 5.5 2.3 4.0 1.3 versicolor 55 6.5 2.8 4.6 1.5 versicolor 101 6.3 3.3 6.0 2.5 virginica 102 5.8 2.7 5.1 1.9 virginica 103 7.1 3.0 5.9 2.1 virginica 104 6.3 2.9 5.6 1.8 virginica 105 6.5 3.0 5.8 2.2 virginica # ================================================================ # 原始数据 # ================================================================ data(iris) x=iris str(x) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ggpairs(x, aes(colour = Species, alpha = 0.4), columns = 1:5, upper=NULL) 5.2 非监督分类 5.2.1 Principal component analysis (PCA) 在多元统计分析中，PCA是一种统计分析、简化数据集的方法。它利用正交变换来对一系列可能相关的变量的观测值进行线性变换，从而投影为一系列线性不相关变量的值，这些不相关变量称为主成分（Principal Components）。具体地，主成分可以看做一个线性方程，其包含一系列线性系数来指示投影方向。PCA对原始数据的正则化或预处理敏感（相对缩放）。 基本思想： 将坐标轴中心移到数据的中心，然后旋转坐标轴，使得数据在C1轴上的方差最大，即全部n个数据个体在该方向上的投影最为分散。意味着更多的信息被保留下来。C1成为第一主成分。 C2第二主成分：找一个C2，使得C2与C1的协方差（相关系数）为0，以免与C1信息重叠，并且使数据在该方向的方差尽量最大。 以此类推，找到第三主成分，第四主成分……第p个主成分。p个随机变量可以有p个主成分[1]。 主成分分析经常用于减少数据集的维数，同时保留数据集当中对方差贡献最大的特征。这是通过保留低维主成分，忽略高维主成分做到的。这样低维成分往往能够保留住数据的最重要部分。但是，这也不是一定的，要视具体应用而定。由于主成分分析依赖所给数据，所以数据的准确性对分析结果影响很大。 PCA被广泛使用于以下方面： - 在特征中找到结构 - 其他机器学习算法的预处理 - 有助于可视化。 x.pca &lt;- prcomp(iris[, -5]) summary(x.pca) ## Importance of components: ## PC1 PC2 PC3 PC4 ## Standard deviation 2.0563 0.49262 0.2797 0.15439 ## Proportion of Variance 0.9246 0.05307 0.0171 0.00521 ## Cumulative Proportion 0.9246 0.97769 0.9948 1.00000 df= data.frame(x.pca$x, &#39;Species&#39;=x$Species) ggpairs(df, aes(colour = Species, alpha = 0.4), columns = 1:5, upper=NULL) (#fig:ch5.pca2)PCA下的iris数据 5.2.2 k-means聚类 K-mean算法的目标是把n个观测放到k个聚类（cluster）中间去，使得每一个观测都被放到离它最近的那个聚类中去，这里“最近”是用这个观测跟相对应的聚类的平均值（mean）的距离（distance）来衡量的。 # 方法1 data(iris) x = iris idx=as.numeric(x$Species) species = levels(x$Species) y = stats::kmeans(x[, 1:3], centers = 3, nstart = 10, iter.max=10) z = table(y$cluster,species[idx]) knitr::kable( z/50, caption = &#39;k-means分类精度&#39;, booktabs = TRUE ) (#tab:ch5.km1)k-means分类精度 setosa versicolor virginica 0 0.1 0.74 1 0.0 0.00 0 0.9 0.26 # 方法2 library(factoextra) data(iris) x=iris[, 1:4] pm= pam(x, k=3) factoextra::fviz_cluster(list(data = x, cluster = pm$clustering), frame.type = &quot;norm&quot;, geom = &quot;point&quot;, stand = FALSE) (#fig:ch5.km2)k-means聚类方法结果 # 不同k值的结果 ks &lt;- 1:6 tot_within_ss &lt;- sapply(ks, function(k) { cl &lt;- kmeans(x[, 1:4], k, nstart = 10) cl$tot.withinss }) graphics.off() plot(ks, tot_within_ss, type = &quot;b&quot;, ylab = &quot;Total within squared distances&quot;, xlab = &quot;Values of k tested&quot;) grid() # -------------------- par(mfrow=c(2,3)) for(i in ks){ cl &lt;- pam(x,i) clusplot(cl, main=paste(&#39;K =&#39;, i), col.p=cl$clustering) } (#fig:ch5.km4)不同k值分类结果 5.2.3 分层聚类(Hierarchical clsutering) Hierarchical clustering有两种策略: Agglomerative和Divisive。 Agglomerative 是一种 自下而上方法。开始假设每一个观测都是独立的聚类(cluster)，然后通过合并相邻的两个聚类 ，再多次迭代达到所有聚类的最高层级——所有观测都属于同一个聚类。 Divisive 是一种自上而下方法。开始假设所有的观测都属于同一个聚类(cluster)，然后通过分离每个聚类中间比较不相似的观测成为下一层，直到所有的观测都属于不同的聚类(cluster)。一般来说，人们用Dendrogram来可视化分层聚类。 # ================================================================ # 分层聚类(Hierarchical clsutering) # ================================================================ # Reference: https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html library(dendextend) d_iris &lt;- dist(iris) # method=&quot;man&quot; # is a bit better hc_iris &lt;- hclust(d_iris, method = &quot;complete&quot;) iris_species &lt;- rev(levels(iris[,5])) dend &lt;- as.dendrogram(hc_iris) # order it the closest we can to the order of the observations: dend &lt;- rotate(dend, 1:150) # Color the branches based on the clusters: dend &lt;- color_branches(dend, k=3) #, groupLabels=iris_species) # Manually match the labels, as much as possible, to the real classification of the flowers: labels_colors(dend) &lt;- rainbow_hcl(3)[sort_levels_values( as.numeric(iris[,5])[order.dendrogram(dend)] )] # We shall add the flower type to the labels: labels(dend) &lt;- paste(as.character(iris[,5])[order.dendrogram(dend)], &quot;(&quot;,labels(dend),&quot;)&quot;, sep = &quot;&quot;) # We hang the dendrogram a bit: dend &lt;- hang.dendrogram(dend,hang_height=0.1) # reduce the size of the labels: # dend &lt;- assign_values_to_leaves_nodePar(dend, 0.5, &quot;lab.cex&quot;) dend &lt;- set(dend, &quot;labels_cex&quot;, 0.5) # And plot: par(mar = c(3,3,3,7)) plot(dend, main = &quot;Clustered Iris data set (the labels give the true flower species)&quot;, horiz = TRUE, nodePar = list(cex = .007)) legend(&quot;topleft&quot;, legend = iris_species, fill = rainbow_hcl(3)) library(circlize) par(mar = rep(0,4)) circlize_dendrogram(dend) 5.3 监督分类 5.3.1 KNN分类(k-nearest neighbour classification) # ================================================================ # KNN - k-nearest neighbour classification # ================================================================ set.seed(12L) tr &lt;- sample(150, 50) ts &lt;- sample(150, 50) x=iris[, 1:4] knn_model &lt;- knn(train = x[tr, ],test = x[ts,], iris$Species[tr]) head(knn_model) ## [1] versicolor setosa versicolor setosa setosa setosa ## Levels: setosa versicolor virginica res = table(knn_model, iris$Species[ts]) knitr::kable( res, caption = &#39;kNN分类精度&#39;, booktabs = TRUE ) (#tab:ch5.knn)kNN分类精度 setosa versicolor virginica setosa 20 0 0 versicolor 0 17 2 virginica 0 0 11 mean(knn_model == iris$Species[ts]) ## [1] 0.96 5.3.2 决策树(Decision trees) # ================================================================ # 决策树(Decision trees) # ================================================================ x=iris dt_model &lt;- rpart::rpart(Species ~ ., data = x, method = &quot;class&quot;) graphics.off() rpart.plot::rpart.plot(dt_model) # ----------------------- p &lt;- predict(dt_model, x, type = &quot;class&quot;) res = table(p, x$Species) knitr::kable( res, caption = &#39;分类精度&#39;, booktabs = TRUE ) (#tab:dt.table)分类精度 setosa versicolor virginica setosa 50 0 0 versicolor 0 49 5 virginica 0 1 45 5.3.3 支持向量机(SVM) # ================================================================ # 支持向量机(SVM) # ================================================================ # reference: https://rstudio-pubs-static.s3.amazonaws.com/515710_c0433490253f45c281f74b286c455419.html data(iris) svm_model &lt;- svm(Species ~ ., data=iris, kernel=&quot;radial&quot;) #linear/polynomial/sigmoid/radial summary(svm_model) ## ## Call: ## svm(formula = Species ~ ., data = iris, kernel = &quot;radial&quot;) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: radial ## cost: 1 ## ## Number of Support Vectors: 51 ## ## ( 8 22 21 ) ## ## ## Number of Classes: 3 ## ## Levels: ## setosa versicolor virginica graphics.off() plot(svm_model, data=iris, col=rainbow_hcl(3), Petal.Width~Petal.Length, slice = list(Sepal.Width=3, Sepal.Length=4) ) #------------ pred = predict(svm_model,iris) res = table(Predicted=pred, Actual = iris$Species) knitr::kable( res, caption = &#39;分类精度&#39;, booktabs = TRUE ) (#tab:ch5.tabsvm)分类精度 setosa versicolor virginica setosa 50 0 0 versicolor 0 48 2 virginica 0 2 48 1-sum(diag(res)/sum(res)) ## [1] 0.02666667 5.3.4 随机森林(Random Forest) # ================================================================ # 随机森林(Random Forest) # ================================================================ # Reference: https://lmavila.github.io/markdown_files/RF_Toy.html library(randomForest) set.seed(12L) tr &lt;- sample(150, 100) ts &lt;- sample(150, 50) x=iris rf_model &lt;- randomForest(Species~.,data=x[tr,],ntree=100,proximity=TRUE) print(rf_model) ## ## Call: ## randomForest(formula = Species ~ ., data = x[tr, ], ntree = 100, proximity = TRUE) ## Type of random forest: classification ## Number of trees: 100 ## No. of variables tried at each split: 2 ## ## OOB estimate of error rate: 7% ## Confusion matrix: ## setosa versicolor virginica class.error ## setosa 32 0 0 0.0000000 ## versicolor 0 29 3 0.0937500 ## virginica 0 4 32 0.1111111 res= table(predict(rf_model),x$Species[tr]) knitr::kable( res, caption = &#39;训练集分类精度&#39;, booktabs = TRUE ) (#tab:ch5.)训练集分类精度 setosa versicolor virginica setosa 32 0 0 versicolor 0 29 4 virginica 0 3 32 x.pred&lt;-predict(rf_model,newdata=x[ts,]) res = table(x.pred, x$Species[ts]) knitr::kable( res, caption = &#39;测试集分类精度&#39;, booktabs = TRUE ) (#tab:ch5.)测试集分类精度 setosa versicolor virginica setosa 19 0 0 versicolor 0 13 0 virginica 0 0 18 5.4 深度学习(Deep Learning) 机器学习与深度学习的区别(https://www.inteliment.com/blog/our-thinking/lets-understand-the-difference-between-machine-learning-vs-deep-learning/) 且听下回分解~ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
